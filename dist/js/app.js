(() => {
    var __webpack_modules__ = {
        606: module => {
            var DIFF_DELETE = -1;
            var DIFF_INSERT = 1;
            var DIFF_EQUAL = 0;
            function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
                if (text1 === text2) {
                    if (text1) return [ [ DIFF_EQUAL, text1 ] ];
                    return [];
                }
                if (cursor_pos != null) {
                    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
                    if (editdiff) return editdiff;
                }
                var commonlength = diff_commonPrefix(text1, text2);
                var commonprefix = text1.substring(0, commonlength);
                text1 = text1.substring(commonlength);
                text2 = text2.substring(commonlength);
                commonlength = diff_commonSuffix(text1, text2);
                var commonsuffix = text1.substring(text1.length - commonlength);
                text1 = text1.substring(0, text1.length - commonlength);
                text2 = text2.substring(0, text2.length - commonlength);
                var diffs = diff_compute_(text1, text2);
                if (commonprefix) diffs.unshift([ DIFF_EQUAL, commonprefix ]);
                if (commonsuffix) diffs.push([ DIFF_EQUAL, commonsuffix ]);
                diff_cleanupMerge(diffs, _fix_unicode);
                if (cleanup) diff_cleanupSemantic(diffs);
                return diffs;
            }
            function diff_compute_(text1, text2) {
                var diffs;
                if (!text1) return [ [ DIFF_INSERT, text2 ] ];
                if (!text2) return [ [ DIFF_DELETE, text1 ] ];
                var longtext = text1.length > text2.length ? text1 : text2;
                var shorttext = text1.length > text2.length ? text2 : text1;
                var i = longtext.indexOf(shorttext);
                if (i !== -1) {
                    diffs = [ [ DIFF_INSERT, longtext.substring(0, i) ], [ DIFF_EQUAL, shorttext ], [ DIFF_INSERT, longtext.substring(i + shorttext.length) ] ];
                    if (text1.length > text2.length) diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                    return diffs;
                }
                if (shorttext.length === 1) return [ [ DIFF_DELETE, text1 ], [ DIFF_INSERT, text2 ] ];
                var hm = diff_halfMatch_(text1, text2);
                if (hm) {
                    var text1_a = hm[0];
                    var text1_b = hm[1];
                    var text2_a = hm[2];
                    var text2_b = hm[3];
                    var mid_common = hm[4];
                    var diffs_a = diff_main(text1_a, text2_a);
                    var diffs_b = diff_main(text1_b, text2_b);
                    return diffs_a.concat([ [ DIFF_EQUAL, mid_common ] ], diffs_b);
                }
                return diff_bisect_(text1, text2);
            }
            function diff_bisect_(text1, text2) {
                var text1_length = text1.length;
                var text2_length = text2.length;
                var max_d = Math.ceil((text1_length + text2_length) / 2);
                var v_offset = max_d;
                var v_length = 2 * max_d;
                var v1 = new Array(v_length);
                var v2 = new Array(v_length);
                for (var x = 0; x < v_length; x++) {
                    v1[x] = -1;
                    v2[x] = -1;
                }
                v1[v_offset + 1] = 0;
                v2[v_offset + 1] = 0;
                var delta = text1_length - text2_length;
                var front = delta % 2 !== 0;
                var k1start = 0;
                var k1end = 0;
                var k2start = 0;
                var k2end = 0;
                for (var d = 0; d < max_d; d++) {
                    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                        var k1_offset = v_offset + k1;
                        if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) x1 = v1[k1_offset + 1]; else x1 = v1[k1_offset - 1] + 1;
                        var y1 = x1 - k1;
                        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
                            x1++;
                            y1++;
                        }
                        v1[k1_offset] = x1;
                        if (x1 > text1_length) k1end += 2; else if (y1 > text2_length) k1start += 2; else if (front) {
                            var k2_offset = v_offset + delta - k1;
                            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
                                var x2 = text1_length - v2[k2_offset];
                                if (x1 >= x2) return diff_bisectSplit_(text1, text2, x1, y1);
                            }
                        }
                    }
                    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                        k2_offset = v_offset + k2;
                        if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) x2 = v2[k2_offset + 1]; else x2 = v2[k2_offset - 1] + 1;
                        var y2 = x2 - k2;
                        while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
                            x2++;
                            y2++;
                        }
                        v2[k2_offset] = x2;
                        if (x2 > text1_length) k2end += 2; else if (y2 > text2_length) k2start += 2; else if (!front) {
                            k1_offset = v_offset + delta - k2;
                            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
                                var x1 = v1[k1_offset];
                                y1 = v_offset + x1 - k1_offset;
                                x2 = text1_length - x2;
                                if (x1 >= x2) return diff_bisectSplit_(text1, text2, x1, y1);
                            }
                        }
                    }
                }
                return [ [ DIFF_DELETE, text1 ], [ DIFF_INSERT, text2 ] ];
            }
            function diff_bisectSplit_(text1, text2, x, y) {
                var text1a = text1.substring(0, x);
                var text2a = text2.substring(0, y);
                var text1b = text1.substring(x);
                var text2b = text2.substring(y);
                var diffs = diff_main(text1a, text2a);
                var diffsb = diff_main(text1b, text2b);
                return diffs.concat(diffsb);
            }
            function diff_commonPrefix(text1, text2) {
                if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) return 0;
                var pointermin = 0;
                var pointermax = Math.min(text1.length, text2.length);
                var pointermid = pointermax;
                var pointerstart = 0;
                while (pointermin < pointermid) {
                    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                        pointermin = pointermid;
                        pointerstart = pointermin;
                    } else pointermax = pointermid;
                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                }
                if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) pointermid--;
                return pointermid;
            }
            function diff_commonOverlap_(text1, text2) {
                var text1_length = text1.length;
                var text2_length = text2.length;
                if (text1_length == 0 || text2_length == 0) return 0;
                if (text1_length > text2_length) text1 = text1.substring(text1_length - text2_length); else if (text1_length < text2_length) text2 = text2.substring(0, text1_length);
                var text_length = Math.min(text1_length, text2_length);
                if (text1 == text2) return text_length;
                var best = 0;
                var length = 1;
                while (true) {
                    var pattern = text1.substring(text_length - length);
                    var found = text2.indexOf(pattern);
                    if (found == -1) return best;
                    length += found;
                    if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
                        best = length;
                        length++;
                    }
                }
            }
            function diff_commonSuffix(text1, text2) {
                if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) return 0;
                var pointermin = 0;
                var pointermax = Math.min(text1.length, text2.length);
                var pointermid = pointermax;
                var pointerend = 0;
                while (pointermin < pointermid) {
                    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                        pointermin = pointermid;
                        pointerend = pointermin;
                    } else pointermax = pointermid;
                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                }
                if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) pointermid--;
                return pointermid;
            }
            function diff_halfMatch_(text1, text2) {
                var longtext = text1.length > text2.length ? text1 : text2;
                var shorttext = text1.length > text2.length ? text2 : text1;
                if (longtext.length < 4 || shorttext.length * 2 < longtext.length) return null;
                function diff_halfMatchI_(longtext, shorttext, i) {
                    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                    var j = -1;
                    var best_common = "";
                    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
                    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
                        var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
                        var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                        if (best_common.length < suffixLength + prefixLength) {
                            best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                            best_longtext_a = longtext.substring(0, i - suffixLength);
                            best_longtext_b = longtext.substring(i + prefixLength);
                            best_shorttext_a = shorttext.substring(0, j - suffixLength);
                            best_shorttext_b = shorttext.substring(j + prefixLength);
                        }
                    }
                    if (best_common.length * 2 >= longtext.length) return [ best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common ]; else return null;
                }
                var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
                var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
                var hm;
                if (!hm1 && !hm2) return null; else if (!hm2) hm = hm1; else if (!hm1) hm = hm2; else hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
                var text1_a, text1_b, text2_a, text2_b;
                if (text1.length > text2.length) {
                    text1_a = hm[0];
                    text1_b = hm[1];
                    text2_a = hm[2];
                    text2_b = hm[3];
                } else {
                    text2_a = hm[0];
                    text2_b = hm[1];
                    text1_a = hm[2];
                    text1_b = hm[3];
                }
                var mid_common = hm[4];
                return [ text1_a, text1_b, text2_a, text2_b, mid_common ];
            }
            function diff_cleanupSemantic(diffs) {
                var changes = false;
                var equalities = [];
                var equalitiesLength = 0;
                var lastequality = null;
                var pointer = 0;
                var length_insertions1 = 0;
                var length_deletions1 = 0;
                var length_insertions2 = 0;
                var length_deletions2 = 0;
                while (pointer < diffs.length) {
                    if (diffs[pointer][0] == DIFF_EQUAL) {
                        equalities[equalitiesLength++] = pointer;
                        length_insertions1 = length_insertions2;
                        length_deletions1 = length_deletions2;
                        length_insertions2 = 0;
                        length_deletions2 = 0;
                        lastequality = diffs[pointer][1];
                    } else {
                        if (diffs[pointer][0] == DIFF_INSERT) length_insertions2 += diffs[pointer][1].length; else length_deletions2 += diffs[pointer][1].length;
                        if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
                            diffs.splice(equalities[equalitiesLength - 1], 0, [ DIFF_DELETE, lastequality ]);
                            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                            equalitiesLength--;
                            equalitiesLength--;
                            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                            length_insertions1 = 0;
                            length_deletions1 = 0;
                            length_insertions2 = 0;
                            length_deletions2 = 0;
                            lastequality = null;
                            changes = true;
                        }
                    }
                    pointer++;
                }
                if (changes) diff_cleanupMerge(diffs);
                diff_cleanupSemanticLossless(diffs);
                pointer = 1;
                while (pointer < diffs.length) {
                    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
                        var deletion = diffs[pointer - 1][1];
                        var insertion = diffs[pointer][1];
                        var overlap_length1 = diff_commonOverlap_(deletion, insertion);
                        var overlap_length2 = diff_commonOverlap_(insertion, deletion);
                        if (overlap_length1 >= overlap_length2) {
                            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                                diffs.splice(pointer, 0, [ DIFF_EQUAL, insertion.substring(0, overlap_length1) ]);
                                diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                                diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                                pointer++;
                            }
                        } else if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [ DIFF_EQUAL, deletion.substring(0, overlap_length2) ]);
                            diffs[pointer - 1][0] = DIFF_INSERT;
                            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                            diffs[pointer + 1][0] = DIFF_DELETE;
                            diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                            pointer++;
                        }
                        pointer++;
                    }
                    pointer++;
                }
            }
            var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
            var whitespaceRegex_ = /\s/;
            var linebreakRegex_ = /[\r\n]/;
            var blanklineEndRegex_ = /\n\r?\n$/;
            var blanklineStartRegex_ = /^\r?\n\r?\n/;
            function diff_cleanupSemanticLossless(diffs) {
                function diff_cleanupSemanticScore_(one, two) {
                    if (!one || !two) return 6;
                    var char1 = one.charAt(one.length - 1);
                    var char2 = two.charAt(0);
                    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
                    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
                    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
                    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
                    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
                    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
                    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
                    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
                    if (blankLine1 || blankLine2) return 5; else if (lineBreak1 || lineBreak2) return 4; else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) return 3; else if (whitespace1 || whitespace2) return 2; else if (nonAlphaNumeric1 || nonAlphaNumeric2) return 1;
                    return 0;
                }
                var pointer = 1;
                while (pointer < diffs.length - 1) {
                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                        var equality1 = diffs[pointer - 1][1];
                        var edit = diffs[pointer][1];
                        var equality2 = diffs[pointer + 1][1];
                        var commonOffset = diff_commonSuffix(equality1, edit);
                        if (commonOffset) {
                            var commonString = edit.substring(edit.length - commonOffset);
                            equality1 = equality1.substring(0, equality1.length - commonOffset);
                            edit = commonString + edit.substring(0, edit.length - commonOffset);
                            equality2 = commonString + equality2;
                        }
                        var bestEquality1 = equality1;
                        var bestEdit = edit;
                        var bestEquality2 = equality2;
                        var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                        while (edit.charAt(0) === equality2.charAt(0)) {
                            equality1 += edit.charAt(0);
                            edit = edit.substring(1) + equality2.charAt(0);
                            equality2 = equality2.substring(1);
                            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                            if (score >= bestScore) {
                                bestScore = score;
                                bestEquality1 = equality1;
                                bestEdit = edit;
                                bestEquality2 = equality2;
                            }
                        }
                        if (diffs[pointer - 1][1] != bestEquality1) {
                            if (bestEquality1) diffs[pointer - 1][1] = bestEquality1; else {
                                diffs.splice(pointer - 1, 1);
                                pointer--;
                            }
                            diffs[pointer][1] = bestEdit;
                            if (bestEquality2) diffs[pointer + 1][1] = bestEquality2; else {
                                diffs.splice(pointer + 1, 1);
                                pointer--;
                            }
                        }
                    }
                    pointer++;
                }
            }
            function diff_cleanupMerge(diffs, fix_unicode) {
                diffs.push([ DIFF_EQUAL, "" ]);
                var pointer = 0;
                var count_delete = 0;
                var count_insert = 0;
                var text_delete = "";
                var text_insert = "";
                var commonlength;
                while (pointer < diffs.length) {
                    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
                        diffs.splice(pointer, 1);
                        continue;
                    }
                    switch (diffs[pointer][0]) {
                      case DIFF_INSERT:
                        count_insert++;
                        text_insert += diffs[pointer][1];
                        pointer++;
                        break;

                      case DIFF_DELETE:
                        count_delete++;
                        text_delete += diffs[pointer][1];
                        pointer++;
                        break;

                      case DIFF_EQUAL:
                        var previous_equality = pointer - count_insert - count_delete - 1;
                        if (fix_unicode) {
                            if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                                var stray = diffs[previous_equality][1].slice(-1);
                                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                                text_delete = stray + text_delete;
                                text_insert = stray + text_insert;
                                if (!diffs[previous_equality][1]) {
                                    diffs.splice(previous_equality, 1);
                                    pointer--;
                                    var k = previous_equality - 1;
                                    if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                                        count_insert++;
                                        text_insert = diffs[k][1] + text_insert;
                                        k--;
                                    }
                                    if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                                        count_delete++;
                                        text_delete = diffs[k][1] + text_delete;
                                        k--;
                                    }
                                    previous_equality = k;
                                }
                            }
                            if (starts_with_pair_end(diffs[pointer][1])) {
                                stray = diffs[pointer][1].charAt(0);
                                diffs[pointer][1] = diffs[pointer][1].slice(1);
                                text_delete += stray;
                                text_insert += stray;
                            }
                        }
                        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
                            diffs.splice(pointer, 1);
                            break;
                        }
                        if (text_delete.length > 0 || text_insert.length > 0) {
                            if (text_delete.length > 0 && text_insert.length > 0) {
                                commonlength = diff_commonPrefix(text_insert, text_delete);
                                if (commonlength !== 0) {
                                    if (previous_equality >= 0) diffs[previous_equality][1] += text_insert.substring(0, commonlength); else {
                                        diffs.splice(0, 0, [ DIFF_EQUAL, text_insert.substring(0, commonlength) ]);
                                        pointer++;
                                    }
                                    text_insert = text_insert.substring(commonlength);
                                    text_delete = text_delete.substring(commonlength);
                                }
                                commonlength = diff_commonSuffix(text_insert, text_delete);
                                if (commonlength !== 0) {
                                    diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                                    text_insert = text_insert.substring(0, text_insert.length - commonlength);
                                    text_delete = text_delete.substring(0, text_delete.length - commonlength);
                                }
                            }
                            var n = count_insert + count_delete;
                            if (text_delete.length === 0 && text_insert.length === 0) {
                                diffs.splice(pointer - n, n);
                                pointer -= n;
                            } else if (text_delete.length === 0) {
                                diffs.splice(pointer - n, n, [ DIFF_INSERT, text_insert ]);
                                pointer = pointer - n + 1;
                            } else if (text_insert.length === 0) {
                                diffs.splice(pointer - n, n, [ DIFF_DELETE, text_delete ]);
                                pointer = pointer - n + 1;
                            } else {
                                diffs.splice(pointer - n, n, [ DIFF_DELETE, text_delete ], [ DIFF_INSERT, text_insert ]);
                                pointer = pointer - n + 2;
                            }
                        }
                        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                            diffs[pointer - 1][1] += diffs[pointer][1];
                            diffs.splice(pointer, 1);
                        } else pointer++;
                        count_insert = 0;
                        count_delete = 0;
                        text_delete = "";
                        text_insert = "";
                        break;
                    }
                }
                if (diffs[diffs.length - 1][1] === "") diffs.pop();
                var changes = false;
                pointer = 1;
                while (pointer < diffs.length - 1) {
                    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
                        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                        diffs.splice(pointer - 1, 1);
                        changes = true;
                    } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                        diffs[pointer - 1][1] += diffs[pointer + 1][1];
                        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                        diffs.splice(pointer + 1, 1);
                        changes = true;
                    }
                    pointer++;
                }
                if (changes) diff_cleanupMerge(diffs, fix_unicode);
            }
            function is_surrogate_pair_start(charCode) {
                return charCode >= 55296 && charCode <= 56319;
            }
            function is_surrogate_pair_end(charCode) {
                return charCode >= 56320 && charCode <= 57343;
            }
            function starts_with_pair_end(str) {
                return is_surrogate_pair_end(str.charCodeAt(0));
            }
            function ends_with_pair_start(str) {
                return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
            }
            function remove_empty_tuples(tuples) {
                var ret = [];
                for (var i = 0; i < tuples.length; i++) if (tuples[i][1].length > 0) ret.push(tuples[i]);
                return ret;
            }
            function make_edit_splice(before, oldMiddle, newMiddle, after) {
                if (ends_with_pair_start(before) || starts_with_pair_end(after)) return null;
                return remove_empty_tuples([ [ DIFF_EQUAL, before ], [ DIFF_DELETE, oldMiddle ], [ DIFF_INSERT, newMiddle ], [ DIFF_EQUAL, after ] ]);
            }
            function find_cursor_edit_diff(oldText, newText, cursor_pos) {
                var oldRange = typeof cursor_pos === "number" ? {
                    index: cursor_pos,
                    length: 0
                } : cursor_pos.oldRange;
                var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
                var oldLength = oldText.length;
                var newLength = newText.length;
                if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
                    var oldCursor = oldRange.index;
                    var oldBefore = oldText.slice(0, oldCursor);
                    var oldAfter = oldText.slice(oldCursor);
                    var maybeNewCursor = newRange ? newRange.index : null;
                    editBefore: {
                        var newCursor = oldCursor + newLength - oldLength;
                        if (maybeNewCursor !== null && maybeNewCursor !== newCursor) break editBefore;
                        if (newCursor < 0 || newCursor > newLength) break editBefore;
                        var newBefore = newText.slice(0, newCursor);
                        var newAfter = newText.slice(newCursor);
                        if (newAfter !== oldAfter) break editBefore;
                        var prefixLength = Math.min(oldCursor, newCursor);
                        var oldPrefix = oldBefore.slice(0, prefixLength);
                        var newPrefix = newBefore.slice(0, prefixLength);
                        if (oldPrefix !== newPrefix) break editBefore;
                        var oldMiddle = oldBefore.slice(prefixLength);
                        var newMiddle = newBefore.slice(prefixLength);
                        return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
                    }
                    editAfter: {
                        if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) break editAfter;
                        var cursor = oldCursor;
                        newBefore = newText.slice(0, cursor);
                        newAfter = newText.slice(cursor);
                        if (newBefore !== oldBefore) break editAfter;
                        var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
                        var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
                        var newSuffix = newAfter.slice(newAfter.length - suffixLength);
                        if (oldSuffix !== newSuffix) break editAfter;
                        oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
                        newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
                        return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
                    }
                }
                if (oldRange.length > 0 && newRange && newRange.length === 0) replaceRange: {
                    oldPrefix = oldText.slice(0, oldRange.index);
                    oldSuffix = oldText.slice(oldRange.index + oldRange.length);
                    prefixLength = oldPrefix.length;
                    suffixLength = oldSuffix.length;
                    if (newLength < prefixLength + suffixLength) break replaceRange;
                    newPrefix = newText.slice(0, prefixLength);
                    newSuffix = newText.slice(newLength - suffixLength);
                    if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) break replaceRange;
                    oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
                    newMiddle = newText.slice(prefixLength, newLength - suffixLength);
                    return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
                }
                return null;
            }
            function diff(text1, text2, cursor_pos, cleanup) {
                return diff_main(text1, text2, cursor_pos, cleanup, true);
            }
            diff.INSERT = DIFF_INSERT;
            diff.DELETE = DIFF_DELETE;
            diff.EQUAL = DIFF_EQUAL;
            module.exports = diff;
        },
        958: function(module) {
            /*!
 * dist/inputmask.min
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2024 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.9
 */
            !function(e, t) {
                if (true) module.exports = t(); else ;
            }("undefined" != typeof self && self, (function() {
                return function() {
                    "use strict";
                    var e = {
                        3976: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            t.default = {
                                _maxTestPos: 500,
                                placeholder: "_",
                                optionalmarker: [ "[", "]" ],
                                quantifiermarker: [ "{", "}" ],
                                groupmarker: [ "(", ")" ],
                                alternatormarker: "|",
                                escapeChar: "\\",
                                mask: null,
                                regex: null,
                                oncomplete: function() {},
                                onincomplete: function() {},
                                oncleared: function() {},
                                repeat: 0,
                                greedy: !1,
                                autoUnmask: !1,
                                removeMaskOnSubmit: !1,
                                clearMaskOnLostFocus: !0,
                                insertMode: !0,
                                insertModeVisual: !0,
                                clearIncomplete: !1,
                                alias: null,
                                onKeyDown: function() {},
                                onBeforeMask: null,
                                onBeforePaste: function(e, t) {
                                    return "function" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;
                                },
                                onBeforeWrite: null,
                                onUnMask: null,
                                showMaskOnFocus: !0,
                                showMaskOnHover: !0,
                                onKeyValidation: function() {},
                                skipOptionalPartCharacter: " ",
                                numericInput: !1,
                                rightAlign: !1,
                                undoOnEscape: !0,
                                radixPoint: "",
                                _radixDance: !1,
                                groupSeparator: "",
                                keepStatic: null,
                                positionCaretOnTab: !0,
                                tabThrough: !1,
                                supportsInputType: [ "text", "tel", "url", "password", "search" ],
                                isComplete: null,
                                preValidation: null,
                                postValidation: null,
                                staticDefinitionSymbol: void 0,
                                jitMasking: !1,
                                nullable: !0,
                                inputEventOnly: !1,
                                noValuePatching: !1,
                                positionCaretOnClick: "lvp",
                                casing: null,
                                inputmode: "text",
                                importDataAttributes: !0,
                                shiftPositions: !0,
                                usePrototypeDefinitions: !0,
                                validationEventTimeOut: 3e3,
                                substitutes: {}
                            };
                        },
                        7392: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            t.default = {
                                9: {
                                    validator: "[0-9０-９]",
                                    definitionSymbol: "*"
                                },
                                a: {
                                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                                    definitionSymbol: "*"
                                },
                                "*": {
                                    validator: "[0-9０-９A-Za-zА-яЁёÀ-ÿµ]"
                                }
                            };
                        },
                        253: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e, t, n) {
                                if (void 0 === n) return e.__data ? e.__data[t] : null;
                                e.__data = e.__data || {}, e.__data[t] = n;
                            };
                        },
                        3776: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.Event = void 0, t.off = function(e, t) {
                                var n, i;
                                u(this[0]) && e && (n = this[0].eventRegistry, i = this[0], e.split(" ").forEach((function(e) {
                                    var a = o(e.split("."), 2);
                                    (function(e, i) {
                                        var a, r, o = [];
                                        if (e.length > 0) if (void 0 === t) for (a = 0, r = n[e][i].length; a < r; a++) o.push({
                                            ev: e,
                                            namespace: i && i.length > 0 ? i : "global",
                                            handler: n[e][i][a]
                                        }); else o.push({
                                            ev: e,
                                            namespace: i && i.length > 0 ? i : "global",
                                            handler: t
                                        }); else if (i.length > 0) for (var l in n) for (var s in n[l]) if (s === i) if (void 0 === t) for (a = 0, 
                                        r = n[l][s].length; a < r; a++) o.push({
                                            ev: l,
                                            namespace: s,
                                            handler: n[l][s][a]
                                        }); else o.push({
                                            ev: l,
                                            namespace: s,
                                            handler: t
                                        });
                                        return o;
                                    })(a[0], a[1]).forEach((function(e) {
                                        var t = e.ev, a = e.handler;
                                        !function(e, t, a) {
                                            if (e in n == 1) if (i.removeEventListener ? i.removeEventListener(e, a, !1) : i.detachEvent && i.detachEvent("on".concat(e), a), 
                                            "global" === t) for (var r in n[e]) n[e][r].splice(n[e][r].indexOf(a), 1); else n[e][t].splice(n[e][t].indexOf(a), 1);
                                        }(t, e.namespace, a);
                                    }));
                                })));
                                return this;
                            }, t.on = function(e, t) {
                                if (u(this[0])) {
                                    var n = this[0].eventRegistry, i = this[0];
                                    e.split(" ").forEach((function(e) {
                                        var a = o(e.split("."), 2), r = a[0], l = a[1];
                                        !function(e, a) {
                                            i.addEventListener ? i.addEventListener(e, t, !1) : i.attachEvent && i.attachEvent("on".concat(e), t), 
                                            n[e] = n[e] || {}, n[e][a] = n[e][a] || [], n[e][a].push(t);
                                        }(r, void 0 === l ? "global" : l);
                                    }));
                                }
                                return this;
                            }, t.trigger = function(e) {
                                var t = arguments;
                                if (u(this[0])) for (var n = this[0].eventRegistry, i = this[0], o = "string" == typeof e ? e.split(" ") : [ e.type ], l = 0; l < o.length; l++) {
                                    var s = o[l].split("."), f = s[0], p = s[1] || "global";
                                    if (void 0 !== c && "global" === p) {
                                        var d, h = {
                                            bubbles: !0,
                                            cancelable: !0,
                                            composed: !0,
                                            detail: arguments[1]
                                        };
                                        if (c.createEvent) {
                                            try {
                                                if ("input" === f) h.inputType = "insertText", d = new InputEvent(f, h); else d = new CustomEvent(f, h);
                                            } catch (e) {
                                                (d = c.createEvent("CustomEvent")).initCustomEvent(f, h.bubbles, h.cancelable, h.detail);
                                            }
                                            e.type && (0, a.default)(d, e), i.dispatchEvent(d);
                                        } else (d = c.createEventObject()).eventType = f, d.detail = arguments[1], e.type && (0, 
                                        a.default)(d, e), i.fireEvent("on" + d.eventType, d);
                                    } else if (void 0 !== n[f]) {
                                        arguments[0] = arguments[0].type ? arguments[0] : r.default.Event(arguments[0]), 
                                        arguments[0].detail = arguments.slice(1);
                                        var v = n[f];
                                        ("global" === p ? Object.values(v).flat() : v[p]).forEach((function(e) {
                                            return e.apply(i, t);
                                        }));
                                    }
                                }
                                return this;
                            };
                            var i = s(n(9380)), a = s(n(600)), r = s(n(4963));
                            function o(e, t) {
                                return function(e) {
                                    if (Array.isArray(e)) return e;
                                }(e) || function(e, t) {
                                    var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (null != n) {
                                        var i, a, r, o, l = [], s = !0, c = !1;
                                        try {
                                            if (r = (n = n.call(e)).next, 0 === t) {
                                                if (Object(n) !== n) return;
                                                s = !1;
                                            } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;
                                        } catch (e) {
                                            c = !0, a = e;
                                        } finally {
                                            try {
                                                if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;
                                            } finally {
                                                if (c) throw a;
                                            }
                                        }
                                        return l;
                                    }
                                }(e, t) || function(e, t) {
                                    if (!e) return;
                                    if ("string" == typeof e) return l(e, t);
                                    var n = Object.prototype.toString.call(e).slice(8, -1);
                                    "Object" === n && e.constructor && (n = e.constructor.name);
                                    if ("Map" === n || "Set" === n) return Array.from(e);
                                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return l(e, t);
                                }(e, t) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }();
                            }
                            function l(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                                return i;
                            }
                            function s(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var c = i.default.document;
                            function u(e) {
                                return e instanceof Element;
                            }
                            var f = t.Event = void 0;
                            "function" == typeof i.default.CustomEvent ? t.Event = f = i.default.CustomEvent : i.default.Event && c && c.createEvent ? (t.Event = f = function(e, t) {
                                t = t || {
                                    bubbles: !1,
                                    cancelable: !1,
                                    composed: !0,
                                    detail: void 0
                                };
                                var n = c.createEvent("CustomEvent");
                                return n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), n;
                            }, f.prototype = i.default.Event.prototype) : "undefined" != typeof Event && (t.Event = f = Event);
                        },
                        600: function(e, t) {
                            function n(e) {
                                return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, n(e);
                            }
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function e() {
                                var t, i, a, r, o, l, s = arguments[0] || {}, c = 1, u = arguments.length, f = !1;
                                "boolean" == typeof s && (f = s, s = arguments[c] || {}, c++);
                                "object" !== n(s) && "function" != typeof s && (s = {});
                                for (;c < u; c++) if (null != (t = arguments[c])) for (i in t) a = s[i], s !== (r = t[i]) && (f && r && ("[object Object]" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1, 
                                l = a && Array.isArray(a) ? a : []) : l = a && "[object Object]" === Object.prototype.toString.call(a) ? a : {}, 
                                s[i] = e(f, l, r)) : void 0 !== r && (s[i] = r));
                                return s;
                            };
                        },
                        4963: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var i = l(n(9380)), a = l(n(253)), r = n(3776), o = l(n(600));
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = i.default.document;
                            function c(e) {
                                return e instanceof c ? e : this instanceof c ? void (null != e && e !== i.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : s.querySelector(e), 
                                void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new c(e);
                            }
                            c.prototype = {
                                on: r.on,
                                off: r.off,
                                trigger: r.trigger
                            }, c.extend = o.default, c.data = a.default, c.Event = r.Event;
                            t.default = c;
                        },
                        9845: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.mobile = t.iphone = t.ie = void 0;
                            var i, a = (i = n(9380)) && i.__esModule ? i : {
                                default: i
                            };
                            var r = a.default.navigator && a.default.navigator.userAgent || "";
                            t.ie = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0, t.mobile = a.default.navigator && a.default.navigator.userAgentData && a.default.navigator.userAgentData.mobile || a.default.navigator && a.default.navigator.maxTouchPoints || "ontouchstart" in a.default, 
                            t.iphone = /iphone/i.test(r);
                        },
                        7184: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e) {
                                return e.replace(n, "\\$1");
                            };
                            var n = new RegExp("(\\" + [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ].join("|\\") + ")", "gim");
                        },
                        6030: function(e, t, n) {
                            function i(e) {
                                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, i(e);
                            }
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.EventHandlers = void 0;
                            var a, r = n(9845), o = (a = n(9380)) && a.__esModule ? a : {
                                default: a
                            }, l = n(7760), s = n(2839), c = n(8711), u = n(7215), f = n(4713);
                            function p() {
                                /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ p = function() {
                                    return t;
                                };
                                var e, t = {}, n = Object.prototype, a = n.hasOwnProperty, r = Object.defineProperty || function(e, t, n) {
                                    e[t] = n.value;
                                }, o = "function" == typeof Symbol ? Symbol : {}, l = o.iterator || "@@iterator", s = o.asyncIterator || "@@asyncIterator", c = o.toStringTag || "@@toStringTag";
                                function u(e, t, n) {
                                    return Object.defineProperty(e, t, {
                                        value: n,
                                        enumerable: !0,
                                        configurable: !0,
                                        writable: !0
                                    }), e[t];
                                }
                                try {
                                    u({}, "");
                                } catch (e) {
                                    u = function(e, t, n) {
                                        return e[t] = n;
                                    };
                                }
                                function f(e, t, n, i) {
                                    var a = t && t.prototype instanceof k ? t : k, o = Object.create(a.prototype), l = new D(i || []);
                                    return r(o, "_invoke", {
                                        value: E(e, n, l)
                                    }), o;
                                }
                                function d(e, t, n) {
                                    try {
                                        return {
                                            type: "normal",
                                            arg: e.call(t, n)
                                        };
                                    } catch (e) {
                                        return {
                                            type: "throw",
                                            arg: e
                                        };
                                    }
                                }
                                t.wrap = f;
                                var h = "suspendedStart", v = "suspendedYield", m = "executing", g = "completed", y = {};
                                function k() {}
                                function b() {}
                                function x() {}
                                var w = {};
                                u(w, l, (function() {
                                    return this;
                                }));
                                var P = Object.getPrototypeOf, S = P && P(P(L([])));
                                S && S !== n && a.call(S, l) && (w = S);
                                var O = x.prototype = k.prototype = Object.create(w);
                                function _(e) {
                                    [ "next", "throw", "return" ].forEach((function(t) {
                                        u(e, t, (function(e) {
                                            return this._invoke(t, e);
                                        }));
                                    }));
                                }
                                function M(e, t) {
                                    function n(r, o, l, s) {
                                        var c = d(e[r], e, o);
                                        if ("throw" !== c.type) {
                                            var u = c.arg, f = u.value;
                                            return f && "object" == i(f) && a.call(f, "__await") ? t.resolve(f.__await).then((function(e) {
                                                n("next", e, l, s);
                                            }), (function(e) {
                                                n("throw", e, l, s);
                                            })) : t.resolve(f).then((function(e) {
                                                u.value = e, l(u);
                                            }), (function(e) {
                                                return n("throw", e, l, s);
                                            }));
                                        }
                                        s(c.arg);
                                    }
                                    var o;
                                    r(this, "_invoke", {
                                        value: function(e, i) {
                                            function a() {
                                                return new t((function(t, a) {
                                                    n(e, i, t, a);
                                                }));
                                            }
                                            return o = o ? o.then(a, a) : a();
                                        }
                                    });
                                }
                                function E(t, n, i) {
                                    var a = h;
                                    return function(r, o) {
                                        if (a === m) throw new Error("Generator is already running");
                                        if (a === g) {
                                            if ("throw" === r) throw o;
                                            return {
                                                value: e,
                                                done: !0
                                            };
                                        }
                                        for (i.method = r, i.arg = o; ;) {
                                            var l = i.delegate;
                                            if (l) {
                                                var s = j(l, i);
                                                if (s) {
                                                    if (s === y) continue;
                                                    return s;
                                                }
                                            }
                                            if ("next" === i.method) i.sent = i._sent = i.arg; else if ("throw" === i.method) {
                                                if (a === h) throw a = g, i.arg;
                                                i.dispatchException(i.arg);
                                            } else "return" === i.method && i.abrupt("return", i.arg);
                                            a = m;
                                            var c = d(t, n, i);
                                            if ("normal" === c.type) {
                                                if (a = i.done ? g : v, c.arg === y) continue;
                                                return {
                                                    value: c.arg,
                                                    done: i.done
                                                };
                                            }
                                            "throw" === c.type && (a = g, i.method = "throw", i.arg = c.arg);
                                        }
                                    };
                                }
                                function j(t, n) {
                                    var i = n.method, a = t.iterator[i];
                                    if (a === e) return n.delegate = null, "throw" === i && t.iterator.return && (n.method = "return", 
                                    n.arg = e, j(t, n), "throw" === n.method) || "return" !== i && (n.method = "throw", 
                                    n.arg = new TypeError("The iterator does not provide a '" + i + "' method")), y;
                                    var r = d(a, t.iterator, n.arg);
                                    if ("throw" === r.type) return n.method = "throw", n.arg = r.arg, n.delegate = null, 
                                    y;
                                    var o = r.arg;
                                    return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", 
                                    n.arg = e), n.delegate = null, y) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), 
                                    n.delegate = null, y);
                                }
                                function T(e) {
                                    var t = {
                                        tryLoc: e[0]
                                    };
                                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), 
                                    this.tryEntries.push(t);
                                }
                                function A(e) {
                                    var t = e.completion || {};
                                    t.type = "normal", delete t.arg, e.completion = t;
                                }
                                function D(e) {
                                    this.tryEntries = [ {
                                        tryLoc: "root"
                                    } ], e.forEach(T, this), this.reset(!0);
                                }
                                function L(t) {
                                    if (t || "" === t) {
                                        var n = t[l];
                                        if (n) return n.call(t);
                                        if ("function" == typeof t.next) return t;
                                        if (!isNaN(t.length)) {
                                            var r = -1, o = function n() {
                                                for (;++r < t.length; ) if (a.call(t, r)) return n.value = t[r], n.done = !1, n;
                                                return n.value = e, n.done = !0, n;
                                            };
                                            return o.next = o;
                                        }
                                    }
                                    throw new TypeError(i(t) + " is not iterable");
                                }
                                return b.prototype = x, r(O, "constructor", {
                                    value: x,
                                    configurable: !0
                                }), r(x, "constructor", {
                                    value: b,
                                    configurable: !0
                                }), b.displayName = u(x, c, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                                    var t = "function" == typeof e && e.constructor;
                                    return !!t && (t === b || "GeneratorFunction" === (t.displayName || t.name));
                                }, t.mark = function(e) {
                                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, x) : (e.__proto__ = x, u(e, c, "GeneratorFunction")), 
                                    e.prototype = Object.create(O), e;
                                }, t.awrap = function(e) {
                                    return {
                                        __await: e
                                    };
                                }, _(M.prototype), u(M.prototype, s, (function() {
                                    return this;
                                })), t.AsyncIterator = M, t.async = function(e, n, i, a, r) {
                                    void 0 === r && (r = Promise);
                                    var o = new M(f(e, n, i, a), r);
                                    return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                                        return e.done ? e.value : o.next();
                                    }));
                                }, _(O), u(O, c, "Generator"), u(O, l, (function() {
                                    return this;
                                })), u(O, "toString", (function() {
                                    return "[object Generator]";
                                })), t.keys = function(e) {
                                    var t = Object(e), n = [];
                                    for (var i in t) n.push(i);
                                    return n.reverse(), function e() {
                                        for (;n.length; ) {
                                            var i = n.pop();
                                            if (i in t) return e.value = i, e.done = !1, e;
                                        }
                                        return e.done = !0, e;
                                    };
                                }, t.values = L, D.prototype = {
                                    constructor: D,
                                    reset: function(t) {
                                        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, 
                                        this.method = "next", this.arg = e, this.tryEntries.forEach(A), !t) for (var n in this) "t" === n.charAt(0) && a.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e);
                                    },
                                    stop: function() {
                                        this.done = !0;
                                        var e = this.tryEntries[0].completion;
                                        if ("throw" === e.type) throw e.arg;
                                        return this.rval;
                                    },
                                    dispatchException: function(t) {
                                        if (this.done) throw t;
                                        var n = this;
                                        function i(i, a) {
                                            return l.type = "throw", l.arg = t, n.next = i, a && (n.method = "next", n.arg = e), 
                                            !!a;
                                        }
                                        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                            var o = this.tryEntries[r], l = o.completion;
                                            if ("root" === o.tryLoc) return i("end");
                                            if (o.tryLoc <= this.prev) {
                                                var s = a.call(o, "catchLoc"), c = a.call(o, "finallyLoc");
                                                if (s && c) {
                                                    if (this.prev < o.catchLoc) return i(o.catchLoc, !0);
                                                    if (this.prev < o.finallyLoc) return i(o.finallyLoc);
                                                } else if (s) {
                                                    if (this.prev < o.catchLoc) return i(o.catchLoc, !0);
                                                } else {
                                                    if (!c) throw new Error("try statement without catch or finally");
                                                    if (this.prev < o.finallyLoc) return i(o.finallyLoc);
                                                }
                                            }
                                        }
                                    },
                                    abrupt: function(e, t) {
                                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                            var i = this.tryEntries[n];
                                            if (i.tryLoc <= this.prev && a.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                                                var r = i;
                                                break;
                                            }
                                        }
                                        r && ("break" === e || "continue" === e) && r.tryLoc <= t && t <= r.finallyLoc && (r = null);
                                        var o = r ? r.completion : {};
                                        return o.type = e, o.arg = t, r ? (this.method = "next", this.next = r.finallyLoc, 
                                        y) : this.complete(o);
                                    },
                                    complete: function(e, t) {
                                        if ("throw" === e.type) throw e.arg;
                                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, 
                                        this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), 
                                        y;
                                    },
                                    finish: function(e) {
                                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                            var n = this.tryEntries[t];
                                            if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), A(n), y;
                                        }
                                    },
                                    catch: function(e) {
                                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                            var n = this.tryEntries[t];
                                            if (n.tryLoc === e) {
                                                var i = n.completion;
                                                if ("throw" === i.type) {
                                                    var a = i.arg;
                                                    A(n);
                                                }
                                                return a;
                                            }
                                        }
                                        throw new Error("illegal catch attempt");
                                    },
                                    delegateYield: function(t, n, i) {
                                        return this.delegate = {
                                            iterator: L(t),
                                            resultName: n,
                                            nextLoc: i
                                        }, "next" === this.method && (this.arg = e), y;
                                    }
                                }, t;
                            }
                            function d(e, t) {
                                var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                if (!n) {
                                    if (Array.isArray(e) || (n = function(e, t) {
                                        if (!e) return;
                                        if ("string" == typeof e) return h(e, t);
                                        var n = Object.prototype.toString.call(e).slice(8, -1);
                                        "Object" === n && e.constructor && (n = e.constructor.name);
                                        if ("Map" === n || "Set" === n) return Array.from(e);
                                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return h(e, t);
                                    }(e)) || t && e && "number" == typeof e.length) {
                                        n && (e = n);
                                        var i = 0, a = function() {};
                                        return {
                                            s: a,
                                            n: function() {
                                                return i >= e.length ? {
                                                    done: !0
                                                } : {
                                                    done: !1,
                                                    value: e[i++]
                                                };
                                            },
                                            e: function(e) {
                                                throw e;
                                            },
                                            f: a
                                        };
                                    }
                                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }
                                var r, o = !0, l = !1;
                                return {
                                    s: function() {
                                        n = n.call(e);
                                    },
                                    n: function() {
                                        var e = n.next();
                                        return o = e.done, e;
                                    },
                                    e: function(e) {
                                        l = !0, r = e;
                                    },
                                    f: function() {
                                        try {
                                            o || null == n.return || n.return();
                                        } finally {
                                            if (l) throw r;
                                        }
                                    }
                                };
                            }
                            function h(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                                return i;
                            }
                            function v(e, t, n, i, a, r, o) {
                                try {
                                    var l = e[r](o), s = l.value;
                                } catch (e) {
                                    return void n(e);
                                }
                                l.done ? t(s) : Promise.resolve(s).then(i, a);
                            }
                            var m, g, y = t.EventHandlers = {
                                keyEvent: function(e, t, n, i, a) {
                                    var o = this.inputmask, p = o.opts, d = o.dependencyLib, h = o.maskset, v = this, m = d(v), g = e.key, k = c.caret.call(o, v), b = p.onKeyDown.call(this, e, c.getBuffer.call(o), k, p);
                                    if (void 0 !== b) return b;
                                    if (g === s.keys.Backspace || g === s.keys.Delete || r.iphone && g === s.keys.BACKSPACE_SAFARI || e.ctrlKey && g === s.keys.x && !("oncut" in v)) e.preventDefault(), 
                                    u.handleRemove.call(o, v, g, k), (0, l.writeBuffer)(v, c.getBuffer.call(o, !0), h.p, e, v.inputmask._valueGet() !== c.getBuffer.call(o).join("")); else if (g === s.keys.End || g === s.keys.PageDown) {
                                        e.preventDefault();
                                        var x = c.seekNext.call(o, c.getLastValidPosition.call(o));
                                        c.caret.call(o, v, e.shiftKey ? k.begin : x, x, !0);
                                    } else g === s.keys.Home && !e.shiftKey || g === s.keys.PageUp ? (e.preventDefault(), 
                                    c.caret.call(o, v, 0, e.shiftKey ? k.begin : 0, !0)) : p.undoOnEscape && g === s.keys.Escape && !0 !== e.altKey ? ((0, 
                                    l.checkVal)(v, !0, !1, o.undoValue.split("")), m.trigger("click")) : g !== s.keys.Insert || e.shiftKey || e.ctrlKey || void 0 !== o.userOptions.insertMode ? !0 === p.tabThrough && g === s.keys.Tab ? !0 === e.shiftKey ? (k.end = c.seekPrevious.call(o, k.end, !0), 
                                    !0 === f.getTest.call(o, k.end - 1).match.static && k.end--, k.begin = c.seekPrevious.call(o, k.end, !0), 
                                    k.begin >= 0 && k.end > 0 && (e.preventDefault(), c.caret.call(o, v, k.begin, k.end))) : (k.begin = c.seekNext.call(o, k.begin, !0), 
                                    k.end = c.seekNext.call(o, k.begin, !0), k.end < h.maskLength && k.end--, k.begin <= h.maskLength && (e.preventDefault(), 
                                    c.caret.call(o, v, k.begin, k.end))) : e.shiftKey || (p.insertModeVisual && !1 === p.insertMode ? g === s.keys.ArrowRight ? setTimeout((function() {
                                        var e = c.caret.call(o, v);
                                        c.caret.call(o, v, e.begin);
                                    }), 0) : g === s.keys.ArrowLeft && setTimeout((function() {
                                        var e = c.translatePosition.call(o, v.inputmask.caretPos.begin);
                                        c.translatePosition.call(o, v.inputmask.caretPos.end);
                                        o.isRTL ? c.caret.call(o, v, e + (e === h.maskLength ? 0 : 1)) : c.caret.call(o, v, e - (0 === e ? 0 : 1));
                                    }), 0) : void 0 === o.keyEventHook || o.keyEventHook(e)) : u.isSelection.call(o, k) ? p.insertMode = !p.insertMode : (p.insertMode = !p.insertMode, 
                                    c.caret.call(o, v, k.begin, k.begin));
                                    return o.isComposing = g == s.keys.Process || g == s.keys.Unidentified, o.ignorable = g.length > 1 && !("textarea" === v.tagName.toLowerCase() && g == s.keys.Enter), 
                                    y.keypressEvent.call(this, e, t, n, i, a);
                                },
                                keypressEvent: function(e, t, n, i, a) {
                                    var r = this.inputmask || this, o = r.opts, f = r.dependencyLib, p = r.maskset, d = r.el, h = f(d), v = e.key;
                                    if (!0 === t || e.ctrlKey && e.altKey && !r.ignorable || !(e.ctrlKey || e.metaKey || r.ignorable)) {
                                        if (v) {
                                            var m, g = t ? {
                                                begin: a,
                                                end: a
                                            } : c.caret.call(r, d);
                                            t || (v = o.substitutes[v] || v), p.writeOutBuffer = !0;
                                            var y = u.isValid.call(r, g, v, i, void 0, void 0, void 0, t);
                                            if (!1 !== y && (c.resetMaskSet.call(r, !0), m = void 0 !== y.caret ? y.caret : c.seekNext.call(r, y.pos.begin ? y.pos.begin : y.pos), 
                                            p.p = m), m = o.numericInput && void 0 === y.caret ? c.seekPrevious.call(r, m) : m, 
                                            !1 !== n && (setTimeout((function() {
                                                o.onKeyValidation.call(d, v, y);
                                            }), 0), p.writeOutBuffer && !1 !== y)) {
                                                var k = c.getBuffer.call(r);
                                                (0, l.writeBuffer)(d, k, m, e, !0 !== t);
                                            }
                                            if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;
                                        }
                                    } else v === s.keys.Enter && r.undoValue !== r._valueGet(!0) && (r.undoValue = r._valueGet(!0), 
                                    setTimeout((function() {
                                        h.trigger("change");
                                    }), 0));
                                },
                                pasteEvent: (m = p().mark((function e(t) {
                                    var n, i, a, r, s, u;
                                    return p().wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                          case 0:
                                            n = function(e, n, i, a, o) {
                                                var s = c.caret.call(e, n, void 0, void 0, !0), u = i.substr(0, s.begin), f = i.substr(s.end, i.length);
                                                if (u == (e.isRTL ? c.getBufferTemplate.call(e).slice().reverse() : c.getBufferTemplate.call(e)).slice(0, s.begin).join("") && (u = ""), 
                                                f == (e.isRTL ? c.getBufferTemplate.call(e).slice().reverse() : c.getBufferTemplate.call(e)).slice(s.end).join("") && (f = ""), 
                                                a = u + a + f, e.isRTL && !0 !== r.numericInput) {
                                                    a = a.split("");
                                                    var p, h = d(c.getBufferTemplate.call(e));
                                                    try {
                                                        for (h.s(); !(p = h.n()).done; ) {
                                                            var v = p.value;
                                                            a[0] === v && a.shift();
                                                        }
                                                    } catch (e) {
                                                        h.e(e);
                                                    } finally {
                                                        h.f();
                                                    }
                                                    a = a.reverse().join("");
                                                }
                                                var m = a;
                                                if ("function" == typeof o) {
                                                    if (!1 === (m = o.call(e, m, r))) return !1;
                                                    m || (m = i);
                                                }
                                                (0, l.checkVal)(n, !0, !1, m.toString().split(""), t);
                                            }, i = this, a = this.inputmask, r = a.opts, s = a._valueGet(!0), a.skipInputEvent = !0, 
                                            t.clipboardData && t.clipboardData.getData ? u = t.clipboardData.getData("text/plain") : o.default.clipboardData && o.default.clipboardData.getData && (u = o.default.clipboardData.getData("Text")), 
                                            n(a, i, s, u, r.onBeforePaste), t.preventDefault();

                                          case 7:
                                          case "end":
                                            return e.stop();
                                        }
                                    }), e, this);
                                })), g = function() {
                                    var e = this, t = arguments;
                                    return new Promise((function(n, i) {
                                        var a = m.apply(e, t);
                                        function r(e) {
                                            v(a, n, i, r, o, "next", e);
                                        }
                                        function o(e) {
                                            v(a, n, i, r, o, "throw", e);
                                        }
                                        r(void 0);
                                    }));
                                }, function(e) {
                                    return g.apply(this, arguments);
                                }),
                                inputFallBackEvent: function(e) {
                                    var t = this.inputmask, n = t.opts, i = t.dependencyLib;
                                    var a, o = this, u = o.inputmask._valueGet(!0), p = (t.isRTL ? c.getBuffer.call(t).slice().reverse() : c.getBuffer.call(t)).join(""), d = c.caret.call(t, o, void 0, void 0, !0);
                                    if (p !== u) {
                                        if (a = function(e, i, a) {
                                            for (var r, o, l, s = e.substr(0, a.begin).split(""), u = e.substr(a.begin).split(""), p = i.substr(0, a.begin).split(""), d = i.substr(a.begin).split(""), h = s.length >= p.length ? s.length : p.length, v = u.length >= d.length ? u.length : d.length, m = "", g = [], y = "~"; s.length < h; ) s.push(y);
                                            for (;p.length < h; ) p.push(y);
                                            for (;u.length < v; ) u.unshift(y);
                                            for (;d.length < v; ) d.unshift(y);
                                            var k = s.concat(u), b = p.concat(d);
                                            for (o = 0, r = k.length; o < r; o++) switch (l = f.getPlaceholder.call(t, c.translatePosition.call(t, o)), 
                                            m) {
                                              case "insertText":
                                                b[o - 1] === k[o] && a.begin == k.length - 1 && g.push(k[o]), o = r;
                                                break;

                                              case "insertReplacementText":
                                              case "deleteContentBackward":
                                                k[o] === y ? a.end++ : o = r;
                                                break;

                                              default:
                                                k[o] !== b[o] && (k[o + 1] !== y && k[o + 1] !== l && void 0 !== k[o + 1] || (b[o] !== l || b[o + 1] !== y) && b[o] !== y ? b[o + 1] === y && b[o] === k[o + 1] ? (m = "insertText", 
                                                g.push(k[o]), a.begin--, a.end--) : k[o] !== l && k[o] !== y && (k[o + 1] === y || b[o] !== k[o] && b[o + 1] === k[o + 1]) ? (m = "insertReplacementText", 
                                                g.push(k[o]), a.begin--) : k[o] === y ? (m = "deleteContentBackward", (c.isMask.call(t, c.translatePosition.call(t, o), !0) || b[o] === n.radixPoint) && a.end++) : o = r : (m = "insertText", 
                                                g.push(k[o]), a.begin--, a.end--));
                                            }
                                            return {
                                                action: m,
                                                data: g,
                                                caret: a
                                            };
                                        }(u, p, d), (o.inputmask.shadowRoot || o.ownerDocument).activeElement !== o && o.focus(), 
                                        (0, l.writeBuffer)(o, c.getBuffer.call(t)), c.caret.call(t, o, d.begin, d.end, !0), 
                                        !r.mobile && t.skipNextInsert && "insertText" === e.inputType && "insertText" === a.action && t.isComposing) return !1;
                                        switch ("insertCompositionText" === e.inputType && "insertText" === a.action && t.isComposing ? t.skipNextInsert = !0 : t.skipNextInsert = !1, 
                                        a.action) {
                                          case "insertText":
                                          case "insertReplacementText":
                                            a.data.forEach((function(e, n) {
                                                var a = new i.Event("keypress");
                                                a.key = e, t.ignorable = !1, y.keypressEvent.call(o, a);
                                            })), setTimeout((function() {
                                                t.$el.trigger("keyup");
                                            }), 0);
                                            break;

                                          case "deleteContentBackward":
                                            var h = new i.Event("keydown");
                                            h.key = s.keys.Backspace, y.keyEvent.call(o, h);
                                            break;

                                          default:
                                            (0, l.applyInputValue)(o, u), c.caret.call(t, o, d.begin, d.end, !0);
                                        }
                                        e.preventDefault();
                                    }
                                },
                                setValueEvent: function(e) {
                                    var t = this.inputmask, n = t.dependencyLib, i = this, a = e && e.detail ? e.detail[0] : arguments[1];
                                    void 0 === a && (a = i.inputmask._valueGet(!0)), (0, l.applyInputValue)(i, a, new n.Event("input")), 
                                    (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && c.caret.call(t, i, e.detail ? e.detail[1] : arguments[2]);
                                },
                                focusEvent: function(e) {
                                    var t = this.inputmask, n = t.opts, i = t && t._valueGet();
                                    n.showMaskOnFocus && i !== c.getBuffer.call(t).join("") && (0, l.writeBuffer)(this, c.getBuffer.call(t), c.seekNext.call(t, c.getLastValidPosition.call(t))), 
                                    !0 !== n.positionCaretOnTab || !1 !== t.mouseEnter || u.isComplete.call(t, c.getBuffer.call(t)) && -1 !== c.getLastValidPosition.call(t) || y.clickEvent.apply(this, [ e, !0 ]), 
                                    t.undoValue = t && t._valueGet(!0);
                                },
                                invalidEvent: function(e) {
                                    this.inputmask.validationEvent = !0;
                                },
                                mouseleaveEvent: function() {
                                    var e = this.inputmask, t = e.opts, n = this;
                                    e.mouseEnter = !1, t.clearMaskOnLostFocus && (n.inputmask.shadowRoot || n.ownerDocument).activeElement !== n && (0, 
                                    l.HandleNativePlaceholder)(n, e.originalPlaceholder);
                                },
                                clickEvent: function(e, t) {
                                    var n = this.inputmask;
                                    n.clicked++;
                                    var i = this;
                                    if ((i.inputmask.shadowRoot || i.ownerDocument).activeElement === i) {
                                        var a = c.determineNewCaretPosition.call(n, c.caret.call(n, i), t);
                                        void 0 !== a && c.caret.call(n, i, a);
                                    }
                                },
                                cutEvent: function(e) {
                                    var t = this.inputmask, n = t.maskset, i = this, a = c.caret.call(t, i), r = t.isRTL ? c.getBuffer.call(t).slice(a.end, a.begin) : c.getBuffer.call(t).slice(a.begin, a.end), f = t.isRTL ? r.reverse().join("") : r.join("");
                                    o.default.navigator && o.default.navigator.clipboard ? o.default.navigator.clipboard.writeText(f) : o.default.clipboardData && o.default.clipboardData.getData && o.default.clipboardData.setData("Text", f), 
                                    u.handleRemove.call(t, i, s.keys.Delete, a), (0, l.writeBuffer)(i, c.getBuffer.call(t), n.p, e, t.undoValue !== t._valueGet(!0));
                                },
                                blurEvent: function(e) {
                                    var t = this.inputmask, n = t.opts, i = t.dependencyLib;
                                    t.clicked = 0;
                                    var a = i(this), r = this;
                                    if (r.inputmask) {
                                        (0, l.HandleNativePlaceholder)(r, t.originalPlaceholder);
                                        var o = r.inputmask._valueGet(), s = c.getBuffer.call(t).slice();
                                        "" !== o && (n.clearMaskOnLostFocus && (-1 === c.getLastValidPosition.call(t) && o === c.getBufferTemplate.call(t).join("") ? s = [] : l.clearOptionalTail.call(t, s)), 
                                        !1 === u.isComplete.call(t, s) && (setTimeout((function() {
                                            a.trigger("incomplete");
                                        }), 0), n.clearIncomplete && (c.resetMaskSet.call(t, !1), s = n.clearMaskOnLostFocus ? [] : c.getBufferTemplate.call(t).slice())), 
                                        (0, l.writeBuffer)(r, s, void 0, e)), o = t._valueGet(!0), t.undoValue !== o && ("" != o || t.undoValue != c.getBufferTemplate.call(t).join("") || t.undoValue == c.getBufferTemplate.call(t).join("") && t.maskset.validPositions.length > 0) && (t.undoValue = o, 
                                        a.trigger("change"));
                                    }
                                },
                                mouseenterEvent: function() {
                                    var e = this.inputmask, t = e.opts.showMaskOnHover, n = this;
                                    if (e.mouseEnter = !0, (n.inputmask.shadowRoot || n.ownerDocument).activeElement !== n) {
                                        var i = (e.isRTL ? c.getBufferTemplate.call(e).slice().reverse() : c.getBufferTemplate.call(e)).join("");
                                        t && (0, l.HandleNativePlaceholder)(n, i);
                                    }
                                },
                                submitEvent: function() {
                                    var e = this.inputmask, t = e.opts;
                                    e.undoValue !== e._valueGet(!0) && e.$el.trigger("change"), -1 === c.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === c.getBufferTemplate.call(e).join("") && e._valueSet(""), 
                                    t.clearIncomplete && !1 === u.isComplete.call(e, c.getBuffer.call(e)) && e._valueSet(""), 
                                    t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout((function() {
                                        (0, l.writeBuffer)(e.el, c.getBuffer.call(e));
                                    }), 0));
                                },
                                resetEvent: function() {
                                    var e = this.inputmask;
                                    e.refreshValue = !0, setTimeout((function() {
                                        (0, l.applyInputValue)(e.el, e._valueGet(!0));
                                    }), 0);
                                }
                            };
                        },
                        9716: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.EventRuler = void 0;
                            var i, a = n(7760), r = (i = n(2394)) && i.__esModule ? i : {
                                default: i
                            }, o = n(2839), l = n(8711);
                            t.EventRuler = {
                                on: function(e, t, n) {
                                    var i = e.inputmask.dependencyLib, s = function(t) {
                                        t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);
                                        var s, c = this, u = c.inputmask, f = u ? u.opts : void 0;
                                        if (void 0 === u && "FORM" !== this.nodeName) {
                                            var p = i.data(c, "_inputmask_opts");
                                            i(c).off(), p && new r.default(p).mask(c);
                                        } else {
                                            if ([ "submit", "reset", "setvalue" ].includes(t.type) || "FORM" === this.nodeName || !(c.disabled || c.readOnly && !("keydown" === t.type && t.ctrlKey && t.key === o.keys.c || !1 === f.tabThrough && t.key === o.keys.Tab))) {
                                                switch (t.type) {
                                                  case "input":
                                                    if (!0 === u.skipInputEvent) return u.skipInputEvent = !1, t.preventDefault();
                                                    break;

                                                  case "click":
                                                  case "focus":
                                                    return u.validationEvent ? (u.validationEvent = !1, e.blur(), (0, a.HandleNativePlaceholder)(e, (u.isRTL ? l.getBufferTemplate.call(u).slice().reverse() : l.getBufferTemplate.call(u)).join("")), 
                                                    setTimeout((function() {
                                                        e.focus();
                                                    }), f.validationEventTimeOut), !1) : (s = arguments, void setTimeout((function() {
                                                        e.inputmask && n.apply(c, s);
                                                    }), 0));
                                                }
                                                var d = n.apply(c, arguments);
                                                return !1 === d && (t.preventDefault(), t.stopPropagation()), d;
                                            }
                                            t.preventDefault();
                                        }
                                    };
                                    [ "submit", "reset" ].includes(t) ? (s = s.bind(e), null !== e.form && i(e.form).on(t, s)) : i(e).on(t, s), 
                                    e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(s);
                                },
                                off: function(e, t) {
                                    if (e.inputmask && e.inputmask.events) {
                                        var n = e.inputmask.dependencyLib, i = e.inputmask.events;
                                        for (var a in t && ((i = [])[t] = e.inputmask.events[t]), i) {
                                            for (var r = i[a]; r.length > 0; ) {
                                                var o = r.pop();
                                                [ "submit", "reset" ].includes(a) ? null !== e.form && n(e.form).off(a, o) : n(e).off(a, o);
                                            }
                                            delete e.inputmask.events[a];
                                        }
                                    }
                                }
                            };
                        },
                        219: function(e, t, n) {
                            var i = p(n(7184)), a = p(n(2394)), r = n(2839), o = n(8711), l = n(4713);
                            function s(e, t) {
                                return function(e) {
                                    if (Array.isArray(e)) return e;
                                }(e) || function(e, t) {
                                    var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (null != n) {
                                        var i, a, r, o, l = [], s = !0, c = !1;
                                        try {
                                            if (r = (n = n.call(e)).next, 0 === t) {
                                                if (Object(n) !== n) return;
                                                s = !1;
                                            } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;
                                        } catch (e) {
                                            c = !0, a = e;
                                        } finally {
                                            try {
                                                if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;
                                            } finally {
                                                if (c) throw a;
                                            }
                                        }
                                        return l;
                                    }
                                }(e, t) || function(e, t) {
                                    if (!e) return;
                                    if ("string" == typeof e) return c(e, t);
                                    var n = Object.prototype.toString.call(e).slice(8, -1);
                                    "Object" === n && e.constructor && (n = e.constructor.name);
                                    if ("Map" === n || "Set" === n) return Array.from(e);
                                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return c(e, t);
                                }(e, t) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }();
                            }
                            function c(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                                return i;
                            }
                            function u(e) {
                                return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, u(e);
                            }
                            function f(e, t) {
                                for (var n = 0; n < t.length; n++) {
                                    var i = t[n];
                                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), 
                                    Object.defineProperty(e, (a = i.key, r = void 0, r = function(e, t) {
                                        if ("object" !== u(e) || null === e) return e;
                                        var n = e[Symbol.toPrimitive];
                                        if (void 0 !== n) {
                                            var i = n.call(e, t || "default");
                                            if ("object" !== u(i)) return i;
                                            throw new TypeError("@@toPrimitive must return a primitive value.");
                                        }
                                        return ("string" === t ? String : Number)(e);
                                    }(a, "string"), "symbol" === u(r) ? r : String(r)), i);
                                }
                                var a, r;
                            }
                            function p(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            n(1313);
                            var d = a.default.dependencyLib, h = function() {
                                function e(t, n, i, a) {
                                    !function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                                    }(this, e), this.mask = t, this.format = n, this.opts = i, this.inputmask = a, this._date = new Date(1, 0, 1), 
                                    this.initDateObject(t, this.opts, this.inputmask);
                                }
                                var t, n, i;
                                return t = e, (n = [ {
                                    key: "date",
                                    get: function() {
                                        return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts, this.inputmask)), 
                                        this._date;
                                    }
                                }, {
                                    key: "initDateObject",
                                    value: function(e, t, n) {
                                        var i;
                                        for (P(t).lastIndex = 0; i = P(t).exec(this.format); ) {
                                            var a = /\d+$/.exec(i[0]), r = a ? i[0][0] + "x" : i[0], o = void 0;
                                            if (void 0 !== e) {
                                                if (a) {
                                                    var s = P(t).lastIndex, c = j.call(n, i.index, t, n && n.maskset);
                                                    P(t).lastIndex = s, o = e.slice(0, e.indexOf(c.nextMatch[0]));
                                                } else {
                                                    for (var u = i[0][0], f = i.index; n && (t.placeholder[l.getTest.call(n, f).match.placeholder] || l.getTest.call(n, f).match.placeholder) === u; ) f++;
                                                    var p = f - i.index;
                                                    o = e.slice(0, p || y[r] && y[r][4] || r.length);
                                                }
                                                e = e.slice(o.length);
                                            }
                                            Object.prototype.hasOwnProperty.call(y, r) && this.setValue(this, o, r, y[r][2], y[r][1]);
                                        }
                                    }
                                }, {
                                    key: "setValue",
                                    value: function(e, t, n, i, a) {
                                        if (void 0 !== t) switch (i) {
                                          case "ampm":
                                            e[i] = t, e["raw" + i] = t.replace(/\s/g, "_");
                                            break;

                                          case "month":
                                            if ("mmm" === n || "mmmm" === n) {
                                                e[i] = _("mmm" === n ? m.monthNames.slice(0, 12).findIndex((function(e) {
                                                    return t.toLowerCase() === e.toLowerCase();
                                                })) + 1 : m.monthNames.slice(12, 24).findIndex((function(e) {
                                                    return t.toLowerCase() === e.toLowerCase();
                                                })) + 1, 2), e[i] = "00" === e[i] ? "" : e[i].toString(), e["raw" + i] = e[i];
                                                break;
                                            }

                                          default:
                                            e[i] = t.replace(/[^0-9]/g, "0"), e["raw" + i] = t.replace(/\s/g, "_");
                                        }
                                        if (void 0 !== a) {
                                            var r = e[i];
                                            ("day" === i && 29 === parseInt(r) || "month" === i && 2 === parseInt(r)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || "" !== e.year && void 0 !== e.year || e._date.setFullYear(2012, 1, 29)), 
                                            "day" === i && (g = !0, 0 === parseInt(r) && (r = 1)), "month" === i && (g = !0), 
                                            "year" === i && (g = !0, r.length < y[n][4] && (r = _(r, y[n][4], !0))), ("" !== r && !isNaN(r) || "ampm" === i) && a.call(e._date, r);
                                        }
                                    }
                                }, {
                                    key: "reset",
                                    value: function() {
                                        this._date = new Date(1, 0, 1);
                                    }
                                }, {
                                    key: "reInit",
                                    value: function() {
                                        this._date = void 0, this.date;
                                    }
                                } ]) && f(t.prototype, n), i && f(t, i), Object.defineProperty(t, "prototype", {
                                    writable: !1
                                }), e;
                            }(), v = (new Date).getFullYear(), m = a.default.prototype.i18n, g = !1, y = {
                                d: [ "[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate ],
                                dd: [ "0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                                    return _(Date.prototype.getDate.call(this), 2);
                                } ],
                                ddd: [ "" ],
                                dddd: [ "" ],
                                m: [ "[1-9]|1[012]", function(e) {
                                    var t = e ? parseInt(e) : 0;
                                    return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return Date.prototype.getMonth.call(this) + 1;
                                } ],
                                mm: [ "0[1-9]|1[012]", function(e) {
                                    var t = e ? parseInt(e) : 0;
                                    return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return _(Date.prototype.getMonth.call(this) + 1, 2);
                                } ],
                                mmm: [ m.monthNames.slice(0, 12).join("|"), function(e) {
                                    var t = m.monthNames.slice(0, 12).findIndex((function(t) {
                                        return e.toLowerCase() === t.toLowerCase();
                                    }));
                                    return -1 !== t && Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return m.monthNames.slice(0, 12)[Date.prototype.getMonth.call(this)];
                                } ],
                                mmmm: [ m.monthNames.slice(12, 24).join("|"), function(e) {
                                    var t = m.monthNames.slice(12, 24).findIndex((function(t) {
                                        return e.toLowerCase() === t.toLowerCase();
                                    }));
                                    return -1 !== t && Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return m.monthNames.slice(12, 24)[Date.prototype.getMonth.call(this)];
                                } ],
                                yy: [ "[0-9]{2}", function(e) {
                                    var t = (new Date).getFullYear().toString().slice(0, 2);
                                    Date.prototype.setFullYear.call(this, "".concat(t).concat(e));
                                }, "year", function() {
                                    return _(Date.prototype.getFullYear.call(this), 2);
                                }, 2 ],
                                yyyy: [ "[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                                    return _(Date.prototype.getFullYear.call(this), 4);
                                }, 4 ],
                                h: [ "[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                                hh: [ "0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                                    return _(Date.prototype.getHours.call(this), 2);
                                } ],
                                hx: [ function(e) {
                                    return "[0-9]{".concat(e, "}");
                                }, Date.prototype.setHours, "hours", function(e) {
                                    return Date.prototype.getHours;
                                } ],
                                H: [ "1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                                HH: [ "0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                                    return _(Date.prototype.getHours.call(this), 2);
                                } ],
                                Hx: [ function(e) {
                                    return "[0-9]{".concat(e, "}");
                                }, Date.prototype.setHours, "hours", function(e) {
                                    return function() {
                                        return _(Date.prototype.getHours.call(this), e);
                                    };
                                } ],
                                M: [ "[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes ],
                                MM: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                                    return _(Date.prototype.getMinutes.call(this), 2);
                                } ],
                                s: [ "[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds ],
                                ss: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                                    return _(Date.prototype.getSeconds.call(this), 2);
                                } ],
                                l: [ "[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                                    return _(Date.prototype.getMilliseconds.call(this), 3);
                                }, 3 ],
                                L: [ "[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                                    return _(Date.prototype.getMilliseconds.call(this), 2);
                                }, 2 ],
                                t: [ "[ap]", b, "ampm", x, 1 ],
                                tt: [ "[ap]m", b, "ampm", x, 2 ],
                                T: [ "[AP]", b, "ampm", x, 1 ],
                                TT: [ "[AP]M", b, "ampm", x, 2 ],
                                Z: [ ".*", void 0, "Z", function() {
                                    var e = this.toString().match(/\((.+)\)/)[1];
                                    e.includes(" ") && (e = (e = e.replace("-", " ").toUpperCase()).split(" ").map((function(e) {
                                        return s(e, 1)[0];
                                    })).join(""));
                                    return e;
                                } ],
                                o: [ "" ],
                                S: [ "" ]
                            }, k = {
                                isoDate: "yyyy-mm-dd",
                                isoTime: "HH:MM:ss",
                                isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
                            };
                            function b(e) {
                                var t = this.getHours();
                                e.toLowerCase().includes("p") ? this.setHours(t + 12) : e.toLowerCase().includes("a") && t >= 12 && this.setHours(t - 12);
                            }
                            function x() {
                                var e = this.getHours();
                                return (e = e || 12) >= 12 ? "PM" : "AM";
                            }
                            function w(e) {
                                var t = /\d+$/.exec(e[0]);
                                if (t && void 0 !== t[0]) {
                                    var n = y[e[0][0] + "x"].slice("");
                                    return n[0] = n[0](t[0]), n[3] = n[3](t[0]), n;
                                }
                                if (y[e[0]]) return y[e[0]];
                            }
                            function P(e) {
                                if (!e.tokenizer) {
                                    var t = [], n = [];
                                    for (var i in y) if (/\.*x$/.test(i)) {
                                        var a = i[0] + "\\d+";
                                        -1 === n.indexOf(a) && n.push(a);
                                    } else -1 === t.indexOf(i[0]) && t.push(i[0]);
                                    e.tokenizer = "(" + (n.length > 0 ? n.join("|") + "|" : "") + t.join("+|") + ")+?|.", 
                                    e.tokenizer = new RegExp(e.tokenizer, "g");
                                }
                                return e.tokenizer;
                            }
                            function S(e, t, n) {
                                if (!g) return !0;
                                if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || "29" == e.day && (!isFinite(e.rawyear) || void 0 === e.rawyear || "" === e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;
                                if ("29" == e.day) {
                                    var i = j.call(this, t.pos, n, this.maskset);
                                    if (i.targetMatch && "yyyy" === i.targetMatch[0] && t.pos - i.targetMatchIndex == 2) return t.remove = t.pos + 1, 
                                    t;
                                } else if (2 == e.date.getMonth() && "30" == e.day && void 0 !== t.c) return e.day = "03", 
                                e.date.setDate(3), e.date.setMonth(1), t.insert = [ {
                                    pos: t.pos,
                                    c: "0"
                                }, {
                                    pos: t.pos + 1,
                                    c: t.c
                                } ], t.caret = o.seekNext.call(this, t.pos + 1), t;
                                return !1;
                            }
                            function O(e, t, n, a) {
                                var r, o, l = "", s = 0, c = {};
                                for (P(n).lastIndex = 0; r = P(n).exec(e); ) {
                                    if (void 0 === t) if (o = w(r)) l += "(" + o[0] + ")", n.placeholder && "" !== n.placeholder ? (c[s] = n.placeholder[r.index % n.placeholder.length], 
                                    c[n.placeholder[r.index % n.placeholder.length]] = r[0].charAt(0)) : c[s] = r[0].charAt(0); else switch (r[0]) {
                                      case "[":
                                        l += "(";
                                        break;

                                      case "]":
                                        l += ")?";
                                        break;

                                      default:
                                        l += (0, i.default)(r[0]), c[s] = r[0].charAt(0);
                                    } else if (o = w(r)) if (!0 !== a && o[3]) l += o[3].call(t.date); else o[2] ? l += t["raw" + o[2]] : l += r[0]; else l += r[0];
                                    s++;
                                }
                                return void 0 === t && (n.placeholder = c), l;
                            }
                            function _(e, t, n) {
                                for (e = String(e), t = t || 2; e.length < t; ) e = n ? e + "0" : "0" + e;
                                return e;
                            }
                            function M(e, t, n) {
                                return "string" == typeof e ? new h(e, t, n, this) : e && "object" === u(e) && Object.prototype.hasOwnProperty.call(e, "date") ? e : void 0;
                            }
                            function E(e, t) {
                                return O(t.inputFormat, {
                                    date: e
                                }, t);
                            }
                            function j(e, t, n) {
                                var i, a, r = this, o = n && n.tests[e] ? t.placeholder[n.tests[e][0].match.placeholder] || n.tests[e][0].match.placeholder : "", s = 0, c = 0;
                                for (P(t).lastIndex = 0; a = P(t).exec(t.inputFormat); ) {
                                    var u = /\d+$/.exec(a[0]);
                                    if (u) c = parseInt(u[0]); else {
                                        for (var f = a[0][0], p = s; r && (t.placeholder[l.getTest.call(r, p).match.placeholder] || l.getTest.call(r, p).match.placeholder) === f; ) p++;
                                        0 === (c = p - s) && (c = a[0].length);
                                    }
                                    if (s += c, -1 != a[0].indexOf(o) || s >= e + 1) {
                                        i = a, a = P(t).exec(t.inputFormat);
                                        break;
                                    }
                                }
                                return {
                                    targetMatchIndex: s - c,
                                    nextMatch: a,
                                    targetMatch: i
                                };
                            }
                            a.default.extendAliases({
                                datetime: {
                                    mask: function(e) {
                                        return e.numericInput = !1, y.S = m.ordinalSuffix.join("|"), e.inputFormat = k[e.inputFormat] || e.inputFormat, 
                                        e.displayFormat = k[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = k[e.outputFormat] || e.outputFormat || e.inputFormat, 
                                        e.regex = O(e.inputFormat, void 0, e), e.min = M(e.min, e.inputFormat, e), e.max = M(e.max, e.inputFormat, e), 
                                        null;
                                    },
                                    placeholder: "",
                                    inputFormat: "isoDateTime",
                                    displayFormat: null,
                                    outputFormat: null,
                                    min: null,
                                    max: null,
                                    skipOptionalPartCharacter: "",
                                    preValidation: function(e, t, n, i, a, r, o, l) {
                                        if (l) return !0;
                                        if (isNaN(n) && e[t] !== n) {
                                            var s = j.call(this, t, a, r);
                                            if (s.nextMatch && s.nextMatch[0] === n && s.targetMatch[0].length > 1) {
                                                var c = w(s.targetMatch)[0];
                                                if (new RegExp(c).test("0" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = "0", 
                                                {
                                                    fuzzy: !0,
                                                    buffer: e,
                                                    refreshFromBuffer: {
                                                        start: t - 1,
                                                        end: t + 1
                                                    },
                                                    pos: t + 1
                                                };
                                            }
                                        }
                                        return !0;
                                    },
                                    postValidation: function(e, t, n, i, a, r, o, s) {
                                        var c, u, f = this;
                                        if (o) return !0;
                                        if (!1 === i && (((c = j.call(f, t + 1, a, r)).targetMatch && c.targetMatchIndex === t && c.targetMatch[0].length > 1 && void 0 !== y[c.targetMatch[0]] || (c = j.call(f, t + 2, a, r)).targetMatch && c.targetMatchIndex === t + 1 && c.targetMatch[0].length > 1 && void 0 !== y[c.targetMatch[0]]) && (u = w(c.targetMatch)[0]), 
                                        void 0 !== u && (void 0 !== r.validPositions[t + 1] && new RegExp(u).test(n + "0") ? (e[t] = n, 
                                        e[t + 1] = "0", i = {
                                            pos: t + 2,
                                            caret: t
                                        }) : new RegExp(u).test("0" + n) && (e[t] = "0", e[t + 1] = n, i = {
                                            pos: t + 2
                                        })), !1 === i)) return i;
                                        if (i.fuzzy && (e = i.buffer, t = i.pos), (c = j.call(f, t, a, r)).targetMatch && c.targetMatch[0] && void 0 !== y[c.targetMatch[0]]) {
                                            var p = w(c.targetMatch);
                                            u = p[0];
                                            var d = e.slice(c.targetMatchIndex, c.targetMatchIndex + c.targetMatch[0].length);
                                            if (!1 === new RegExp(u).test(d.join("")) && 2 === c.targetMatch[0].length && r.validPositions[c.targetMatchIndex] && r.validPositions[c.targetMatchIndex + 1] && (r.validPositions[c.targetMatchIndex + 1].input = "0"), 
                                            "year" == p[2]) for (var h = l.getMaskTemplate.call(f, !1, 1, void 0, !0), m = t + 1; m < e.length; m++) e[m] = h[m], 
                                            r.validPositions.splice(t + 1, 1);
                                        }
                                        var g = i, k = M.call(f, e.join(""), a.inputFormat, a);
                                        return g && !isNaN(k.date.getTime()) && (a.prefillYear && (g = function(e, t, n) {
                                            if (e.year !== e.rawyear) {
                                                var i = v.toString(), a = e.rawyear.replace(/[^0-9]/g, ""), r = i.slice(0, a.length), o = i.slice(a.length);
                                                if (2 === a.length && a === r) {
                                                    var l = new Date(v, e.month - 1, e.day);
                                                    e.day == l.getDate() && (!n.max || n.max.date.getTime() >= l.getTime()) && (e.date.setFullYear(v), 
                                                    e.year = i, t.insert = [ {
                                                        pos: t.pos + 1,
                                                        c: o[0]
                                                    }, {
                                                        pos: t.pos + 2,
                                                        c: o[1]
                                                    } ]);
                                                }
                                            }
                                            return t;
                                        }(k, g, a)), g = function(e, t, n, i) {
                                            if (!t) return t;
                                            if (t && n.min && !isNaN(n.min.date.getTime())) {
                                                var r;
                                                for (e.reset(), P(n).lastIndex = 0; r = P(n).exec(n.inputFormat); ) {
                                                    var o;
                                                    if ((o = w(r)) && o[3]) {
                                                        for (var l = o[1], s = e[o[2]], c = n.min[o[2]], u = n.max ? n.max[o[2]] : c + 1, f = [], p = !1, d = 0; d < c.length; d++) void 0 !== i.validPositions[d + r.index] || p ? (f[d] = s[d], 
                                                        p = p || s[d] > c[d]) : (d + r.index == 0 && s[d] < c[d] ? (f[d] = s[d], p = !0) : f[d] = c[d], 
                                                        "year" === o[2] && s.length - 1 == d && c != u && (f = (parseInt(f.join("")) + 1).toString().split("")), 
                                                        "ampm" === o[2] && c != u && n.min.date.getTime() > e.date.getTime() && (f[d] = u[d]));
                                                        l.call(e._date, f.join(""));
                                                    }
                                                }
                                                t = n.min.date.getTime() <= e.date.getTime(), e.reInit();
                                            }
                                            return t && n.max && (isNaN(n.max.date.getTime()) || (t = n.max.date.getTime() >= e.date.getTime())), 
                                            t;
                                        }(k, g = S.call(f, k, g, a), a, r)), void 0 !== t && g && i.pos !== t ? {
                                            buffer: O(a.inputFormat, k, a).split(""),
                                            refreshFromBuffer: {
                                                start: t,
                                                end: i.pos
                                            },
                                            pos: i.caret || i.pos
                                        } : g;
                                    },
                                    onKeyDown: function(e, t, n, i) {
                                        e.ctrlKey && e.key === r.keys.ArrowRight && (this.inputmask._valueSet(E(new Date, i)), 
                                        d(this).trigger("setvalue"));
                                    },
                                    onUnMask: function(e, t, n) {
                                        return t ? O(n.outputFormat, M.call(this, e, n.inputFormat, n), n, !0) : t;
                                    },
                                    casing: function(e, t, n, i) {
                                        if (0 == t.nativeDef.indexOf("[ap]")) return e.toLowerCase();
                                        if (0 == t.nativeDef.indexOf("[AP]")) return e.toUpperCase();
                                        var a = l.getTest.call(this, [ n - 1 ]);
                                        return 0 == a.match.def.indexOf("[AP]") || 0 === n || a && a.input === String.fromCharCode(r.keyCode.Space) || a && a.match.def === String.fromCharCode(r.keyCode.Space) ? e.toUpperCase() : e.toLowerCase();
                                    },
                                    onBeforeMask: function(e, t) {
                                        return "[object Date]" === Object.prototype.toString.call(e) && (e = E(e, t)), e;
                                    },
                                    insertMode: !1,
                                    insertModeVisual: !1,
                                    shiftPositions: !1,
                                    keepStatic: !1,
                                    inputmode: "numeric",
                                    prefillYear: !0
                                }
                            });
                        },
                        1313: function(e, t, n) {
                            var i, a = (i = n(2394)) && i.__esModule ? i : {
                                default: i
                            };
                            a.default.dependencyLib.extend(!0, a.default.prototype.i18n, {
                                dayNames: [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ],
                                monthNames: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                                ordinalSuffix: [ "st", "nd", "rd", "th" ]
                            });
                        },
                        3851: function(e, t, n) {
                            var i, a = (i = n(2394)) && i.__esModule ? i : {
                                default: i
                            }, r = n(8711), o = n(4713);
                            function l(e) {
                                return function(e) {
                                    if (Array.isArray(e)) return s(e);
                                }(e) || function(e) {
                                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
                                }(e) || function(e, t) {
                                    if (!e) return;
                                    if ("string" == typeof e) return s(e, t);
                                    var n = Object.prototype.toString.call(e).slice(8, -1);
                                    "Object" === n && e.constructor && (n = e.constructor.name);
                                    if ("Map" === n || "Set" === n) return Array.from(e);
                                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(e, t);
                                }(e) || function() {
                                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }();
                            }
                            function s(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                                return i;
                            }
                            a.default.extendDefinitions({
                                A: {
                                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                                    casing: "upper"
                                },
                                "&": {
                                    validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                                    casing: "upper"
                                },
                                "#": {
                                    validator: "[0-9A-Fa-f]",
                                    casing: "upper"
                                }
                            });
                            var c = /25[0-5]|2[0-4][0-9]|[01][0-9][0-9]/;
                            function u(e, t, n, i, a) {
                                if (n - 1 > -1 && "." !== t.buffer[n - 1] ? (e = t.buffer[n - 1] + e, e = n - 2 > -1 && "." !== t.buffer[n - 2] ? t.buffer[n - 2] + e : "0" + e) : e = "00" + e, 
                                a.greedy && parseInt(e) > 255 && c.test("00" + e.charAt(2))) {
                                    var r = [].concat(l(t.buffer.slice(0, n)), [ ".", e.charAt(2) ]);
                                    if (r.join("").match(/\./g).length < 4) return {
                                        refreshFromBuffer: !0,
                                        buffer: r,
                                        caret: n + 2
                                    };
                                }
                                return c.test(e);
                            }
                            a.default.extendAliases({
                                cssunit: {
                                    regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                                },
                                url: {
                                    regex: "(https?|ftp)://.*",
                                    autoUnmask: !1,
                                    keepStatic: !1,
                                    tabThrough: !0
                                },
                                ip: {
                                    mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                                    definitions: {
                                        i: {
                                            validator: u
                                        },
                                        j: {
                                            validator: u
                                        },
                                        k: {
                                            validator: u
                                        },
                                        l: {
                                            validator: u
                                        }
                                    },
                                    onUnMask: function(e, t, n) {
                                        return e;
                                    },
                                    inputmode: "decimal",
                                    substitutes: {
                                        ",": "."
                                    }
                                },
                                email: {
                                    mask: function(e) {
                                        var t = e.separator, n = e.quantifier, i = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", a = i;
                                        if (t) for (var r = 0; r < n; r++) a += "[".concat(t).concat(i, "]");
                                        return a;
                                    },
                                    greedy: !1,
                                    casing: "lower",
                                    separator: null,
                                    quantifier: 5,
                                    skipOptionalPartCharacter: "",
                                    onBeforePaste: function(e, t) {
                                        return (e = e.toLowerCase()).replace("mailto:", "");
                                    },
                                    definitions: {
                                        "*": {
                                            validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]"
                                        },
                                        "-": {
                                            validator: "[0-9A-Za-z-]"
                                        }
                                    },
                                    onUnMask: function(e, t, n) {
                                        return e;
                                    },
                                    inputmode: "email"
                                },
                                mac: {
                                    mask: "##:##:##:##:##:##"
                                },
                                vin: {
                                    mask: "V{13}9{4}",
                                    definitions: {
                                        V: {
                                            validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                                            casing: "upper"
                                        }
                                    },
                                    clearIncomplete: !0,
                                    autoUnmask: !0
                                },
                                ssn: {
                                    mask: "999-99-9999",
                                    postValidation: function(e, t, n, i, a, l, s) {
                                        var c = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);
                                        return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(c.join(""));
                                    }
                                }
                            });
                        },
                        207: function(e, t, n) {
                            var i = l(n(7184)), a = l(n(2394)), r = n(2839), o = n(8711);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = a.default.dependencyLib;
                            function c(e, t) {
                                for (var n = "", i = 0; i < e.length; i++) a.default.prototype.definitions[e.charAt(i)] || t.definitions[e.charAt(i)] || t.optionalmarker[0] === e.charAt(i) || t.optionalmarker[1] === e.charAt(i) || t.quantifiermarker[0] === e.charAt(i) || t.quantifiermarker[1] === e.charAt(i) || t.groupmarker[0] === e.charAt(i) || t.groupmarker[1] === e.charAt(i) || t.alternatormarker === e.charAt(i) ? n += "\\" + e.charAt(i) : n += e.charAt(i);
                                return n;
                            }
                            function u(e, t, n, i) {
                                if (e.length > 0 && t > 0 && (!n.digitsOptional || i)) {
                                    var a = e.indexOf(n.radixPoint), r = !1;
                                    n.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === a && (e.push(n.radixPoint), 
                                    a = e.length - 1);
                                    for (var o = 1; o <= t; o++) isFinite(e[a + o]) || (e[a + o] = "0");
                                }
                                return r && e.push(n.negationSymbol.back), e;
                            }
                            function f(e, t) {
                                var n = 0;
                                for (var i in "+" === e && (n = o.seekNext.call(this, t.validPositions.length - 1)), 
                                t.tests) if ((i = parseInt(i)) >= n) for (var a = 0, r = t.tests[i].length; a < r; a++) if ((void 0 === t.validPositions[i] || "-" === e) && t.tests[i][a].match.def === e) return i + (void 0 !== t.validPositions[i] && "-" !== e ? 1 : 0);
                                return n;
                            }
                            function p(e, t) {
                                for (var n = -1, i = 0, a = t.validPositions.length; i < a; i++) {
                                    var r = t.validPositions[i];
                                    if (r && r.match.def === e) {
                                        n = i;
                                        break;
                                    }
                                }
                                return n;
                            }
                            function d(e, t, n, i, a) {
                                var r = t.buffer ? t.buffer.indexOf(a.radixPoint) : -1, o = (-1 !== r || i && a.jitMasking) && new RegExp(a.definitions[9].validator).test(e);
                                return !i && a._radixDance && -1 !== r && o && null == t.validPositions[r] ? {
                                    insert: {
                                        pos: r === n ? r + 1 : r,
                                        c: a.radixPoint
                                    },
                                    pos: n
                                } : o;
                            }
                            a.default.extendAliases({
                                numeric: {
                                    mask: function(e) {
                                        e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && "0" !== e.digits && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""), 
                                        " " === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)), 
                                        "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && (e.positionCaretOnClick = "lvp");
                                        var t = "0", n = e.radixPoint;
                                        !0 === e.numericInput && void 0 === e.__financeInput ? (t = "1", e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick, 
                                        e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, n = "," === e.radixPoint ? "?" : "!", 
                                        "" !== e.radixPoint && void 0 === e.definitions[n] && (e.definitions[n] = {}, e.definitions[n].validator = "[" + e.radixPoint + "]", 
                                        e.definitions[n].placeholder = e.radixPoint, e.definitions[n].static = !0, e.definitions[n].generated = !0)) : (e.__financeInput = !1, 
                                        e.numericInput = !0);
                                        var a, r = "[+]";
                                        if (r += c(e.prefix, e), "" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {}, 
                                        e.definitions[e.groupSeparator].validator = "[" + e.groupSeparator + "]", e.definitions[e.groupSeparator].placeholder = e.groupSeparator, 
                                        e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0), 
                                        r += e._mask(e)) : r += "9{+}", void 0 !== e.digits && 0 !== e.digits) {
                                            var o = e.digits.toString().split(",");
                                            isFinite(o[0]) && o[1] && isFinite(o[1]) ? r += n + t + "{" + e.digits + "}" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (a = r + n + t + "{0," + e.digits + "}", 
                                            e.keepStatic = !0) : r += n + t + "{" + e.digits + "}");
                                        } else e.inputmode = "numeric";
                                        return r += c(e.suffix, e), r += "[-]", a && (r = [ a + c(e.suffix, e) + "[-]", r ]), 
                                        e.greedy = !1, function(e) {
                                            void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0, 
                                            i.default)(e.groupSeparator), "g"), ""), "," === e.radixPoint && (e.min = e.min.replace(e.radixPoint, ".")), 
                                            e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)), 
                                            null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, i.default)(e.groupSeparator), "g"), ""), 
                                            "," === e.radixPoint && (e.max = e.max.replace(e.radixPoint, ".")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN, 
                                            isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = "done");
                                        }(e), "" !== e.radixPoint && e.substituteRadixPoint && (e.substitutes["." == e.radixPoint ? "," : "."] = e.radixPoint), 
                                        r;
                                    },
                                    _mask: function(e) {
                                        return "(" + e.groupSeparator + "999){+|1}";
                                    },
                                    digits: "*",
                                    digitsOptional: !0,
                                    enforceDigitsOnBlur: !1,
                                    radixPoint: ".",
                                    positionCaretOnClick: "radixFocus",
                                    _radixDance: !0,
                                    groupSeparator: "",
                                    allowMinus: !0,
                                    negationSymbol: {
                                        front: "-",
                                        back: ""
                                    },
                                    prefix: "",
                                    suffix: "",
                                    min: null,
                                    max: null,
                                    SetMaxOnOverflow: !1,
                                    step: 1,
                                    inputType: "text",
                                    unmaskAsNumber: !1,
                                    roundingFN: Math.round,
                                    inputmode: "decimal",
                                    shortcuts: {
                                        k: "1000",
                                        m: "1000000"
                                    },
                                    placeholder: "0",
                                    greedy: !1,
                                    rightAlign: !0,
                                    insertMode: !0,
                                    autoUnmask: !1,
                                    skipOptionalPartCharacter: "",
                                    usePrototypeDefinitions: !1,
                                    stripLeadingZeroes: !0,
                                    substituteRadixPoint: !0,
                                    definitions: {
                                        0: {
                                            validator: d
                                        },
                                        1: {
                                            validator: d,
                                            definitionSymbol: "9"
                                        },
                                        9: {
                                            validator: "[0-9０-９٠-٩۰-۹]",
                                            definitionSymbol: "*"
                                        },
                                        "+": {
                                            validator: function(e, t, n, i, a) {
                                                return a.allowMinus && ("-" === e || e === a.negationSymbol.front);
                                            }
                                        },
                                        "-": {
                                            validator: function(e, t, n, i, a) {
                                                return a.allowMinus && e === a.negationSymbol.back;
                                            }
                                        }
                                    },
                                    preValidation: function(e, t, n, i, a, r, o, l) {
                                        var s = this;
                                        if (!1 !== a.__financeInput && n === a.radixPoint) return !1;
                                        var c = e.indexOf(a.radixPoint), u = t;
                                        if (t = function(e, t, n, i, a) {
                                            return a._radixDance && a.numericInput && t !== a.negationSymbol.back && e <= n && (n > 0 || t == a.radixPoint) && (void 0 === i.validPositions[e - 1] || i.validPositions[e - 1].input !== a.negationSymbol.back) && (e -= 1), 
                                            e;
                                        }(t, n, c, r, a), "-" === n || n === a.negationSymbol.front) {
                                            if (!0 !== a.allowMinus) return !1;
                                            var d = !1, h = p("+", r), v = p("-", r);
                                            return -1 !== h && (d = [ h ], -1 !== v && d.push(v)), !1 !== d ? {
                                                remove: d,
                                                caret: u - a.negationSymbol.back.length
                                            } : {
                                                insert: [ {
                                                    pos: f.call(s, "+", r),
                                                    c: a.negationSymbol.front,
                                                    fromIsValid: !0
                                                }, {
                                                    pos: f.call(s, "-", r),
                                                    c: a.negationSymbol.back,
                                                    fromIsValid: void 0
                                                } ],
                                                caret: u + a.negationSymbol.back.length
                                            };
                                        }
                                        if (n === a.groupSeparator) return {
                                            caret: u
                                        };
                                        if (l) return !0;
                                        if (-1 !== c && !0 === a._radixDance && !1 === i && n === a.radixPoint && void 0 !== a.digits && (isNaN(a.digits) || parseInt(a.digits) > 0) && c !== t) {
                                            var m = f.call(s, a.radixPoint, r);
                                            return r.validPositions[m] && (r.validPositions[m].generatedInput = r.validPositions[m].generated || !1), 
                                            {
                                                caret: a._radixDance && t === c - 1 ? c + 1 : c
                                            };
                                        }
                                        if (!1 === a.__financeInput) if (i) {
                                            if (a.digitsOptional) return {
                                                rewritePosition: o.end
                                            };
                                            if (!a.digitsOptional) {
                                                if (o.begin > c && o.end <= c) return n === a.radixPoint ? {
                                                    insert: {
                                                        pos: c + 1,
                                                        c: "0",
                                                        fromIsValid: !0
                                                    },
                                                    rewritePosition: c
                                                } : {
                                                    rewritePosition: c + 1
                                                };
                                                if (o.begin < c) return {
                                                    rewritePosition: o.begin - 1
                                                };
                                            }
                                        } else if (!a.showMaskOnHover && !a.showMaskOnFocus && !a.digitsOptional && a.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                                            rewritePosition: c
                                        };
                                        return {
                                            rewritePosition: t
                                        };
                                    },
                                    postValidation: function(e, t, n, i, a, r, o) {
                                        if (!1 === i) return i;
                                        if (o) return !0;
                                        if (null !== a.min || null !== a.max) {
                                            var l = a.onUnMask(e.slice().reverse().join(""), void 0, s.extend({}, a, {
                                                unmaskAsNumber: !0
                                            }));
                                            if (null !== a.min && l < a.min && (l.toString().length > a.min.toString().length || l < 0)) return !1;
                                            if (null !== a.max && l > a.max) return !!a.SetMaxOnOverflow && {
                                                refreshFromBuffer: !0,
                                                buffer: u(a.max.toString().replace(".", a.radixPoint).split(""), a.digits, a).reverse()
                                            };
                                        }
                                        return i;
                                    },
                                    onUnMask: function(e, t, n) {
                                        if ("" === t && !0 === n.nullable) return t;
                                        var a = e.replace(n.prefix, "");
                                        return a = (a = a.replace(n.suffix, "")).replace(new RegExp((0, i.default)(n.groupSeparator), "g"), ""), 
                                        "" !== n.placeholder.charAt(0) && (a = a.replace(new RegExp(n.placeholder.charAt(0), "g"), "0")), 
                                        n.unmaskAsNumber ? ("" !== n.radixPoint && -1 !== a.indexOf(n.radixPoint) && (a = a.replace(i.default.call(this, n.radixPoint), ".")), 
                                        a = (a = a.replace(new RegExp("^" + (0, i.default)(n.negationSymbol.front)), "-")).replace(new RegExp((0, 
                                        i.default)(n.negationSymbol.back) + "$"), ""), Number(a)) : a;
                                    },
                                    isComplete: function(e, t) {
                                        var n = (t.numericInput ? e.slice().reverse() : e).join("");
                                        return n = (n = (n = (n = (n = n.replace(new RegExp("^" + (0, i.default)(t.negationSymbol.front)), "-")).replace(new RegExp((0, 
                                        i.default)(t.negationSymbol.back) + "$"), "")).replace(t.prefix, "")).replace(t.suffix, "")).replace(new RegExp((0, 
                                        i.default)(t.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t.radixPoint && (n = n.replace((0, 
                                        i.default)(t.radixPoint), ".")), isFinite(n);
                                    },
                                    onBeforeMask: function(e, t) {
                                        var n;
                                        e = null !== (n = e) && void 0 !== n ? n : "";
                                        var a = t.radixPoint || ",";
                                        isFinite(t.digits) && (t.digits = parseInt(t.digits)), "number" != typeof e && "number" !== t.inputType || "" === a || (e = e.toString().replace(".", a));
                                        var r = "-" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front, o = e.split(a), l = o[0].replace(/[^\-0-9]/g, ""), s = o.length > 1 ? o[1].replace(/[^0-9]/g, "") : "", c = o.length > 1;
                                        e = l + ("" !== s ? a + s : s);
                                        var f = 0;
                                        if ("" !== a && (f = t.digitsOptional ? t.digits < s.length ? t.digits : s.length : t.digits, 
                                        "" !== s || !t.digitsOptional)) {
                                            var p = Math.pow(10, f || 1);
                                            e = e.replace((0, i.default)(a), "."), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * p) / p).toFixed(f)), 
                                            e = e.toString().replace(".", a);
                                        }
                                        if (0 === t.digits && -1 !== e.indexOf(a) && (e = e.substring(0, e.indexOf(a))), 
                                        null !== t.min || null !== t.max) {
                                            var d = e.toString().replace(a, ".");
                                            null !== t.min && d < t.min ? e = t.min.toString().replace(".", a) : null !== t.max && d > t.max && (e = t.max.toString().replace(".", a));
                                        }
                                        return r && "-" !== e.charAt(0) && (e = "-" + e), u(e.toString().split(""), f, t, c).join("");
                                    },
                                    onBeforeWrite: function(e, t, n, a) {
                                        function r(e, t) {
                                            if (!1 !== a.__financeInput || t) {
                                                var n = e.indexOf(a.radixPoint);
                                                -1 !== n && e.splice(n, 1);
                                            }
                                            if ("" !== a.groupSeparator) for (;-1 !== (n = e.indexOf(a.groupSeparator)); ) e.splice(n, 1);
                                            return e;
                                        }
                                        var o, l;
                                        if (a.stripLeadingZeroes && (l = function(e, t) {
                                            var n = new RegExp("(^" + ("" !== t.negationSymbol.front ? (0, i.default)(t.negationSymbol.front) + "?" : "") + (0, 
                                            i.default)(t.prefix) + ")(.*)(" + (0, i.default)(t.suffix) + ("" != t.negationSymbol.back ? (0, 
                                            i.default)(t.negationSymbol.back) + "?" : "") + "$)").exec(e.slice().reverse().join("")), a = n ? n[2] : "", r = !1;
                                            return a && (a = a.split(t.radixPoint.charAt(0))[0], r = new RegExp("^[0" + t.groupSeparator + "]*").exec(a)), 
                                            !(!r || !(r[0].length > 1 || r[0].length > 0 && r[0].length < a.length)) && r;
                                        }(t, a))) for (var c = t.join("").lastIndexOf(l[0].split("").reverse().join("")) - (l[0] == l.input ? 0 : 1), f = l[0] == l.input ? 1 : 0, p = l[0].length - f; p > 0; p--) this.maskset.validPositions.splice(c + p, 1), 
                                        delete t[c + p];
                                        if (e) switch (e.type) {
                                          case "blur":
                                          case "checkval":
                                            if (null !== a.min) {
                                                var d = a.onUnMask(t.slice().reverse().join(""), void 0, s.extend({}, a, {
                                                    unmaskAsNumber: !0
                                                }));
                                                if (null !== a.min && d < a.min) return {
                                                    refreshFromBuffer: !0,
                                                    buffer: u(a.min.toString().replace(".", a.radixPoint).split(""), a.digits, a).reverse()
                                                };
                                            }
                                            if (t[t.length - 1] === a.negationSymbol.front) {
                                                var h = new RegExp("(^" + ("" != a.negationSymbol.front ? (0, i.default)(a.negationSymbol.front) + "?" : "") + (0, 
                                                i.default)(a.prefix) + ")(.*)(" + (0, i.default)(a.suffix) + ("" != a.negationSymbol.back ? (0, 
                                                i.default)(a.negationSymbol.back) + "?" : "") + "$)").exec(r(t.slice(), !0).reverse().join(""));
                                                0 == (h ? h[2] : "") && (o = {
                                                    refreshFromBuffer: !0,
                                                    buffer: [ 0 ]
                                                });
                                            } else if ("" !== a.radixPoint) t.indexOf(a.radixPoint) === a.suffix.length && (o && o.buffer ? o.buffer.splice(0, 1 + a.suffix.length) : (t.splice(0, 1 + a.suffix.length), 
                                            o = {
                                                refreshFromBuffer: !0,
                                                buffer: r(t)
                                            }));
                                            if (a.enforceDigitsOnBlur) {
                                                var v = (o = o || {}) && o.buffer || t.slice().reverse();
                                                o.refreshFromBuffer = !0, o.buffer = u(v, a.digits, a, !0).reverse();
                                            }
                                        }
                                        return o;
                                    },
                                    onKeyDown: function(e, t, n, i) {
                                        var a, o = s(this);
                                        if (3 != e.location) {
                                            var l, c = e.key;
                                            if ((l = i.shortcuts && i.shortcuts[c]) && l.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(l)), 
                                            o.trigger("setvalue"), !1;
                                        }
                                        if (e.ctrlKey) switch (e.key) {
                                          case r.keys.ArrowUp:
                                            return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(i.step)), 
                                            o.trigger("setvalue"), !1;

                                          case r.keys.ArrowDown:
                                            return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(i.step)), 
                                            o.trigger("setvalue"), !1;
                                        }
                                        if (!e.shiftKey && (e.key === r.keys.Delete || e.key === r.keys.Backspace || e.key === r.keys.BACKSPACE_SAFARI) && n.begin !== t.length) {
                                            if (t[e.key === r.keys.Delete ? n.begin - 1 : n.end] === i.negationSymbol.front) return a = t.slice().reverse(), 
                                            "" !== i.negationSymbol.front && a.shift(), "" !== i.negationSymbol.back && a.pop(), 
                                            o.trigger("setvalue", [ a.join(""), n.begin ]), !1;
                                            if (!0 === i._radixDance) {
                                                var f, p = t.indexOf(i.radixPoint);
                                                if (i.digitsOptional) {
                                                    if (0 === p) return (a = t.slice().reverse()).pop(), o.trigger("setvalue", [ a.join(""), n.begin >= a.length ? a.length : n.begin ]), 
                                                    !1;
                                                } else if (-1 !== p && (n.begin < p || n.end < p || e.key === r.keys.Delete && (n.begin === p || n.begin - 1 === p))) return n.begin === n.end && (e.key === r.keys.Backspace || e.key === r.keys.BACKSPACE_SAFARI ? n.begin++ : e.key === r.keys.Delete && n.begin - 1 === p && (f = s.extend({}, n), 
                                                n.begin--, n.end--)), (a = t.slice().reverse()).splice(a.length - n.begin, n.begin - n.end + 1), 
                                                a = u(a, i.digits, i).join(""), f && (n = f), o.trigger("setvalue", [ a, n.begin >= a.length ? p + 1 : n.begin ]), 
                                                !1;
                                            }
                                        }
                                    }
                                },
                                currency: {
                                    prefix: "",
                                    groupSeparator: ",",
                                    alias: "numeric",
                                    digits: 2,
                                    digitsOptional: !1
                                },
                                decimal: {
                                    alias: "numeric"
                                },
                                integer: {
                                    alias: "numeric",
                                    inputmode: "numeric",
                                    digits: 0
                                },
                                percentage: {
                                    alias: "numeric",
                                    min: 0,
                                    max: 100,
                                    suffix: " %",
                                    digits: 0,
                                    allowMinus: !1
                                },
                                indianns: {
                                    alias: "numeric",
                                    _mask: function(e) {
                                        return "(" + e.groupSeparator + "99){*|1}(" + e.groupSeparator + "999){1|1}";
                                    },
                                    groupSeparator: ",",
                                    radixPoint: ".",
                                    placeholder: "0",
                                    digits: 2,
                                    digitsOptional: !1
                                }
                            });
                        },
                        9380: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var n = !("undefined" == typeof window || !window.document || !window.document.createElement);
                            t.default = n ? window : {};
                        },
                        7760: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.HandleNativePlaceholder = function(e, t) {
                                var n = e ? e.inputmask : this;
                                if (i.ie) {
                                    if (e.inputmask._valueGet() !== t && (e.placeholder !== t || "" === e.placeholder)) {
                                        var a = o.getBuffer.call(n).slice(), r = e.inputmask._valueGet();
                                        if (r !== t) {
                                            var l = o.getLastValidPosition.call(n);
                                            -1 === l && r === o.getBufferTemplate.call(n).join("") ? a = [] : -1 !== l && u.call(n, a), 
                                            p(e, a);
                                        }
                                    }
                                } else e.placeholder !== t && (e.placeholder = t, "" === e.placeholder && e.removeAttribute("placeholder"));
                            }, t.applyInputValue = c, t.checkVal = f, t.clearOptionalTail = u, t.unmaskedvalue = function(e) {
                                var t = e ? e.inputmask : this, n = t.opts, i = t.maskset;
                                if (e) {
                                    if (void 0 === e.inputmask) return e.value;
                                    e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));
                                }
                                for (var a = [], r = i.validPositions, l = 0, s = r.length; l < s; l++) r[l] && r[l].match && (1 != r[l].match.static || Array.isArray(i.metadata) && !0 !== r[l].generatedInput) && a.push(r[l].input);
                                var u = 0 === a.length ? "" : (t.isRTL ? a.reverse() : a).join("");
                                if ("function" == typeof n.onUnMask) {
                                    var f = (t.isRTL ? o.getBuffer.call(t).slice().reverse() : o.getBuffer.call(t)).join("");
                                    u = n.onUnMask.call(t, f, u, n);
                                }
                                return u;
                            }, t.writeBuffer = p;
                            var i = n(9845), a = n(6030), r = n(2839), o = n(8711), l = n(7215), s = n(4713);
                            function c(e, t, n) {
                                var i = e ? e.inputmask : this, a = i.opts;
                                e.inputmask.refreshValue = !1, "function" == typeof a.onBeforeMask && (t = a.onBeforeMask.call(i, t, a) || t), 
                                f(e, !0, !1, t = (t || "").toString().split(""), n), i.undoValue = i._valueGet(!0), 
                                (a.clearMaskOnLostFocus || a.clearIncomplete) && e.inputmask._valueGet() === o.getBufferTemplate.call(i).join("") && -1 === o.getLastValidPosition.call(i) && e.inputmask._valueSet("");
                            }
                            function u(e) {
                                e.length = 0;
                                for (var t, n = s.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = n.shift()); ) e.push(t);
                                return e;
                            }
                            function f(e, t, n, i, r) {
                                var c, u = e ? e.inputmask : this, f = u.maskset, d = u.opts, h = u.dependencyLib, v = i.slice(), m = "", g = -1, y = d.skipOptionalPartCharacter;
                                d.skipOptionalPartCharacter = "", o.resetMaskSet.call(u, !1), u.clicked = 0, g = d.radixPoint ? o.determineNewCaretPosition.call(u, {
                                    begin: 0,
                                    end: 0
                                }, !1, !1 === d.__financeInput ? "radixFocus" : void 0).begin : 0, f.p = g, u.caretPos = {
                                    begin: g
                                };
                                var k = [], b = u.caretPos;
                                if (v.forEach((function(e, t) {
                                    if (void 0 !== e) {
                                        var i = new h.Event("_checkval");
                                        i.key = e, m += e;
                                        var r = o.getLastValidPosition.call(u, void 0, !0);
                                        !function(e, t) {
                                            for (var n = s.getMaskTemplate.call(u, !0, 0).slice(e, o.seekNext.call(u, e, !1, !1)).join("").replace(/'/g, ""), i = n.indexOf(t); i > 0 && " " === n[i - 1]; ) i--;
                                            var a = 0 === i && !o.isMask.call(u, e) && (s.getTest.call(u, e).match.nativeDef === t.charAt(0) || !0 === s.getTest.call(u, e).match.static && s.getTest.call(u, e).match.nativeDef === "'" + t.charAt(0) || " " === s.getTest.call(u, e).match.nativeDef && (s.getTest.call(u, e + 1).match.nativeDef === t.charAt(0) || !0 === s.getTest.call(u, e + 1).match.static && s.getTest.call(u, e + 1).match.nativeDef === "'" + t.charAt(0)));
                                            if (!a && i > 0 && !o.isMask.call(u, e, !1, !0)) {
                                                var r = o.seekNext.call(u, e);
                                                u.caretPos.begin < r && (u.caretPos = {
                                                    begin: r
                                                });
                                            }
                                            return a;
                                        }(g, m) ? (c = a.EventHandlers.keypressEvent.call(u, i, !0, !1, n, u.caretPos.begin)) && (g = u.caretPos.begin + 1, 
                                        m = "") : c = a.EventHandlers.keypressEvent.call(u, i, !0, !1, n, r + 1), c ? (void 0 !== c.pos && f.validPositions[c.pos] && !0 === f.validPositions[c.pos].match.static && void 0 === f.validPositions[c.pos].alternation && (k.push(c.pos), 
                                        u.isRTL || (c.forwardPosition = c.pos + 1)), p.call(u, void 0, o.getBuffer.call(u), c.forwardPosition, i, !1), 
                                        u.caretPos = {
                                            begin: c.forwardPosition,
                                            end: c.forwardPosition
                                        }, b = u.caretPos) : void 0 === f.validPositions[t] && v[t] === s.getPlaceholder.call(u, t) && o.isMask.call(u, t, !0) ? u.caretPos.begin++ : u.caretPos = b;
                                    }
                                })), k.length > 0) {
                                    var x, w, P = o.seekNext.call(u, -1, void 0, !1);
                                    if (!l.isComplete.call(u, o.getBuffer.call(u)) && k.length <= P || l.isComplete.call(u, o.getBuffer.call(u)) && k.length > 0 && k.length !== P && 0 === k[0]) for (var S = P; void 0 !== (x = k.shift()); ) if (x < S) {
                                        var O = new h.Event("_checkval");
                                        if ((w = f.validPositions[x]).generatedInput = !0, O.key = w.input, (c = a.EventHandlers.keypressEvent.call(u, O, !0, !1, n, S)) && void 0 !== c.pos && c.pos !== x && f.validPositions[c.pos] && !0 === f.validPositions[c.pos].match.static) k.push(c.pos); else if (!c) break;
                                        S++;
                                    }
                                }
                                t && p.call(u, e, o.getBuffer.call(u), c ? c.forwardPosition : u.caretPos.begin, r || new h.Event("checkval"), r && ("input" === r.type && u.undoValue !== o.getBuffer.call(u).join("") || "paste" === r.type)), 
                                d.skipOptionalPartCharacter = y;
                            }
                            function p(e, t, n, i, a) {
                                var s = e ? e.inputmask : this, c = s.opts, u = s.dependencyLib;
                                if (i && "function" == typeof c.onBeforeWrite) {
                                    var f = c.onBeforeWrite.call(s, i, t, n, c);
                                    if (f) {
                                        if (f.refreshFromBuffer) {
                                            var p = f.refreshFromBuffer;
                                            l.refreshFromBuffer.call(s, !0 === p ? p : p.start, p.end, f.buffer || t), t = o.getBuffer.call(s, !0);
                                        }
                                        void 0 !== n && (n = void 0 !== f.caret ? f.caret : n);
                                    }
                                }
                                if (void 0 !== e && (e.inputmask._valueSet(t.join("")), void 0 === n || void 0 !== i && "blur" === i.type || o.caret.call(s, e, n, void 0, void 0, void 0 !== i && "keydown" === i.type && (i.key === r.keys.Delete || i.key === r.keys.Backspace)), 
                                void 0 === e.inputmask.writeBufferHook || e.inputmask.writeBufferHook(n), !0 === a)) {
                                    var d = u(e), h = e.inputmask._valueGet();
                                    e.inputmask.skipInputEvent = !0, d.trigger("input"), setTimeout((function() {
                                        h === o.getBufferTemplate.call(s).join("") ? d.trigger("cleared") : !0 === l.isComplete.call(s, t) && d.trigger("complete");
                                    }), 0);
                                }
                            }
                        },
                        2394: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var i = v(n(3976)), a = v(n(7392)), r = v(n(4963)), o = n(9716), l = v(n(9380)), s = n(7760), c = n(157), u = n(2391), f = n(8711), p = n(7215), d = n(4713);
                            function h(e) {
                                return h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, h(e);
                            }
                            function v(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var m = l.default.document, g = "_inputmask_opts";
                            function y(e, t, n) {
                                if (!(this instanceof y)) return new y(e, t, n);
                                this.dependencyLib = r.default, this.el = void 0, this.events = {}, this.maskset = void 0, 
                                !0 !== n && ("[object Object]" === Object.prototype.toString.call(e) ? t = e : (t = t || {}, 
                                e && (t.alias = e)), this.opts = r.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, 
                                this.userOptions = t || {}, k(this.opts.alias, t, this.opts)), this.refreshValue = !1, 
                                this.undoValue = void 0, this.$el = void 0, this.skipInputEvent = !1, this.validationEvent = !1, 
                                this.ignorable = !1, this.maxLength, this.mouseEnter = !1, this.clicked = 0, this.originalPlaceholder = void 0, 
                                this.isComposing = !1, this.hasAlternator = !1;
                            }
                            function k(e, t, n) {
                                var i = y.prototype.aliases[e];
                                return i ? (i.alias && k(i.alias, void 0, n), r.default.extend(!0, n, i), r.default.extend(!0, n, t), 
                                !0) : (null === n.mask && (n.mask = e), !1);
                            }
                            y.prototype = {
                                dataAttribute: "data-inputmask",
                                defaults: i.default,
                                definitions: a.default,
                                aliases: {},
                                masksCache: {},
                                i18n: {},
                                get isRTL() {
                                    return this.opts.isRTL || this.opts.numericInput;
                                },
                                mask: function(e) {
                                    var t = this;
                                    return "string" == typeof e && (e = m.getElementById(e) || m.querySelectorAll(e)), 
                                    (e = e.nodeName ? [ e ] : Array.isArray(e) ? e : [].slice.call(e)).forEach((function(e, n) {
                                        var i = r.default.extend(!0, {}, t.opts);
                                        if (function(e, t, n, i) {
                                            function a(t, a) {
                                                var r = "" === i ? t : i + "-" + t;
                                                null !== (a = void 0 !== a ? a : e.getAttribute(r)) && ("string" == typeof a && (0 === t.indexOf("on") ? a = l.default[a] : "false" === a ? a = !1 : "true" === a && (a = !0)), 
                                                n[t] = a);
                                            }
                                            if (!0 === t.importDataAttributes) {
                                                var o, s, c, u, f = e.getAttribute(i);
                                                if (f && "" !== f && (f = f.replace(/'/g, '"'), s = JSON.parse("{" + f + "}")), 
                                                s) for (u in c = void 0, s) if ("alias" === u.toLowerCase()) {
                                                    c = s[u];
                                                    break;
                                                }
                                                for (o in a("alias", c), n.alias && k(n.alias, n, t), t) {
                                                    if (s) for (u in c = void 0, s) if (u.toLowerCase() === o.toLowerCase()) {
                                                        c = s[u];
                                                        break;
                                                    }
                                                    a(o, c);
                                                }
                                            }
                                            r.default.extend(!0, t, n), ("rtl" === e.dir || t.rightAlign) && (e.style.textAlign = "right");
                                            ("rtl" === e.dir || t.numericInput) && (e.dir = "ltr", e.removeAttribute("dir"), 
                                            t.isRTL = !0);
                                            return Object.keys(n).length;
                                        }(e, i, r.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {
                                            var a = (0, u.generateMaskSet)(i, t.noMasksCache);
                                            void 0 !== a && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()), 
                                            e.inputmask = new y(void 0, void 0, !0), e.inputmask.opts = i, e.inputmask.noMasksCache = t.noMasksCache, 
                                            e.inputmask.userOptions = r.default.extend(!0, {}, t.userOptions), e.inputmask.el = e, 
                                            e.inputmask.$el = (0, r.default)(e), e.inputmask.maskset = a, r.default.data(e, g, t.userOptions), 
                                            c.mask.call(e.inputmask));
                                        }
                                    })), e && e[0] && e[0].inputmask || this;
                                },
                                option: function(e, t) {
                                    return "string" == typeof e ? this.opts[e] : "object" === h(e) ? (r.default.extend(this.userOptions, e), 
                                    this.el && !0 !== t && this.mask(this.el), this) : void 0;
                                },
                                unmaskedvalue: function(e) {
                                    if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), 
                                    void 0 === this.el || void 0 !== e) {
                                        var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                        s.checkVal.call(this, void 0, !1, !1, t), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, f.getBuffer.call(this), 0, this.opts);
                                    }
                                    return s.unmaskedvalue.call(this, this.el);
                                },
                                remove: function() {
                                    if (this.el) {
                                        r.default.data(this.el, g, null);
                                        var e = this.opts.autoUnmask ? (0, s.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                                        e !== f.getBufferTemplate.call(this).join("") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(""), 
                                        o.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                                            get: this.__valueGet,
                                            set: this.__valueSet,
                                            configurable: !0
                                        }) : m.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), 
                                        this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                                    }
                                    return this.el;
                                },
                                getemptymask: function() {
                                    return this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), 
                                    (this.isRTL ? f.getBufferTemplate.call(this).reverse() : f.getBufferTemplate.call(this)).join("");
                                },
                                hasMaskedValue: function() {
                                    return !this.opts.autoUnmask;
                                },
                                isComplete: function() {
                                    return this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), 
                                    p.isComplete.call(this, f.getBuffer.call(this));
                                },
                                getmetadata: function() {
                                    if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), 
                                    Array.isArray(this.maskset.metadata)) {
                                        var e = d.getMaskTemplate.call(this, !0, 0, !1).join("");
                                        return this.maskset.metadata.forEach((function(t) {
                                            return t.mask !== e || (e = t, !1);
                                        })), e;
                                    }
                                    return this.maskset.metadata;
                                },
                                isValid: function(e) {
                                    if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), 
                                    e) {
                                        var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                        s.checkVal.call(this, void 0, !0, !1, t);
                                    } else e = this.isRTL ? f.getBuffer.call(this).slice().reverse().join("") : f.getBuffer.call(this).join("");
                                    for (var n = f.getBuffer.call(this), i = f.determineLastRequiredPosition.call(this), a = n.length - 1; a > i && !f.isMask.call(this, a); a--) ;
                                    return n.splice(i, a + 1 - i), p.isComplete.call(this, n) && e === (this.isRTL ? f.getBuffer.call(this).slice().reverse().join("") : f.getBuffer.call(this).join(""));
                                },
                                format: function(e, t) {
                                    this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache);
                                    var n = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                    s.checkVal.call(this, void 0, !0, !1, n);
                                    var i = this.isRTL ? f.getBuffer.call(this).slice().reverse().join("") : f.getBuffer.call(this).join("");
                                    return t ? {
                                        value: i,
                                        metadata: this.getmetadata()
                                    } : i;
                                },
                                setValue: function(e) {
                                    this.el && (0, r.default)(this.el).trigger("setvalue", [ e ]);
                                },
                                analyseMask: u.analyseMask
                            }, y.extendDefaults = function(e) {
                                r.default.extend(!0, y.prototype.defaults, e);
                            }, y.extendDefinitions = function(e) {
                                r.default.extend(!0, y.prototype.definitions, e);
                            }, y.extendAliases = function(e) {
                                r.default.extend(!0, y.prototype.aliases, e);
                            }, y.format = function(e, t, n) {
                                return y(t).format(e, n);
                            }, y.unmask = function(e, t) {
                                return y(t).unmaskedvalue(e);
                            }, y.isValid = function(e, t) {
                                return y(t).isValid(e);
                            }, y.remove = function(e) {
                                "string" == typeof e && (e = m.getElementById(e) || m.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                                    e.inputmask && e.inputmask.remove();
                                }));
                            }, y.setValue = function(e, t) {
                                "string" == typeof e && (e = m.getElementById(e) || m.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                                    e.inputmask ? e.inputmask.setValue(t) : (0, r.default)(e).trigger("setvalue", [ t ]);
                                }));
                            }, y.dependencyLib = r.default, l.default.Inputmask = y;
                            t.default = y;
                        },
                        5296: function(e, t, n) {
                            function i(e) {
                                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, i(e);
                            }
                            var a = d(n(9380)), r = d(n(2394));
                            function o(e, t) {
                                for (var n = 0; n < t.length; n++) {
                                    var a = t[n];
                                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), 
                                    Object.defineProperty(e, (r = a.key, o = void 0, o = function(e, t) {
                                        if ("object" !== i(e) || null === e) return e;
                                        var n = e[Symbol.toPrimitive];
                                        if (void 0 !== n) {
                                            var a = n.call(e, t || "default");
                                            if ("object" !== i(a)) return a;
                                            throw new TypeError("@@toPrimitive must return a primitive value.");
                                        }
                                        return ("string" === t ? String : Number)(e);
                                    }(r, "string"), "symbol" === i(o) ? o : String(o)), a);
                                }
                                var r, o;
                            }
                            function l(e) {
                                var t = u();
                                return function() {
                                    var n, a = p(e);
                                    if (t) {
                                        var r = p(this).constructor;
                                        n = Reflect.construct(a, arguments, r);
                                    } else n = a.apply(this, arguments);
                                    return function(e, t) {
                                        if (t && ("object" === i(t) || "function" == typeof t)) return t;
                                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                                        return function(e) {
                                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                            return e;
                                        }(e);
                                    }(this, n);
                                };
                            }
                            function s(e) {
                                var t = "function" == typeof Map ? new Map : void 0;
                                return s = function(e) {
                                    if (null === e || !function(e) {
                                        try {
                                            return -1 !== Function.toString.call(e).indexOf("[native code]");
                                        } catch (t) {
                                            return "function" == typeof e;
                                        }
                                    }(e)) return e;
                                    if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                                    if (void 0 !== t) {
                                        if (t.has(e)) return t.get(e);
                                        t.set(e, n);
                                    }
                                    function n() {
                                        return c(e, arguments, p(this).constructor);
                                    }
                                    return n.prototype = Object.create(e.prototype, {
                                        constructor: {
                                            value: n,
                                            enumerable: !1,
                                            writable: !0,
                                            configurable: !0
                                        }
                                    }), f(n, e);
                                }, s(e);
                            }
                            function c(e, t, n) {
                                return c = u() ? Reflect.construct.bind() : function(e, t, n) {
                                    var i = [ null ];
                                    i.push.apply(i, t);
                                    var a = new (Function.bind.apply(e, i));
                                    return n && f(a, n.prototype), a;
                                }, c.apply(null, arguments);
                            }
                            function u() {
                                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                if (Reflect.construct.sham) return !1;
                                if ("function" == typeof Proxy) return !0;
                                try {
                                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                                    !0;
                                } catch (e) {
                                    return !1;
                                }
                            }
                            function f(e, t) {
                                return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                                    return e.__proto__ = t, e;
                                }, f(e, t);
                            }
                            function p(e) {
                                return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                                    return e.__proto__ || Object.getPrototypeOf(e);
                                }, p(e);
                            }
                            function d(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var h = a.default.document;
                            if (h && h.head && h.head.attachShadow && a.default.customElements && void 0 === a.default.customElements.get("input-mask")) {
                                var v = function(e) {
                                    !function(e, t) {
                                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                                        e.prototype = Object.create(t && t.prototype, {
                                            constructor: {
                                                value: e,
                                                writable: !0,
                                                configurable: !0
                                            }
                                        }), Object.defineProperty(e, "prototype", {
                                            writable: !1
                                        }), t && f(e, t);
                                    }(s, e);
                                    var t, n, i, a = l(s);
                                    function s() {
                                        var e;
                                        !function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                                        }(this, s);
                                        var t = (e = a.call(this)).getAttributeNames(), n = e.attachShadow({
                                            mode: "closed"
                                        });
                                        for (var i in e.input = h.createElement("input"), e.input.type = "text", n.appendChild(e.input), 
                                        t) Object.prototype.hasOwnProperty.call(t, i) && e.input.setAttribute(t[i], e.getAttribute(t[i]));
                                        var o = new r.default;
                                        return o.dataAttribute = "", o.mask(e.input), e.input.inputmask.shadowRoot = n, 
                                        e;
                                    }
                                    return t = s, (n = [ {
                                        key: "attributeChangedCallback",
                                        value: function(e, t, n) {
                                            this.input.setAttribute(e, n);
                                        }
                                    }, {
                                        key: "value",
                                        get: function() {
                                            return this.input.value;
                                        },
                                        set: function(e) {
                                            this.input.value = e;
                                        }
                                    } ]) && o(t.prototype, n), i && o(t, i), Object.defineProperty(t, "prototype", {
                                        writable: !1
                                    }), s;
                                }(s(HTMLElement));
                                a.default.customElements.define("input-mask", v);
                            }
                        },
                        2839: function(e, t) {
                            function n(e) {
                                return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, n(e);
                            }
                            function i(e, t) {
                                return function(e) {
                                    if (Array.isArray(e)) return e;
                                }(e) || function(e, t) {
                                    var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (null != n) {
                                        var i, a, r, o, l = [], s = !0, c = !1;
                                        try {
                                            if (r = (n = n.call(e)).next, 0 === t) {
                                                if (Object(n) !== n) return;
                                                s = !1;
                                            } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;
                                        } catch (e) {
                                            c = !0, a = e;
                                        } finally {
                                            try {
                                                if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;
                                            } finally {
                                                if (c) throw a;
                                            }
                                        }
                                        return l;
                                    }
                                }(e, t) || function(e, t) {
                                    if (!e) return;
                                    if ("string" == typeof e) return a(e, t);
                                    var n = Object.prototype.toString.call(e).slice(8, -1);
                                    "Object" === n && e.constructor && (n = e.constructor.name);
                                    if ("Map" === n || "Set" === n) return Array.from(e);
                                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return a(e, t);
                                }(e, t) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }();
                            }
                            function a(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                                return i;
                            }
                            function r(e, t) {
                                var n = Object.keys(e);
                                if (Object.getOwnPropertySymbols) {
                                    var i = Object.getOwnPropertySymbols(e);
                                    t && (i = i.filter((function(t) {
                                        return Object.getOwnPropertyDescriptor(e, t).enumerable;
                                    }))), n.push.apply(n, i);
                                }
                                return n;
                            }
                            function o(e, t, i) {
                                return (t = function(e) {
                                    var t = function(e, t) {
                                        if ("object" !== n(e) || null === e) return e;
                                        var i = e[Symbol.toPrimitive];
                                        if (void 0 !== i) {
                                            var a = i.call(e, t || "default");
                                            if ("object" !== n(a)) return a;
                                            throw new TypeError("@@toPrimitive must return a primitive value.");
                                        }
                                        return ("string" === t ? String : Number)(e);
                                    }(e, "string");
                                    return "symbol" === n(t) ? t : String(t);
                                }(t)) in e ? Object.defineProperty(e, t, {
                                    value: i,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : e[t] = i, e;
                            }
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.keys = t.keyCode = void 0, t.toKey = function(e, t) {
                                return s[e] || (t ? String.fromCharCode(e) : String.fromCharCode(e).toLowerCase());
                            }, t.toKeyCode = function(e) {
                                return l[e];
                            };
                            var l = t.keyCode = function(e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var n = null != arguments[t] ? arguments[t] : {};
                                    t % 2 ? r(Object(n), !0).forEach((function(t) {
                                        o(e, t, n[t]);
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r(Object(n)).forEach((function(t) {
                                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
                                    }));
                                }
                                return e;
                            }({
                                c: 67,
                                x: 88,
                                z: 90,
                                BACKSPACE_SAFARI: 127,
                                Enter: 13,
                                Meta_LEFT: 91,
                                Meta_RIGHT: 92,
                                Space: 32
                            }, {
                                Alt: 18,
                                AltGraph: 18,
                                ArrowDown: 40,
                                ArrowLeft: 37,
                                ArrowRight: 39,
                                ArrowUp: 38,
                                Backspace: 8,
                                CapsLock: 20,
                                Control: 17,
                                ContextMenu: 93,
                                Dead: 221,
                                Delete: 46,
                                End: 35,
                                Escape: 27,
                                F1: 112,
                                F2: 113,
                                F3: 114,
                                F4: 115,
                                F5: 116,
                                F6: 117,
                                F7: 118,
                                F8: 119,
                                F9: 120,
                                F10: 121,
                                F11: 122,
                                F12: 123,
                                Home: 36,
                                Insert: 45,
                                NumLock: 144,
                                PageDown: 34,
                                PageUp: 33,
                                Pause: 19,
                                PrintScreen: 44,
                                Process: 229,
                                Shift: 16,
                                ScrollLock: 145,
                                Tab: 9,
                                Unidentified: 229
                            }), s = Object.entries(l).reduce((function(e, t) {
                                var n = i(t, 2), a = n[0], r = n[1];
                                return e[r] = void 0 === e[r] ? a : e[r], e;
                            }), {});
                            t.keys = Object.entries(l).reduce((function(e, t) {
                                var n = i(t, 2), a = n[0];
                                n[1];
                                return e[a] = "Space" === a ? " " : a, e;
                            }), {});
                        },
                        2391: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.analyseMask = function(e, t, n) {
                                var i, a, s, c, u, f, p = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, h = !1, v = new o.default, m = [], g = [], y = !1;
                                function k(e, i, a) {
                                    a = void 0 !== a ? a : e.matches.length;
                                    var o = e.matches[a - 1];
                                    if (t) {
                                        if (0 === i.indexOf("[") || h && /\\d|\\s|\\w|\\p/i.test(i) || "." === i) {
                                            var s = n.casing ? "i" : "";
                                            /\\p\{.*}/i.test(i) && (s += "u"), e.matches.splice(a++, 0, {
                                                fn: new RegExp(i, s),
                                                static: !1,
                                                optionality: !1,
                                                newBlockMarker: void 0 === o ? "master" : o.def !== i,
                                                casing: null,
                                                def: i,
                                                placeholder: "object" === l(n.placeholder) ? n.placeholder[v.matches.length] : void 0,
                                                nativeDef: i
                                            });
                                        } else h && (i = i[i.length - 1]), i.split("").forEach((function(t, i) {
                                            o = e.matches[a - 1], e.matches.splice(a++, 0, {
                                                fn: /[a-z]/i.test(n.staticDefinitionSymbol || t) ? new RegExp("[" + (n.staticDefinitionSymbol || t) + "]", n.casing ? "i" : "") : null,
                                                static: !0,
                                                optionality: !1,
                                                newBlockMarker: void 0 === o ? "master" : o.def !== t && !0 !== o.static,
                                                casing: null,
                                                def: n.staticDefinitionSymbol || t,
                                                placeholder: void 0 !== n.staticDefinitionSymbol ? t : "object" === l(n.placeholder) ? n.placeholder[v.matches.length] : void 0,
                                                nativeDef: (h ? "'" : "") + t
                                            });
                                        }));
                                        h = !1;
                                    } else {
                                        var c = n.definitions && n.definitions[i] || n.usePrototypeDefinitions && r.default.prototype.definitions[i];
                                        c && !h ? e.matches.splice(a++, 0, {
                                            fn: c.validator ? "string" == typeof c.validator ? new RegExp(c.validator, n.casing ? "i" : "") : new function() {
                                                this.test = c.validator;
                                            } : /./,
                                            static: c.static || !1,
                                            optionality: c.optional || !1,
                                            defOptionality: c.optional || !1,
                                            newBlockMarker: void 0 === o || c.optional ? "master" : o.def !== (c.definitionSymbol || i),
                                            casing: c.casing,
                                            def: c.definitionSymbol || i,
                                            placeholder: c.placeholder,
                                            nativeDef: i,
                                            generated: c.generated
                                        }) : (e.matches.splice(a++, 0, {
                                            fn: /[a-z]/i.test(n.staticDefinitionSymbol || i) ? new RegExp("[" + (n.staticDefinitionSymbol || i) + "]", n.casing ? "i" : "") : null,
                                            static: !0,
                                            optionality: !1,
                                            newBlockMarker: void 0 === o ? "master" : o.def !== i && !0 !== o.static,
                                            casing: null,
                                            def: n.staticDefinitionSymbol || i,
                                            placeholder: void 0 !== n.staticDefinitionSymbol ? i : void 0,
                                            nativeDef: (h ? "'" : "") + i
                                        }), h = !1);
                                    }
                                }
                                function b() {
                                    if (m.length > 0) {
                                        if (k(c = m[m.length - 1], a), c.isAlternator) {
                                            u = m.pop();
                                            for (var e = 0; e < u.matches.length; e++) u.matches[e].isGroup && (u.matches[e].isGroup = !1);
                                            m.length > 0 ? (c = m[m.length - 1]).matches.push(u) : v.matches.push(u);
                                        }
                                    } else k(v, a);
                                }
                                function x(e) {
                                    var t = new o.default(!0);
                                    return t.openGroup = !1, t.matches = e, t;
                                }
                                function w() {
                                    if ((s = m.pop()).openGroup = !1, void 0 !== s) if (m.length > 0) {
                                        if ((c = m[m.length - 1]).matches.push(s), c.isAlternator) {
                                            u = m.pop();
                                            for (var e = 0; e < u.matches.length; e++) u.matches[e].isGroup = !1, u.matches[e].alternatorGroup = !1;
                                            m.length > 0 ? (c = m[m.length - 1]).matches.push(u) : v.matches.push(u);
                                        }
                                    } else v.matches.push(s); else b();
                                }
                                function P(e) {
                                    var t = e.pop();
                                    return t.isQuantifier && (t = x([ e.pop(), t ])), t;
                                }
                                t && (n.optionalmarker[0] = void 0, n.optionalmarker[1] = void 0);
                                for (;i = t ? d.exec(e) : p.exec(e); ) {
                                    if (a = i[0], t) {
                                        switch (a.charAt(0)) {
                                          case "?":
                                            a = "{0,1}";
                                            break;

                                          case "+":
                                          case "*":
                                            a = "{" + a + "}";
                                            break;

                                          case "|":
                                            if (0 === m.length) {
                                                var S = x(v.matches);
                                                S.openGroup = !0, m.push(S), v.matches = [], y = !0;
                                            }
                                        }
                                        switch (a) {
                                          case "\\d":
                                            a = "[0-9]";
                                            break;

                                          case "\\p":
                                            a += d.exec(e)[0], a += d.exec(e)[0];
                                        }
                                    }
                                    if (h) b(); else switch (a.charAt(0)) {
                                      case "$":
                                      case "^":
                                        t || b();
                                        break;

                                      case n.escapeChar:
                                        h = !0, t && b();
                                        break;

                                      case n.optionalmarker[1]:
                                      case n.groupmarker[1]:
                                        w();
                                        break;

                                      case n.optionalmarker[0]:
                                        m.push(new o.default(!1, !0));
                                        break;

                                      case n.groupmarker[0]:
                                        m.push(new o.default(!0));
                                        break;

                                      case n.quantifiermarker[0]:
                                        var O = new o.default(!1, !1, !0), _ = (a = a.replace(/[{}?]/g, "")).split("|"), M = _[0].split(","), E = isNaN(M[0]) ? M[0] : parseInt(M[0]), j = 1 === M.length ? E : isNaN(M[1]) ? M[1] : parseInt(M[1]), T = isNaN(_[1]) ? _[1] : parseInt(_[1]);
                                        "*" !== E && "+" !== E || (E = "*" === j ? 0 : 1), O.quantifier = {
                                            min: E,
                                            max: j,
                                            jit: T
                                        };
                                        var A = m.length > 0 ? m[m.length - 1].matches : v.matches;
                                        (i = A.pop()).isGroup || (i = x([ i ])), A.push(i), A.push(O);
                                        break;

                                      case n.alternatormarker:
                                        if (m.length > 0) {
                                            var D = (c = m[m.length - 1]).matches[c.matches.length - 1];
                                            f = c.openGroup && (void 0 === D.matches || !1 === D.isGroup && !1 === D.isAlternator) ? m.pop() : P(c.matches);
                                        } else f = P(v.matches);
                                        if (f.isAlternator) m.push(f); else if (f.alternatorGroup ? (u = m.pop(), f.alternatorGroup = !1) : u = new o.default(!1, !1, !1, !0), 
                                        u.matches.push(f), m.push(u), f.openGroup) {
                                            f.openGroup = !1;
                                            var L = new o.default(!0);
                                            L.alternatorGroup = !0, m.push(L);
                                        }
                                        break;

                                      default:
                                        b();
                                    }
                                }
                                y && w();
                                for (;m.length > 0; ) s = m.pop(), v.matches.push(s);
                                v.matches.length > 0 && (!function e(i) {
                                    i && i.matches && i.matches.forEach((function(a, r) {
                                        var o = i.matches[r + 1];
                                        (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && a && a.isGroup && (a.isGroup = !1, 
                                        t || (k(a, n.groupmarker[0], 0), !0 !== a.openGroup && k(a, n.groupmarker[1]))), 
                                        e(a);
                                    }));
                                }(v), g.push(v));
                                (n.numericInput || n.isRTL) && function e(t) {
                                    for (var i in t.matches = t.matches.reverse(), t.matches) if (Object.prototype.hasOwnProperty.call(t.matches, i)) {
                                        var a = parseInt(i);
                                        if (t.matches[i].isQuantifier && t.matches[a + 1] && t.matches[a + 1].isGroup) {
                                            var r = t.matches[i];
                                            t.matches.splice(i, 1), t.matches.splice(a + 1, 0, r);
                                        }
                                        void 0 !== t.matches[i].matches ? t.matches[i] = e(t.matches[i]) : t.matches[i] = ((o = t.matches[i]) === n.optionalmarker[0] ? o = n.optionalmarker[1] : o === n.optionalmarker[1] ? o = n.optionalmarker[0] : o === n.groupmarker[0] ? o = n.groupmarker[1] : o === n.groupmarker[1] && (o = n.groupmarker[0]), 
                                        o);
                                    }
                                    var o;
                                    return t;
                                }(g[0]);
                                return g;
                            }, t.generateMaskSet = function(e, t) {
                                var n;
                                function o(e, t) {
                                    var n = t.repeat, i = t.groupmarker, r = t.quantifiermarker, o = t.keepStatic;
                                    if (n > 0 || "*" === n || "+" === n) {
                                        var l = "*" === n ? 0 : "+" === n ? 1 : n;
                                        if (l != n) e = i[0] + e + i[1] + r[0] + l + "," + n + r[1]; else for (var c = e, u = 1; u < l; u++) e += c;
                                    }
                                    if (!0 === o) {
                                        var f = e.match(new RegExp("(.)\\[([^\\]]*)\\]", "g"));
                                        f && f.forEach((function(t, n) {
                                            var i = function(e, t) {
                                                return function(e) {
                                                    if (Array.isArray(e)) return e;
                                                }(e) || function(e, t) {
                                                    var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                                    if (null != n) {
                                                        var i, a, r, o, l = [], s = !0, c = !1;
                                                        try {
                                                            if (r = (n = n.call(e)).next, 0 === t) {
                                                                if (Object(n) !== n) return;
                                                                s = !1;
                                                            } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;
                                                        } catch (e) {
                                                            c = !0, a = e;
                                                        } finally {
                                                            try {
                                                                if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;
                                                            } finally {
                                                                if (c) throw a;
                                                            }
                                                        }
                                                        return l;
                                                    }
                                                }(e, t) || function(e, t) {
                                                    if (!e) return;
                                                    if ("string" == typeof e) return s(e, t);
                                                    var n = Object.prototype.toString.call(e).slice(8, -1);
                                                    "Object" === n && e.constructor && (n = e.constructor.name);
                                                    if ("Map" === n || "Set" === n) return Array.from(e);
                                                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(e, t);
                                                }(e, t) || function() {
                                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                                }();
                                            }(t.split("["), 2), r = i[0], o = i[1];
                                            o = o.replace("]", ""), e = e.replace(new RegExp("".concat((0, a.default)(r), "\\[").concat((0, 
                                            a.default)(o), "\\]")), r.charAt(0) === o.charAt(0) ? "(".concat(r, "|").concat(r).concat(o, ")") : "".concat(r, "[").concat(o, "]"));
                                        }));
                                    }
                                    return e;
                                }
                                function c(e, n, a) {
                                    var s, c, u = !1;
                                    return null !== e && "" !== e || ((u = null !== a.regex) ? e = (e = a.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (u = !0, 
                                    e = ".*")), 1 === e.length && !1 === a.greedy && 0 !== a.repeat && (a.placeholder = ""), 
                                    e = o(e, a), c = u ? "regex_" + a.regex : a.numericInput ? e.split("").reverse().join("") : e, 
                                    null !== a.keepStatic && (c = "ks_" + a.keepStatic + c), "object" === l(a.placeholder) && (c = "ph_" + JSON.stringify(a.placeholder) + c), 
                                    void 0 === r.default.prototype.masksCache[c] || !0 === t ? (s = {
                                        mask: e,
                                        maskToken: r.default.prototype.analyseMask(e, u, a),
                                        validPositions: [],
                                        _buffer: void 0,
                                        buffer: void 0,
                                        tests: {},
                                        excludes: {},
                                        metadata: n,
                                        maskLength: void 0,
                                        jitOffset: {}
                                    }, !0 !== t && (r.default.prototype.masksCache[c] = s, s = i.default.extend(!0, {}, r.default.prototype.masksCache[c]))) : s = i.default.extend(!0, {}, r.default.prototype.masksCache[c]), 
                                    s;
                                }
                                "function" == typeof e.mask && (e.mask = e.mask(e));
                                if (Array.isArray(e.mask)) {
                                    if (e.mask.length > 1) {
                                        null === e.keepStatic && (e.keepStatic = !0);
                                        var u = e.groupmarker[0];
                                        return (e.isRTL ? e.mask.reverse() : e.mask).forEach((function(t) {
                                            u.length > 1 && (u += e.alternatormarker), void 0 !== t.mask && "function" != typeof t.mask ? u += t.mask : u += t;
                                        })), c(u += e.groupmarker[1], e.mask, e);
                                    }
                                    e.mask = e.mask.pop();
                                }
                                n = e.mask && void 0 !== e.mask.mask && "function" != typeof e.mask.mask ? c(e.mask.mask, e.mask, e) : c(e.mask, e.mask, e);
                                null === e.keepStatic && (e.keepStatic = !1);
                                return n;
                            };
                            var i = c(n(4963)), a = c(n(7184)), r = c(n(2394)), o = c(n(9695));
                            function l(e) {
                                return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, l(e);
                            }
                            function s(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                                return i;
                            }
                            function c(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                        },
                        157: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.mask = function() {
                                var e = this, t = this.opts, n = this.el, c = this.dependencyLib;
                                r.EventRuler.off(n);
                                var u = function(t, n) {
                                    var i = t.getAttribute("type"), a = "input" === t.tagName.toLowerCase() && n.supportsInputType.includes(i) || t.isContentEditable || "textarea" === t.tagName.toLowerCase();
                                    if (!a) if ("input" === t.tagName.toLowerCase()) {
                                        var s = document.createElement("input");
                                        s.setAttribute("type", i), a = "text" === s.type, s = null;
                                    } else a = "partial";
                                    return !1 !== a ? function(t) {
                                        var i, a;
                                        function s() {
                                            return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== l.getLastValidPosition.call(e) || !0 !== n.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && n.clearMaskOnLostFocus ? (e.isRTL ? o.clearOptionalTail.call(e, l.getBuffer.call(e).slice()).reverse() : o.clearOptionalTail.call(e, l.getBuffer.call(e).slice())).join("") : i.call(this) : "" : i.call(this);
                                        }
                                        function u(e) {
                                            a.call(this, e), this.inputmask && (0, o.applyInputValue)(this, e);
                                        }
                                        if (!t.inputmask.__valueGet) {
                                            if (!0 !== n.noValuePatching) {
                                                if (Object.getOwnPropertyDescriptor) {
                                                    var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), "value") : void 0;
                                                    f && f.get && f.set ? (i = f.get, a = f.set, Object.defineProperty(t, "value", {
                                                        get: s,
                                                        set: u,
                                                        configurable: !0
                                                    })) : "input" !== t.tagName.toLowerCase() && (i = function() {
                                                        return this.textContent;
                                                    }, a = function(e) {
                                                        this.textContent = e;
                                                    }, Object.defineProperty(t, "value", {
                                                        get: s,
                                                        set: u,
                                                        configurable: !0
                                                    }));
                                                } else document.__lookupGetter__ && t.__lookupGetter__("value") && (i = t.__lookupGetter__("value"), 
                                                a = t.__lookupSetter__("value"), t.__defineGetter__("value", s), t.__defineSetter__("value", u));
                                                t.inputmask.__valueGet = i, t.inputmask.__valueSet = a;
                                            }
                                            t.inputmask._valueGet = function(t) {
                                                return e.isRTL && !0 !== t ? i.call(this.el).split("").reverse().join("") : i.call(this.el);
                                            }, t.inputmask._valueSet = function(t, n) {
                                                a.call(this.el, null == t ? "" : !0 !== n && e.isRTL ? t.split("").reverse().join("") : t);
                                            }, void 0 === i && (i = function() {
                                                return this.value;
                                            }, a = function(e) {
                                                this.value = e;
                                            }, function(t) {
                                                if (c.valHooks && (void 0 === c.valHooks[t] || !0 !== c.valHooks[t].inputmaskpatch)) {
                                                    var i = c.valHooks[t] && c.valHooks[t].get ? c.valHooks[t].get : function(e) {
                                                        return e.value;
                                                    }, a = c.valHooks[t] && c.valHooks[t].set ? c.valHooks[t].set : function(e, t) {
                                                        return e.value = t, e;
                                                    };
                                                    c.valHooks[t] = {
                                                        get: function(t) {
                                                            if (t.inputmask) {
                                                                if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();
                                                                var a = i(t);
                                                                return -1 !== l.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== n.nullable ? a : "";
                                                            }
                                                            return i(t);
                                                        },
                                                        set: function(e, t) {
                                                            var n = a(e, t);
                                                            return e.inputmask && (0, o.applyInputValue)(e, t), n;
                                                        },
                                                        inputmaskpatch: !0
                                                    };
                                                }
                                            }(t.type), function(e) {
                                                r.EventRuler.on(e, "mouseenter", (function() {
                                                    var e = this, t = e.inputmask._valueGet(!0);
                                                    t != (e.inputmask.isRTL ? l.getBuffer.call(e.inputmask).slice().reverse() : l.getBuffer.call(e.inputmask)).join("") && (0, 
                                                    o.applyInputValue)(e, t);
                                                }));
                                            }(t));
                                        }
                                    }(t) : t.inputmask = void 0, a;
                                }(n, t);
                                if (!1 !== u) {
                                    e.originalPlaceholder = n.placeholder, e.maxLength = void 0 !== n ? n.maxLength : void 0, 
                                    -1 === e.maxLength && (e.maxLength = void 0), "inputMode" in n && null === n.getAttribute("inputmode") && (n.inputMode = t.inputmode, 
                                    n.setAttribute("inputmode", t.inputmode)), !0 === u && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === [ "cc-number", "cc-exp" ].indexOf(n.autocomplete), 
                                    i.iphone && (t.insertModeVisual = !1, n.setAttribute("autocorrect", "off")), r.EventRuler.on(n, "submit", a.EventHandlers.submitEvent), 
                                    r.EventRuler.on(n, "reset", a.EventHandlers.resetEvent), r.EventRuler.on(n, "blur", a.EventHandlers.blurEvent), 
                                    r.EventRuler.on(n, "focus", a.EventHandlers.focusEvent), r.EventRuler.on(n, "invalid", a.EventHandlers.invalidEvent), 
                                    r.EventRuler.on(n, "click", a.EventHandlers.clickEvent), r.EventRuler.on(n, "mouseleave", a.EventHandlers.mouseleaveEvent), 
                                    r.EventRuler.on(n, "mouseenter", a.EventHandlers.mouseenterEvent), r.EventRuler.on(n, "paste", a.EventHandlers.pasteEvent), 
                                    r.EventRuler.on(n, "cut", a.EventHandlers.cutEvent), r.EventRuler.on(n, "complete", t.oncomplete), 
                                    r.EventRuler.on(n, "incomplete", t.onincomplete), r.EventRuler.on(n, "cleared", t.oncleared), 
                                    !0 !== t.inputEventOnly && r.EventRuler.on(n, "keydown", a.EventHandlers.keyEvent), 
                                    (i.mobile || t.inputEventOnly) && n.removeAttribute("maxLength"), r.EventRuler.on(n, "input", a.EventHandlers.inputFallBackEvent)), 
                                    r.EventRuler.on(n, "setvalue", a.EventHandlers.setValueEvent), void 0 === e.applyMaskHook || e.applyMaskHook(), 
                                    l.getBufferTemplate.call(e).join(""), e.undoValue = e._valueGet(!0);
                                    var f = (n.inputmask.shadowRoot || n.ownerDocument).activeElement;
                                    if ("" !== n.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || f === n) {
                                        (0, o.applyInputValue)(n, n.inputmask._valueGet(!0), t);
                                        var p = l.getBuffer.call(e).slice();
                                        !1 === s.isComplete.call(e, p) && t.clearIncomplete && l.resetMaskSet.call(e, !1), 
                                        t.clearMaskOnLostFocus && f !== n && (-1 === l.getLastValidPosition.call(e) ? p = [] : o.clearOptionalTail.call(e, p)), 
                                        (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && f === n || "" !== n.inputmask._valueGet(!0)) && (0, 
                                        o.writeBuffer)(n, p), f === n && l.caret.call(e, n, l.seekNext.call(e, l.getLastValidPosition.call(e)));
                                    }
                                }
                            };
                            var i = n(9845), a = n(6030), r = n(9716), o = n(7760), l = n(8711), s = n(7215);
                        },
                        9695: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e, t, n, i) {
                                this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, 
                                this.isOptional = t || !1, this.isQuantifier = n || !1, this.isAlternator = i || !1, 
                                this.quantifier = {
                                    min: 1,
                                    max: 1
                                };
                            };
                        },
                        3194: function() {
                            Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                                value: function(e, t) {
                                    if (null == this) throw new TypeError('"this" is null or not defined');
                                    var n = Object(this), i = n.length >>> 0;
                                    if (0 === i) return !1;
                                    for (var a = 0 | t, r = Math.max(a >= 0 ? a : i - Math.abs(a), 0); r < i; ) {
                                        if (n[r] === e) return !0;
                                        r++;
                                    }
                                    return !1;
                                }
                            });
                        },
                        9302: function() {
                            var e = Function.bind.call(Function.call, Array.prototype.reduce), t = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable), n = Function.bind.call(Function.call, Array.prototype.concat), i = Object.keys;
                            Object.entries || (Object.entries = function(a) {
                                return e(i(a), (function(e, i) {
                                    return n(e, "string" == typeof i && t(a, i) ? [ [ i, a[i] ] ] : []);
                                }), []);
                            });
                        },
                        7149: function() {
                            function e(t) {
                                return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, e(t);
                            }
                            "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e("test".__proto__) ? function(e) {
                                return e.__proto__;
                            } : function(e) {
                                return e.constructor.prototype;
                            });
                        },
                        4013: function() {
                            String.prototype.includes || (String.prototype.includes = function(e, t) {
                                return "number" != typeof t && (t = 0), !(t + e.length > this.length) && -1 !== this.indexOf(e, t);
                            });
                        },
                        8711: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.caret = function(e, t, n, i, r) {
                                var o, l = this, s = this.opts;
                                if (void 0 === t) return "selectionStart" in e && "selectionEnd" in e ? (t = e.selectionStart, 
                                n = e.selectionEnd) : a.default.getSelection ? (o = a.default.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && o.commonAncestorContainer !== e || (t = o.startOffset, 
                                n = o.endOffset) : document.selection && document.selection.createRange && (n = (t = 0 - (o = document.selection.createRange()).duplicate().moveStart("character", -e.inputmask._valueGet().length)) + o.text.length), 
                                {
                                    begin: i ? t : f.call(l, t),
                                    end: i ? n : f.call(l, n)
                                };
                                if (Array.isArray(t) && (n = l.isRTL ? t[0] : t[1], t = l.isRTL ? t[1] : t[0]), 
                                void 0 !== t.begin && (n = l.isRTL ? t.begin : t.end, t = l.isRTL ? t.end : t.begin), 
                                "number" == typeof t) {
                                    t = i ? t : f.call(l, t), n = "number" == typeof (n = i ? n : f.call(l, n)) ? n : t;
                                    var c = parseInt(((e.ownerDocument.defaultView || a.default).getComputedStyle ? (e.ownerDocument.defaultView || a.default).getComputedStyle(e, null) : e.currentStyle).fontSize) * n;
                                    if (e.scrollLeft = c > e.scrollWidth ? c : 0, e.inputmask.caretPos = {
                                        begin: t,
                                        end: n
                                    }, s.insertModeVisual && !1 === s.insertMode && t === n && (r || n++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) {
                                        if ("setSelectionRange" in e) e.setSelectionRange(t, n); else if (a.default.getSelection) {
                                            if (o = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {
                                                var u = document.createTextNode("");
                                                e.appendChild(u);
                                            }
                                            o.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), 
                                            o.setEnd(e.firstChild, n < e.inputmask._valueGet().length ? n : e.inputmask._valueGet().length), 
                                            o.collapse(!0);
                                            var p = a.default.getSelection();
                                            p.removeAllRanges(), p.addRange(o);
                                        } else e.createTextRange && ((o = e.createTextRange()).collapse(!0), o.moveEnd("character", n), 
                                        o.moveStart("character", t), o.select());
                                        void 0 === e.inputmask.caretHook || e.inputmask.caretHook.call(l, {
                                            begin: t,
                                            end: n
                                        });
                                    }
                                }
                            }, t.determineLastRequiredPosition = function(e) {
                                var t, n, i = this, a = i.maskset, l = i.dependencyLib, c = s.call(i), u = {}, f = a.validPositions[c], p = o.getMaskTemplate.call(i, !0, s.call(i), !0, !0), d = p.length, h = void 0 !== f ? f.locator.slice() : void 0;
                                for (t = c + 1; t < p.length; t++) h = (n = o.getTestTemplate.call(i, t, h, t - 1)).locator.slice(), 
                                u[t] = l.extend(!0, {}, n);
                                var v = f && void 0 !== f.alternation ? f.locator[f.alternation] : void 0;
                                for (t = d - 1; t > c && ((n = u[t]).match.optionality || n.match.optionalQuantifier && n.match.newBlockMarker || v && (v !== u[t].locator[f.alternation] && !0 !== n.match.static || !0 === n.match.static && n.locator[f.alternation] && r.checkAlternationMatch.call(i, n.locator[f.alternation].toString().split(","), v.toString().split(",")) && "" !== o.getTests.call(i, t)[0].def)) && p[t] === o.getPlaceholder.call(i, t, n.match); t--) d--;
                                return e ? {
                                    l: d,
                                    def: u[d] ? u[d].match : void 0
                                } : d;
                            }, t.determineNewCaretPosition = function(e, t, n) {
                                var i, a, r, f = this, p = f.maskset, d = f.opts;
                                t && (f.isRTL ? e.end = e.begin : e.begin = e.end);
                                if (e.begin === e.end) {
                                    switch (n = n || d.positionCaretOnClick) {
                                      case "none":
                                        break;

                                      case "select":
                                        e = {
                                            begin: 0,
                                            end: l.call(f).length
                                        };
                                        break;

                                      case "ignore":
                                        e.end = e.begin = u.call(f, s.call(f));
                                        break;

                                      case "radixFocus":
                                        if (f.clicked > 1 && 0 === p.validPositions.length) break;
                                        if (function(e) {
                                            if ("" !== d.radixPoint && 0 !== d.digits) {
                                                var t = p.validPositions;
                                                if (void 0 === t[e] || void 0 === t[e].input) {
                                                    if (e < u.call(f, -1)) return !0;
                                                    var n = l.call(f).indexOf(d.radixPoint);
                                                    if (-1 !== n) {
                                                        for (var i = 0, a = t.length; i < a; i++) if (t[i] && n < i && t[i].input !== o.getPlaceholder.call(f, i)) return !1;
                                                        return !0;
                                                    }
                                                }
                                            }
                                            return !1;
                                        }(e.begin)) {
                                            var h = l.call(f).join("").indexOf(d.radixPoint);
                                            e.end = e.begin = d.numericInput ? u.call(f, h) : h;
                                            break;
                                        }

                                      default:
                                        if (i = e.begin, a = s.call(f, i, !0), i <= (r = u.call(f, -1 !== a || c.call(f, 0) ? a : -1))) e.end = e.begin = c.call(f, i, !1, !0) ? i : u.call(f, i); else {
                                            var v = p.validPositions[a], m = o.getTestTemplate.call(f, r, v ? v.match.locator : void 0, v), g = o.getPlaceholder.call(f, r, m.match);
                                            if ("" !== g && l.call(f)[r] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !c.call(f, r, d.keepStatic, !0) && m.match.def === g) {
                                                var y = u.call(f, r);
                                                (i >= y || i === r) && (r = y);
                                            }
                                            e.end = e.begin = r;
                                        }
                                    }
                                    return e;
                                }
                            }, t.getBuffer = l, t.getBufferTemplate = function() {
                                var e = this.maskset;
                                void 0 === e._buffer && (e._buffer = o.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));
                                return e._buffer;
                            }, t.getLastValidPosition = s, t.isMask = c, t.resetMaskSet = function(e) {
                                var t = this.maskset;
                                t.buffer = void 0, !0 !== e && (t.validPositions = [], t.p = 0);
                                !1 === e && (t.tests = {}, t.jitOffset = {});
                            }, t.seekNext = u, t.seekPrevious = function(e, t) {
                                var n = this, i = e - 1;
                                if (e <= 0) return 0;
                                for (;i > 0 && (!0 === t && (!0 !== o.getTest.call(n, i).match.newBlockMarker || !c.call(n, i, void 0, !0)) || !0 !== t && !c.call(n, i, void 0, !0)); ) i--;
                                return i;
                            }, t.translatePosition = f;
                            var i, a = (i = n(9380)) && i.__esModule ? i : {
                                default: i
                            }, r = n(7215), o = n(4713);
                            function l(e) {
                                var t = this, n = t.maskset;
                                return void 0 !== n.buffer && !0 !== e || (n.buffer = o.getMaskTemplate.call(t, !0, s.call(t), !0), 
                                void 0 === n._buffer && (n._buffer = n.buffer.slice())), n.buffer;
                            }
                            function s(e, t, n) {
                                var i = this.maskset, a = -1, r = -1, o = n || i.validPositions;
                                void 0 === e && (e = -1);
                                for (var l = 0, s = o.length; l < s; l++) o[l] && (t || !0 !== o[l].generatedInput) && (l <= e && (a = l), 
                                l >= e && (r = l));
                                return -1 === a || a === e ? r : -1 === r || e - a < r - e ? a : r;
                            }
                            function c(e, t, n) {
                                var i = this, a = this.maskset, r = o.getTestTemplate.call(i, e).match;
                                if ("" === r.def && (r = o.getTest.call(i, e).match), !0 !== r.static) return r.fn;
                                if (!0 === n && void 0 !== a.validPositions[e] && !0 !== a.validPositions[e].generatedInput) return !0;
                                if (!0 !== t && e > -1) {
                                    if (n) {
                                        var l = o.getTests.call(i, e);
                                        return l.length > 1 + ("" === l[l.length - 1].match.def ? 1 : 0);
                                    }
                                    var s = o.determineTestTemplate.call(i, e, o.getTests.call(i, e)), c = o.getPlaceholder.call(i, e, s.match);
                                    return s.match.def !== c;
                                }
                                return !1;
                            }
                            function u(e, t, n) {
                                var i = this;
                                void 0 === n && (n = !0);
                                for (var a = e + 1; "" !== o.getTest.call(i, a).match.def && (!0 === t && (!0 !== o.getTest.call(i, a).match.newBlockMarker || !c.call(i, a, void 0, !0)) || !0 !== t && !c.call(i, a, void 0, n)); ) a++;
                                return a;
                            }
                            function f(e) {
                                var t = this.opts, n = this.el;
                                return !this.isRTL || "number" != typeof e || t.greedy && "" === t.placeholder || !n || (e = this._valueGet().length - e) < 0 && (e = 0), 
                                e;
                            }
                        },
                        4713: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.determineTestTemplate = f, t.getDecisionTaker = s, t.getMaskTemplate = function(e, t, n, i, a) {
                                var r = this, o = this.opts, l = this.maskset, s = o.greedy;
                                a && o.greedy && (o.greedy = !1, r.maskset.tests = {});
                                t = t || 0;
                                var p, d, v, m, g = [], y = 0;
                                do {
                                    if (!0 === e && l.validPositions[y]) d = (v = a && l.validPositions[y].match.optionality && void 0 === l.validPositions[y + 1] && (!0 === l.validPositions[y].generatedInput || l.validPositions[y].input == o.skipOptionalPartCharacter && y > 0) ? f.call(r, y, h.call(r, y, p, y - 1)) : l.validPositions[y]).match, 
                                    p = v.locator.slice(), g.push(!0 === n ? v.input : !1 === n ? d.nativeDef : c.call(r, y, d)); else {
                                        d = (v = u.call(r, y, p, y - 1)).match, p = v.locator.slice();
                                        var k = !0 !== i && (!1 !== o.jitMasking ? o.jitMasking : d.jit);
                                        (m = (m || l.validPositions[y - 1]) && d.static && d.def !== o.groupSeparator && null === d.fn) || !1 === k || void 0 === k || "number" == typeof k && isFinite(k) && k > y ? g.push(!1 === n ? d.nativeDef : c.call(r, g.length, d)) : m = !1;
                                    }
                                    y++;
                                } while (!0 !== d.static || "" !== d.def || t > y);
                                "" === g[g.length - 1] && g.pop();
                                !1 === n && void 0 !== l.maskLength || (l.maskLength = y - 1);
                                return o.greedy = s, g;
                            }, t.getPlaceholder = c, t.getTest = p, t.getTestTemplate = u, t.getTests = h, t.isSubsetOf = d;
                            var i, a = (i = n(2394)) && i.__esModule ? i : {
                                default: i
                            }, r = n(8711);
                            function o(e) {
                                return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, o(e);
                            }
                            function l(e, t) {
                                var n = (null != e.alternation ? e.mloc[s(e)] : e.locator).join("");
                                if ("" !== n) for (n = n.split(":")[0]; n.length < t; ) n += "0";
                                return n;
                            }
                            function s(e) {
                                var t = e.locator[e.alternation];
                                return "string" == typeof t && t.length > 0 && (t = t.split(",")[0]), void 0 !== t ? t.toString() : "";
                            }
                            function c(e, t, n) {
                                var i = this, a = this.opts, l = this.maskset;
                                if (void 0 !== (t = t || p.call(i, e).match).placeholder || !0 === n) {
                                    if ("" !== t.placeholder && !0 === t.static && !0 !== t.generated) {
                                        var s = r.getLastValidPosition.call(i, e), c = r.seekNext.call(i, s);
                                        return (n ? e <= c : e < c) ? a.staticDefinitionSymbol && t.static ? t.nativeDef : t.def : "function" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;
                                    }
                                    return "function" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;
                                }
                                if (!0 === t.static) {
                                    if (e > -1 && void 0 === l.validPositions[e]) {
                                        var u, f = h.call(i, e), d = [];
                                        if ("string" == typeof a.placeholder && f.length > 1 + ("" === f[f.length - 1].match.def ? 1 : 0)) for (var v = 0; v < f.length; v++) if ("" !== f[v].match.def && !0 !== f[v].match.optionality && !0 !== f[v].match.optionalQuantifier && (!0 === f[v].match.static || void 0 === u || !1 !== f[v].match.fn.test(u.match.def, l, e, !0, a)) && (d.push(f[v]), 
                                        !0 === f[v].match.static && (u = f[v]), d.length > 1 && /[0-9a-bA-Z]/.test(d[0].match.def))) return a.placeholder.charAt(e % a.placeholder.length);
                                    }
                                    return t.def;
                                }
                                return "object" === o(a.placeholder) ? t.def : a.placeholder.charAt(e % a.placeholder.length);
                            }
                            function u(e, t, n) {
                                return this.maskset.validPositions[e] || f.call(this, e, h.call(this, e, t ? t.slice() : t, n));
                            }
                            function f(e, t) {
                                var n = this.opts, i = 0, a = function(e, t) {
                                    var n = 0, i = !1;
                                    t.forEach((function(e) {
                                        e.match.optionality && (0 !== n && n !== e.match.optionality && (i = !0), (0 === n || n > e.match.optionality) && (n = e.match.optionality));
                                    })), n && (0 == e || 1 == t.length ? n = 0 : i || (n = 0));
                                    return n;
                                }(e, t);
                                e = e > 0 ? e - 1 : 0;
                                var r, o, s, c = l(p.call(this, e));
                                n.greedy && t.length > 1 && "" === t[t.length - 1].match.def && (i = 1);
                                for (var u = 0; u < t.length - i; u++) {
                                    var f = t[u];
                                    r = l(f, c.length);
                                    var d = Math.abs(r - c);
                                    (!0 !== f.unMatchedAlternationStopped || t.filter((function(e) {
                                        return !0 !== e.unMatchedAlternationStopped;
                                    })).length <= 1) && (void 0 === o || "" !== r && d < o || s && !n.greedy && s.match.optionality && s.match.optionality - a > 0 && "master" === s.match.newBlockMarker && (!f.match.optionality || f.match.optionality - a < 1 || !f.match.newBlockMarker) || s && !n.greedy && s.match.optionalQuantifier && !f.match.optionalQuantifier) && (o = d, 
                                    s = f);
                                }
                                return s;
                            }
                            function p(e, t) {
                                var n = this.maskset;
                                return n.validPositions[e] ? n.validPositions[e] : (t || h.call(this, e))[0];
                            }
                            function d(e, t, n) {
                                function i(e) {
                                    for (var t, n = [], i = -1, a = 0, r = e.length; a < r; a++) if ("-" === e.charAt(a)) for (t = e.charCodeAt(a + 1); ++i < t; ) n.push(String.fromCharCode(i)); else i = e.charCodeAt(a), 
                                    n.push(e.charAt(a));
                                    return n.join("");
                                }
                                return e.match.def === t.match.nativeDef || !(!(n.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && ("." === t.match.fn.source || -1 !== i(t.match.fn.source.replace(/[[\]/]/g, "")).indexOf(i(e.match.fn.source.replace(/[[\]/]/g, ""))));
                            }
                            function h(e, t, n) {
                                var i, r, o = this, l = this.dependencyLib, s = this.maskset, c = this.opts, u = this.el, p = s.maskToken, h = t ? n : 0, v = t ? t.slice() : [ 0 ], m = [], g = !1, y = t ? t.join("") : "", k = !1;
                                function b(t, n, r, l) {
                                    function f(r, l, p) {
                                        function v(e, t) {
                                            var n = 0 === t.matches.indexOf(e);
                                            return n || t.matches.every((function(i, a) {
                                                return !0 === i.isQuantifier ? n = v(e, t.matches[a - 1]) : Object.prototype.hasOwnProperty.call(i, "matches") && (n = v(e, i)), 
                                                !n;
                                            })), n;
                                        }
                                        function w(e, t, n) {
                                            var i, a;
                                            if ((s.tests[e] || s.validPositions[e]) && (s.validPositions[e] ? [ s.validPositions[e] ] : s.tests[e]).every((function(e, r) {
                                                if (e.mloc[t]) return i = e, !1;
                                                var o = void 0 !== n ? n : e.alternation, l = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;
                                                return (void 0 === a || l < a) && -1 !== l && (i = e, a = l), !0;
                                            })), i) {
                                                var r = i.locator[i.alternation], o = i.mloc[t] || i.mloc[r] || i.locator;
                                                if (-1 !== o[o.length - 1].toString().indexOf(":")) o.pop();
                                                return o.slice((void 0 !== n ? n : i.alternation) + 1);
                                            }
                                            return void 0 !== n ? w(e, t) : void 0;
                                        }
                                        function P(t, n) {
                                            return !0 === t.match.static && !0 !== n.match.static && n.match.fn.test(t.match.def, s, e, !1, c, !1);
                                        }
                                        function S(e, t) {
                                            var n = e.alternation, i = void 0 === t || n <= t.alternation && -1 === e.locator[n].toString().indexOf(t.locator[n]);
                                            if (!i && n > t.alternation) for (var a = 0; a < n; a++) if (e.locator[a] !== t.locator[a]) {
                                                n = a, i = !0;
                                                break;
                                            }
                                            return !!i && function(n) {
                                                e.mloc = e.mloc || {};
                                                var i = e.locator[n];
                                                if (void 0 !== i) {
                                                    if ("string" == typeof i && (i = i.split(",")[0]), void 0 === e.mloc[i] && (e.mloc[i] = e.locator.slice(), 
                                                    e.mloc[i].push(":".concat(e.alternation))), void 0 !== t) {
                                                        for (var a in t.mloc) "string" == typeof a && (a = parseInt(a.split(",")[0])), e.mloc[a + 0] = t.mloc[a];
                                                        e.locator[n] = Object.keys(e.mloc).join(",");
                                                    }
                                                    return e.alternation > n && (e.alternation = n), !0;
                                                }
                                                return e.alternation = void 0, !1;
                                            }(n);
                                        }
                                        function O(e, t) {
                                            if (e.locator.length !== t.locator.length) return !1;
                                            for (var n = e.alternation + 1; n < e.locator.length; n++) if (e.locator[n] !== t.locator[n]) return !1;
                                            return !0;
                                        }
                                        if (h > e + c._maxTestPos) throw new Error("Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ".concat(s.mask));
                                        if (h === e && void 0 === r.matches) {
                                            if (m.push({
                                                match: r,
                                                locator: l.reverse(),
                                                cd: y,
                                                mloc: {}
                                            }), !r.optionality || void 0 !== p || !(c.definitions && c.definitions[r.nativeDef] && c.definitions[r.nativeDef].optional || a.default.prototype.definitions[r.nativeDef] && a.default.prototype.definitions[r.nativeDef].optional)) return !0;
                                            g = !0, h = e;
                                        } else if (void 0 !== r.matches) {
                                            if (r.isGroup && p !== r) return function() {
                                                if (r = f(t.matches[t.matches.indexOf(r) + 1], l, p)) return !0;
                                            }();
                                            if (r.isOptional) return function() {
                                                var t = r, a = m.length;
                                                if (r = b(r, n, l, p), m.length > 0) {
                                                    if (m.forEach((function(e, t) {
                                                        t >= a && (e.match.optionality = e.match.optionality ? e.match.optionality + 1 : 1);
                                                    })), i = m[m.length - 1].match, void 0 !== p || !v(i, t)) return r;
                                                    g = !0, h = e;
                                                }
                                            }();
                                            if (r.isAlternator) return function() {
                                                function i(e) {
                                                    for (var t, n = e.matches[0].matches ? e.matches[0].matches.length : 1, i = 0; i < e.matches.length && n === (t = e.matches[i].matches ? e.matches[i].matches.length : 1); i++) ;
                                                    return n !== t;
                                                }
                                                o.hasAlternator = !0;
                                                var a, v = r, y = [], b = m.slice(), x = l.length, _ = n.length > 0 ? n.shift() : -1;
                                                if (-1 === _ || "string" == typeof _) {
                                                    var M, E = h, j = n.slice(), T = [];
                                                    if ("string" == typeof _) T = _.split(","); else for (M = 0; M < v.matches.length; M++) T.push(M.toString());
                                                    if (void 0 !== s.excludes[e]) {
                                                        for (var A = T.slice(), D = 0, L = s.excludes[e].length; D < L; D++) {
                                                            var C = s.excludes[e][D].toString().split(":");
                                                            l.length == C[1] && T.splice(T.indexOf(C[0]), 1);
                                                        }
                                                        0 === T.length && (delete s.excludes[e], T = A);
                                                    }
                                                    (!0 === c.keepStatic || isFinite(parseInt(c.keepStatic)) && E >= c.keepStatic) && (T = T.slice(0, 1));
                                                    for (var B = 0; B < T.length; B++) {
                                                        M = parseInt(T[B]), m = [], n = "string" == typeof _ && w(h, M, x) || j.slice();
                                                        var I = v.matches[M];
                                                        if (I && f(I, [ M ].concat(l), p)) r = !0; else if (0 === B && (k = i(v)), I && I.matches && I.matches.length > v.matches[0].matches.length) break;
                                                        a = m.slice(), h = E, m = [];
                                                        for (var R = 0; R < a.length; R++) {
                                                            var F = a[R], N = !1;
                                                            F.alternation = F.alternation || x, S(F);
                                                            for (var V = 0; V < y.length; V++) {
                                                                var G = y[V];
                                                                if ("string" != typeof _ || void 0 !== F.alternation && T.includes(F.locator[F.alternation].toString())) {
                                                                    if (F.match.nativeDef === G.match.nativeDef) {
                                                                        N = !0, S(G, F);
                                                                        break;
                                                                    }
                                                                    if (d(F, G, c)) {
                                                                        S(F, G) && (N = !0, y.splice(y.indexOf(G), 0, F));
                                                                        break;
                                                                    }
                                                                    if (d(G, F, c)) {
                                                                        S(G, F);
                                                                        break;
                                                                    }
                                                                    if (P(F, G)) {
                                                                        O(F, G) || void 0 !== u.inputmask.userOptions.keepStatic ? S(F, G) && (N = !0, y.splice(y.indexOf(G), 0, F)) : c.keepStatic = !0;
                                                                        break;
                                                                    }
                                                                    if (P(G, F)) {
                                                                        S(G, F);
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            N || y.push(F);
                                                        }
                                                    }
                                                    m = b.concat(y), h = e, g = m.length > 0 && k, r = y.length > 0 && !k, k && g && !r && m.forEach((function(e, t) {
                                                        e.unMatchedAlternationStopped = !0;
                                                    })), n = j.slice();
                                                } else r = f(v.matches[_] || t.matches[_], [ _ ].concat(l), p);
                                                if (r) return !0;
                                            }();
                                            if (r.isQuantifier && p !== t.matches[t.matches.indexOf(r) - 1]) return function() {
                                                for (var a = r, o = !1, u = n.length > 0 ? n.shift() : 0; u < (isNaN(a.quantifier.max) ? u + 1 : a.quantifier.max) && h <= e; u++) {
                                                    var p = t.matches[t.matches.indexOf(a) - 1];
                                                    if (r = f(p, [ u ].concat(l), p)) {
                                                        if (m.forEach((function(t, n) {
                                                            (i = x(p, t.match) ? t.match : m[m.length - 1].match).optionalQuantifier = u >= a.quantifier.min, 
                                                            i.jit = (u + 1) * (p.matches.indexOf(i) + 1) > a.quantifier.jit, i.optionalQuantifier && v(i, p) && (g = !0, 
                                                            h = e, c.greedy && null == s.validPositions[e - 1] && u > a.quantifier.min && -1 != [ "*", "+" ].indexOf(a.quantifier.max) && (m.pop(), 
                                                            y = void 0), o = !0, r = !1), !o && i.jit && (s.jitOffset[e] = p.matches.length - p.matches.indexOf(i));
                                                        })), o) break;
                                                        return !0;
                                                    }
                                                }
                                            }();
                                            if (r = b(r, n, l, p)) return !0;
                                        } else h++;
                                    }
                                    for (var p = n.length > 0 ? n.shift() : 0; p < t.matches.length; p++) if (!0 !== t.matches[p].isQuantifier) {
                                        var v = f(t.matches[p], [ p ].concat(r), l);
                                        if (v && h === e) return v;
                                        if (h > e) break;
                                    }
                                }
                                function x(e, t) {
                                    var n = -1 != e.matches.indexOf(t);
                                    return n || e.matches.forEach((function(e, i) {
                                        void 0 === e.matches || n || (n = x(e, t));
                                    })), n;
                                }
                                if (e > -1) {
                                    if (void 0 === t) {
                                        for (var w, P = e - 1; void 0 === (w = s.validPositions[P] || s.tests[P]) && P > -1; ) P--;
                                        void 0 !== w && P > -1 && (v = function(e, t) {
                                            var n, i = [];
                                            return Array.isArray(t) || (t = [ t ]), t.length > 0 && (void 0 === t[0].alternation || !0 === c.keepStatic ? 0 === (i = f.call(o, e, t.slice()).locator.slice()).length && (i = t[0].locator.slice()) : t.forEach((function(e) {
                                                "" !== e.def && (0 === i.length ? (n = e.alternation, i = e.locator.slice()) : e.locator[n] && -1 === i[n].toString().indexOf(e.locator[n]) && (i[n] += "," + e.locator[n]));
                                            }))), i;
                                        }(P, w), y = v.join(""), h = P);
                                    }
                                    if (s.tests[e] && s.tests[e][0].cd === y) return s.tests[e];
                                    for (var S = v.shift(); S < p.length; S++) if (b(p[S], v, [ S ]) && h === e || h > e) break;
                                }
                                return (0 === m.length || g) && m.push({
                                    match: {
                                        fn: null,
                                        static: !0,
                                        optionality: !1,
                                        casing: null,
                                        def: "",
                                        placeholder: ""
                                    },
                                    locator: k && 0 === m.filter((function(e) {
                                        return !0 !== e.unMatchedAlternationStopped;
                                    })).length ? [ 0 ] : [],
                                    mloc: {},
                                    cd: y
                                }), void 0 !== t && s.tests[e] ? r = l.extend(!0, [], m) : (s.tests[e] = l.extend(!0, [], m), 
                                r = s.tests[e]), m.forEach((function(e) {
                                    e.match.optionality = e.match.defOptionality || !1;
                                })), r;
                            }
                        },
                        7215: function(e, t, n) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.alternate = l, t.checkAlternationMatch = function(e, t, n) {
                                for (var i, a = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== n ? n.split(",") : [], l = 0; l < o.length; l++) -1 !== (i = e.indexOf(o[l])) && e.splice(i, 1);
                                for (var s = 0; s < e.length; s++) if (a.includes(e[s])) {
                                    r = !0;
                                    break;
                                }
                                return r;
                            }, t.handleRemove = function(e, t, n, i, s) {
                                var c = this, u = this.maskset, f = this.opts;
                                if ((f.numericInput || c.isRTL) && (t === a.keys.Backspace ? t = a.keys.Delete : t === a.keys.Delete && (t = a.keys.Backspace), 
                                c.isRTL)) {
                                    var p = n.end;
                                    n.end = n.begin, n.begin = p;
                                }
                                var d, h = r.getLastValidPosition.call(c, void 0, !0);
                                n.end >= r.getBuffer.call(c).length && h >= n.end && (n.end = h + 1);
                                t === a.keys.Backspace ? n.end - n.begin < 1 && (n.begin = r.seekPrevious.call(c, n.begin)) : t === a.keys.Delete && n.begin === n.end && (n.end = r.isMask.call(c, n.end, !0, !0) ? n.end + 1 : r.seekNext.call(c, n.end) + 1);
                                !1 !== (d = v.call(c, n)) && ((!0 !== i && !1 !== f.keepStatic || null !== f.regex && -1 !== o.getTest.call(c, n.begin).match.def.indexOf("|")) && l.call(c, !0), 
                                !0 !== i && (u.p = t === a.keys.Delete ? n.begin + d : n.begin, u.p = r.determineNewCaretPosition.call(c, {
                                    begin: u.p,
                                    end: u.p
                                }, !1, !1 === f.insertMode && t === a.keys.Backspace ? "none" : void 0).begin));
                            }, t.isComplete = c, t.isSelection = u, t.isValid = f, t.refreshFromBuffer = d, 
                            t.revalidateMask = v;
                            var i = n(6030), a = n(2839), r = n(8711), o = n(4713);
                            function l(e, t, n, i, a, s) {
                                var c = this, u = this.dependencyLib, p = this.opts, d = c.maskset;
                                if (!c.hasAlternator) return !1;
                                var h, v, m, g, y, k, b, x, w, P, S, O = u.extend(!0, [], d.validPositions), _ = u.extend(!0, {}, d.tests), M = !1, E = !1, j = void 0 !== a ? a : r.getLastValidPosition.call(c);
                                if (s && (P = s.begin, S = s.end, s.begin > s.end && (P = s.end, S = s.begin)), 
                                -1 === j && void 0 === a) h = 0, v = (g = o.getTest.call(c, h)).alternation; else for (;j >= 0; j--) if ((m = d.validPositions[j]) && void 0 !== m.alternation) {
                                    if (j <= (e || 0) && g && g.locator[m.alternation] !== m.locator[m.alternation]) break;
                                    h = j, v = d.validPositions[h].alternation, g = m;
                                }
                                if (void 0 !== v) {
                                    b = parseInt(h), d.excludes[b] = d.excludes[b] || [], !0 !== e && d.excludes[b].push((0, 
                                    o.getDecisionTaker)(g) + ":" + g.alternation);
                                    var T = [], A = -1;
                                    for (y = b; b < r.getLastValidPosition.call(c, void 0, !0) + 1; y++) -1 === A && e <= y && void 0 !== t && (T.push(t), 
                                    A = T.length - 1), (k = d.validPositions[b]) && !0 !== k.generatedInput && (void 0 === s || y < P || y >= S) && T.push(k.input), 
                                    d.validPositions.splice(b, 1);
                                    for (-1 === A && void 0 !== t && (T.push(t), A = T.length - 1); void 0 !== d.excludes[b] && d.excludes[b].length < 10; ) {
                                        for (d.tests = {}, r.resetMaskSet.call(c, !0), M = !0, y = 0; y < T.length && (x = M.caret || 0 == p.insertMode && null != x ? r.seekNext.call(c, x) : r.getLastValidPosition.call(c, void 0, !0) + 1, 
                                        w = T[y], M = f.call(c, x, w, !1, i, !0)); y++) y === A && (E = M), 1 == e && M && (E = {
                                            caretPos: y
                                        });
                                        if (M) break;
                                        if (r.resetMaskSet.call(c), g = o.getTest.call(c, b), d.validPositions = u.extend(!0, [], O), 
                                        d.tests = u.extend(!0, {}, _), !d.excludes[b]) {
                                            E = l.call(c, e, t, n, i, b - 1, s);
                                            break;
                                        }
                                        if (null != g.alternation) {
                                            var D = (0, o.getDecisionTaker)(g);
                                            if (-1 !== d.excludes[b].indexOf(D + ":" + g.alternation)) {
                                                E = l.call(c, e, t, n, i, b - 1, s);
                                                break;
                                            }
                                            for (d.excludes[b].push(D + ":" + g.alternation), y = b; y < r.getLastValidPosition.call(c, void 0, !0) + 1; y++) d.validPositions.splice(b);
                                        } else delete d.excludes[b];
                                    }
                                }
                                return E && !1 === p.keepStatic || delete d.excludes[b], E;
                            }
                            function s(e, t, n) {
                                var i = this.opts, r = this.maskset;
                                switch (i.casing || t.casing) {
                                  case "upper":
                                    e = e.toUpperCase();
                                    break;

                                  case "lower":
                                    e = e.toLowerCase();
                                    break;

                                  case "title":
                                    var o = r.validPositions[n - 1];
                                    e = 0 === n || o && o.input === String.fromCharCode(a.keyCode.Space) ? e.toUpperCase() : e.toLowerCase();
                                    break;

                                  default:
                                    if ("function" == typeof i.casing) {
                                        var l = Array.prototype.slice.call(arguments);
                                        l.push(r.validPositions), e = i.casing.apply(this, l);
                                    }
                                }
                                return e;
                            }
                            function c(e) {
                                var t = this, n = this.opts, i = this.maskset;
                                if ("function" == typeof n.isComplete) return n.isComplete(e, n);
                                if ("*" !== n.repeat) {
                                    var a = !1, l = r.determineLastRequiredPosition.call(t, !0), s = l.l;
                                    if (void 0 === l.def || l.def.newBlockMarker || l.def.optionality || l.def.optionalQuantifier) {
                                        a = !0;
                                        for (var c = 0; c <= s; c++) {
                                            var u = o.getTestTemplate.call(t, c).match;
                                            if (!0 !== u.static && void 0 === i.validPositions[c] && (!1 === u.optionality || void 0 === u.optionality || u.optionality && 0 == u.newBlockMarker) && (!1 === u.optionalQuantifier || void 0 === u.optionalQuantifier) || !0 === u.static && "" != u.def && e[c] !== o.getPlaceholder.call(t, c, u)) {
                                                a = !1;
                                                break;
                                            }
                                        }
                                    }
                                    return a;
                                }
                            }
                            function u(e) {
                                var t = this.opts.insertMode ? 0 : 1;
                                return this.isRTL ? e.begin - e.end > t : e.end - e.begin > t;
                            }
                            function f(e, t, n, i, a, p, m) {
                                var g = this, y = this.dependencyLib, k = this.opts, b = g.maskset;
                                n = !0 === n;
                                var x = e;
                                function w(e) {
                                    if (void 0 !== e) {
                                        if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [ e.remove ]), 
                                        e.remove.sort((function(e, t) {
                                            return g.isRTL ? e.pos - t.pos : t.pos - e.pos;
                                        })).forEach((function(e) {
                                            v.call(g, {
                                                begin: e,
                                                end: e + 1
                                            });
                                        })), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [ e.insert ]), 
                                        e.insert.sort((function(e, t) {
                                            return g.isRTL ? t.pos - e.pos : e.pos - t.pos;
                                        })).forEach((function(e) {
                                            "" !== e.c && f.call(g, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : i);
                                        })), e.insert = void 0), e.refreshFromBuffer && e.buffer) {
                                            var t = e.refreshFromBuffer;
                                            d.call(g, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;
                                        }
                                        void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);
                                    }
                                    return e;
                                }
                                function P(t, n, a) {
                                    var l = !1;
                                    return o.getTests.call(g, t).every((function(c, f) {
                                        var p = c.match;
                                        if (r.getBuffer.call(g, !0), !1 !== (l = (!p.jit || void 0 !== b.validPositions[r.seekPrevious.call(g, t)]) && (null != p.fn ? p.fn.test(n, b, t, a, k, u.call(g, e)) : (n === p.def || n === k.skipOptionalPartCharacter) && "" !== p.def && {
                                            c: o.getPlaceholder.call(g, t, p, !0) || p.def,
                                            pos: t
                                        }))) {
                                            var d = void 0 !== l.c ? l.c : n, h = t;
                                            return d = d === k.skipOptionalPartCharacter && !0 === p.static ? o.getPlaceholder.call(g, t, p, !0) || p.def : d, 
                                            !0 !== (l = w(l)) && void 0 !== l.pos && l.pos !== t && (h = l.pos), !0 !== l && void 0 === l.pos && void 0 === l.c ? !1 : (!1 === v.call(g, e, y.extend({}, c, {
                                                input: s.call(g, d, p, h)
                                            }), i, h) && (l = !1), !1);
                                        }
                                        return !0;
                                    })), l;
                                }
                                void 0 !== e.begin && (x = g.isRTL ? e.end : e.begin);
                                var S = !0, O = y.extend(!0, [], b.validPositions);
                                if (!1 === k.keepStatic && void 0 !== b.excludes[x] && !0 !== a && !0 !== i) for (var _ = x; _ < (g.isRTL ? e.begin : e.end); _++) void 0 !== b.excludes[_] && (b.excludes[_] = void 0, 
                                delete b.tests[_]);
                                if ("function" == typeof k.preValidation && !0 !== i && !0 !== p && (S = w(S = k.preValidation.call(g, r.getBuffer.call(g), x, t, u.call(g, e), k, b, e, n || a))), 
                                !0 === S) {
                                    if (S = P(x, t, n), (!n || !0 === i) && !1 === S && !0 !== p) {
                                        var M = b.validPositions[x];
                                        if (!M || !0 !== M.match.static || M.match.def !== t && t !== k.skipOptionalPartCharacter) {
                                            if (k.insertMode || void 0 === b.validPositions[r.seekNext.call(g, x)] || e.end > x) {
                                                var E = !1;
                                                if (b.jitOffset[x] && void 0 === b.validPositions[r.seekNext.call(g, x)] && !1 !== (S = f.call(g, x + b.jitOffset[x], t, !0, !0)) && (!0 !== a && (S.caret = x), 
                                                E = !0), e.end > x && (b.validPositions[x] = void 0), !E && !r.isMask.call(g, x, k.keepStatic && 0 === x)) for (var j = x + 1, T = r.seekNext.call(g, x, !1, 0 !== x); j <= T; j++) if (!1 !== (S = P(j, t, n))) {
                                                    S = h.call(g, x, void 0 !== S.pos ? S.pos : j) || S, x = j;
                                                    break;
                                                }
                                            }
                                        } else S = {
                                            caret: r.seekNext.call(g, x)
                                        };
                                    }
                                    g.hasAlternator && !0 !== a && !n && (a = !0, !1 === S && k.keepStatic && (c.call(g, r.getBuffer.call(g)) || 0 === x) ? S = l.call(g, x, t, n, i, void 0, e) : (u.call(g, e) && b.tests[x] && b.tests[x].length > 1 && k.keepStatic || 1 == S && !0 !== k.numericInput && b.tests[x] && b.tests[x].length > 1 && r.getLastValidPosition.call(g, void 0, !0) > x) && (S = l.call(g, !0))), 
                                    !0 === S && (S = {
                                        pos: x
                                    });
                                }
                                if ("function" == typeof k.postValidation && !0 !== i && !0 !== p) {
                                    var A = k.postValidation.call(g, r.getBuffer.call(g, !0), void 0 !== e.begin ? g.isRTL ? e.end : e.begin : e, t, S, k, b, n, m);
                                    void 0 !== A && (S = !0 === A ? S : A);
                                }
                                S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === p ? (r.resetMaskSet.call(g, !0), 
                                b.validPositions = y.extend(!0, [], O)) : h.call(g, void 0, x, !0);
                                var D = w(S);
                                void 0 !== g.maxLength && r.getBuffer.call(g).length > g.maxLength && !i && (r.resetMaskSet.call(g, !0), 
                                b.validPositions = y.extend(!0, [], O), D = !1);
                                return D;
                            }
                            function p(e, t, n) {
                                for (var i = this.maskset, a = !1, r = o.getTests.call(this, e), l = 0; l < r.length; l++) {
                                    if (r[l].match && (r[l].match.nativeDef === t.match[n.shiftPositions ? "def" : "nativeDef"] && (!n.shiftPositions || !t.match.static) || r[l].match.nativeDef === t.match.nativeDef || n.regex && !r[l].match.static && r[l].match.fn.test(t.input, i, e, !1, n))) {
                                        a = !0;
                                        break;
                                    }
                                    if (r[l].match && r[l].match.def === t.match.nativeDef) {
                                        a = void 0;
                                        break;
                                    }
                                }
                                return !1 === a && void 0 !== i.jitOffset[e] && (a = p.call(this, e + i.jitOffset[e], t, n)), 
                                a;
                            }
                            function d(e, t, n) {
                                var a, o, l = this, s = this.maskset, c = this.opts, u = this.dependencyLib, f = c.skipOptionalPartCharacter, p = l.isRTL ? n.slice().reverse() : n;
                                if (c.skipOptionalPartCharacter = "", !0 === e) r.resetMaskSet.call(l, !1), e = 0, 
                                t = n.length, o = r.determineNewCaretPosition.call(l, {
                                    begin: 0,
                                    end: 0
                                }, !1).begin; else {
                                    for (a = e; a < t; a++) s.validPositions.splice(e, 0);
                                    o = e;
                                }
                                var d = new u.Event("keypress");
                                for (a = e; a < t; a++) {
                                    d.key = p[a].toString(), l.ignorable = !1;
                                    var h = i.EventHandlers.keypressEvent.call(l, d, !0, !1, !1, o);
                                    !1 !== h && void 0 !== h && (o = h.forwardPosition);
                                }
                                c.skipOptionalPartCharacter = f;
                            }
                            function h(e, t, n) {
                                var i = this, a = this.maskset, l = this.dependencyLib;
                                if (void 0 === e) for (e = t - 1; e > 0 && !a.validPositions[e]; e--) ;
                                for (var s = e; s < t; s++) if (void 0 === a.validPositions[s] && !r.isMask.call(i, s, !1)) if (0 == s ? o.getTest.call(i, s) : a.validPositions[s - 1]) {
                                    var c = o.getTests.call(i, s).slice();
                                    "" === c[c.length - 1].match.def && c.pop();
                                    var u, p = o.determineTestTemplate.call(i, s, c);
                                    if (p && (!0 !== p.match.jit || "master" === p.match.newBlockMarker && (u = a.validPositions[s + 1]) && !0 === u.match.optionalQuantifier) && ((p = l.extend({}, p, {
                                        input: o.getPlaceholder.call(i, s, p.match, !0) || p.match.def
                                    })).generatedInput = !0, v.call(i, s, p, !0), !0 !== n)) {
                                        var d = a.validPositions[t].input;
                                        return a.validPositions[t] = void 0, f.call(i, t, d, !0, !0);
                                    }
                                }
                            }
                            function v(e, t, n, i) {
                                var a = this, l = this.maskset, s = this.opts, c = this.dependencyLib;
                                function d(e, t, n) {
                                    var i = t[e];
                                    if (void 0 !== i && !0 === i.match.static && !0 !== i.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {
                                        var a = n.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1], r = n.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];
                                        return a && r;
                                    }
                                    return !1;
                                }
                                var h = 0, v = void 0 !== e.begin ? e.begin : e, m = void 0 !== e.end ? e.end : e, g = !0;
                                if (e.begin > e.end && (v = e.end, m = e.begin), i = void 0 !== i ? i : v, void 0 === n && (v !== m || s.insertMode && void 0 !== l.validPositions[i] || void 0 === t || t.match.optionalQuantifier || t.match.optionality)) {
                                    var y, k = c.extend(!0, [], l.validPositions), b = r.getLastValidPosition.call(a, void 0, !0);
                                    l.p = v;
                                    var x = u.call(a, e) ? v : i;
                                    for (y = b; y >= x; y--) l.validPositions.splice(y, 1), void 0 === t && delete l.tests[y + 1];
                                    var w, P, S = i, O = S;
                                    for (t && (l.validPositions[i] = c.extend(!0, {}, t), O++, S++), null == k[m] && l.jitOffset[m] && (m += l.jitOffset[m] + 1), 
                                    y = t ? m : m - 1; y <= b; y++) {
                                        if (void 0 !== (w = k[y]) && !0 !== w.generatedInput && (y >= m || y >= v && d(y, k, {
                                            begin: v,
                                            end: m
                                        }))) {
                                            for (;"" !== o.getTest.call(a, O).match.def; ) {
                                                if (!1 !== (P = p.call(a, O, w, s)) || "+" === w.match.def) {
                                                    "+" === w.match.def && r.getBuffer.call(a, !0);
                                                    var _ = f.call(a, O, w.input, "+" !== w.match.def, !0);
                                                    if (g = !1 !== _, S = (_.pos || O) + 1, !g && P) break;
                                                } else g = !1;
                                                if (g) {
                                                    void 0 === t && w.match.static && y === e.begin && h++;
                                                    break;
                                                }
                                                if (!g && r.getBuffer.call(a), O > l.maskLength) break;
                                                O++;
                                            }
                                            "" == o.getTest.call(a, O).match.def && (g = !1), O = S;
                                        }
                                        if (!g) break;
                                    }
                                    if (!g) return l.validPositions = c.extend(!0, [], k), r.resetMaskSet.call(a, !0), 
                                    !1;
                                } else t && o.getTest.call(a, i).match.cd === t.match.cd && (l.validPositions[i] = c.extend(!0, {}, t));
                                return r.resetMaskSet.call(a, !0), h;
                            }
                        }
                    }, t = {};
                    function n(i) {
                        var a = t[i];
                        if (void 0 !== a) return a.exports;
                        var r = t[i] = {
                            exports: {}
                        };
                        return e[i](r, r.exports, n), r.exports;
                    }
                    var i = {};
                    return function() {
                        var e = i;
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }), e.default = void 0, n(7149), n(3194), n(9302), n(4013), n(3851), n(219), n(207), 
                        n(5296);
                        var t, a = (t = n(2394)) && t.__esModule ? t : {
                            default: t
                        };
                        e.default = a.default;
                    }(), i;
                }();
            }));
        },
        193: (module, exports, __webpack_require__) => {
            module = __webpack_require__.nmd(module);
            var LARGE_ARRAY_SIZE = 200;
            var HASH_UNDEFINED = "__lodash_hash_undefined__";
            var MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
            var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reFlags = /\w*$/;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
            var freeGlobal = typeof __webpack_require__.g == "object" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var freeExports = true && exports && !exports.nodeType && exports;
            var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            function addMapEntry(map, pair) {
                map.set(pair[0], pair[1]);
                return map;
            }
            function addSetEntry(set, value) {
                set.add(value);
                return set;
            }
            function arrayEach(array, iteratee) {
                var index = -1, length = array ? array.length : 0;
                while (++index < length) if (iteratee(array[index], index, array) === false) break;
                return array;
            }
            function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) array[offset + index] = values[index];
                return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1, length = array ? array.length : 0;
                if (initAccum && length) accumulator = array[++index];
                while (++index < length) accumulator = iteratee(accumulator, array[index], index, array);
                return accumulator;
            }
            function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) result[index] = iteratee(index);
                return result;
            }
            function getValue(object, key) {
                return object == null ? void 0 : object[key];
            }
            function isHostObject(value) {
                var result = false;
                if (value != null && typeof value.toString != "function") try {
                    result = !!(value + "");
                } catch (e) {}
                return result;
            }
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                map.forEach((function(value, key) {
                    result[++index] = [ key, value ];
                }));
                return result;
            }
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach((function(value) {
                    result[++index] = value;
                }));
                return result;
            }
            var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
            var coreJsData = root["__core-js_shared__"];
            var maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
            }();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            var Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
            var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
            var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            function Hash(entries) {
                var index = -1, length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
                return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
                var data = this.__data__;
                data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
                return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype["delete"] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
                var index = -1, length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function listCacheClear() {
                this.__data__ = [];
            }
            function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) return false;
                var lastIndex = data.length - 1;
                if (index == lastIndex) data.pop(); else splice.call(data, index, 1);
                return true;
            }
            function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) data.push([ key, value ]); else data[index][1] = value;
                return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype["delete"] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
                var index = -1, length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function mapCacheClear() {
                this.__data__ = {
                    hash: new Hash,
                    map: new (Map || ListCache),
                    string: new Hash
                };
            }
            function mapCacheDelete(key) {
                return getMapData(this, key)["delete"](key);
            }
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
                getMapData(this, key).set(key, value);
                return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype["delete"] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function Stack(entries) {
                this.__data__ = new ListCache(entries);
            }
            function stackClear() {
                this.__data__ = new ListCache;
            }
            function stackDelete(key) {
                return this.__data__["delete"](key);
            }
            function stackGet(key) {
                return this.__data__.get(key);
            }
            function stackHas(key) {
                return this.__data__.has(key);
            }
            function stackSet(key, value) {
                var cache = this.__data__;
                if (cache instanceof ListCache) {
                    var pairs = cache.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([ key, value ]);
                        return this;
                    }
                    cache = this.__data__ = new MapCache(pairs);
                }
                cache.set(key, value);
                return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype["delete"] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
                var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
                var length = result.length, skipIndexes = !!length;
                for (var key in value) if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) result.push(key);
                return result;
            }
            function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) object[key] = value;
            }
            function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) if (eq(array[length][0], key)) return length;
                return -1;
            }
            function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
            }
            function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
                var result;
                if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
                if (result !== void 0) return result;
                if (!isObject(value)) return value;
                var isArr = isArray(value);
                if (isArr) {
                    result = initCloneArray(value);
                    if (!isDeep) return copyArray(value, result);
                } else {
                    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                    if (isBuffer(value)) return cloneBuffer(value, isDeep);
                    if (tag == objectTag || tag == argsTag || isFunc && !object) {
                        if (isHostObject(value)) return object ? value : {};
                        result = initCloneObject(isFunc ? {} : value);
                        if (!isDeep) return copySymbols(value, baseAssign(result, value));
                    } else {
                        if (!cloneableTags[tag]) return object ? value : {};
                        result = initCloneByTag(value, tag, baseClone, isDeep);
                    }
                }
                stack || (stack = new Stack);
                var stacked = stack.get(value);
                if (stacked) return stacked;
                stack.set(value, result);
                if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
                arrayEach(props || value, (function(subValue, key) {
                    if (props) {
                        key = subValue;
                        subValue = value[key];
                    }
                    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
                }));
                return result;
            }
            function baseCreate(proto) {
                return isObject(proto) ? objectCreate(proto) : {};
            }
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
            }
            function baseGetTag(value) {
                return objectToString.call(value);
            }
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) return false;
                var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
            }
            function baseKeys(object) {
                if (!isPrototype(object)) return nativeKeys(object);
                var result = [];
                for (var key in Object(object)) if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
                return result;
            }
            function cloneBuffer(buffer, isDeep) {
                if (isDeep) return buffer.slice();
                var result = new buffer.constructor(buffer.length);
                buffer.copy(result);
                return result;
            }
            function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                return result;
            }
            function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
            }
            function cloneMap(map, isDeep, cloneFunc) {
                var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
                return arrayReduce(array, addMapEntry, new map.constructor);
            }
            function cloneRegExp(regexp) {
                var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result.lastIndex = regexp.lastIndex;
                return result;
            }
            function cloneSet(set, isDeep, cloneFunc) {
                var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
                return arrayReduce(array, addSetEntry, new set.constructor);
            }
            function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
            }
            function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
            }
            function copyArray(source, array) {
                var index = -1, length = source.length;
                array || (array = Array(length));
                while (++index < length) array[index] = source[index];
                return array;
            }
            function copyObject(source, props, object, customizer) {
                object || (object = {});
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                    assignValue(object, key, newValue === void 0 ? source[key] : newValue);
                }
                return object;
            }
            function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
            }
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
            }
            function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
            }
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
            var getTag = baseGetTag;
            if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
                var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
                if (ctorString) switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
                return result;
            };
            function initCloneArray(array) {
                var length = array.length, result = array.constructor(length);
                if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                    result.index = array.index;
                    result.input = array.input;
                }
                return result;
            }
            function initCloneObject(object) {
                return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
            }
            function initCloneByTag(object, tag, cloneFunc, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return cloneArrayBuffer(object);

                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);

                  case dataViewTag:
                    return cloneDataView(object, isDeep);

                  case float32Tag:
                  case float64Tag:
                  case int8Tag:
                  case int16Tag:
                  case int32Tag:
                  case uint8Tag:
                  case uint8ClampedTag:
                  case uint16Tag:
                  case uint32Tag:
                    return cloneTypedArray(object, isDeep);

                  case mapTag:
                    return cloneMap(object, isDeep, cloneFunc);

                  case numberTag:
                  case stringTag:
                    return new Ctor(object);

                  case regexpTag:
                    return cloneRegExp(object);

                  case setTag:
                    return cloneSet(object, isDeep, cloneFunc);

                  case symbolTag:
                    return cloneSymbol(object);
                }
            }
            function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
            }
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
            }
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + "";
                    } catch (e) {}
                }
                return "";
            }
            function cloneDeep(value) {
                return baseClone(value, true, true);
            }
            function eq(value, other) {
                return value === other || value !== value && other !== other;
            }
            function isArguments(value) {
                return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
            }
            function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
            }
            var isBuffer = nativeIsBuffer || stubFalse;
            function isFunction(value) {
                var tag = isObject(value) ? objectToString.call(value) : "";
                return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isObject(value) {
                var type = typeof value;
                return !!value && (type == "object" || type == "function");
            }
            function isObjectLike(value) {
                return !!value && typeof value == "object";
            }
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            function stubArray() {
                return [];
            }
            function stubFalse() {
                return false;
            }
            module.exports = cloneDeep;
        },
        142: (module, exports, __webpack_require__) => {
            module = __webpack_require__.nmd(module);
            var LARGE_ARRAY_SIZE = 200;
            var HASH_UNDEFINED = "__lodash_hash_undefined__";
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            var MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
            var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var freeGlobal = typeof __webpack_require__.g == "object" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var freeExports = true && exports && !exports.nodeType && exports;
            var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = function() {
                try {
                    return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arrayFilter(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) result[resIndex++] = value;
                }
                return result;
            }
            function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) array[offset + index] = values[index];
                return array;
            }
            function arraySome(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) if (predicate(array[index], index, array)) return true;
                return false;
            }
            function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) result[index] = iteratee(index);
                return result;
            }
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }
            function cacheHas(cache, key) {
                return cache.has(key);
            }
            function getValue(object, key) {
                return object == null ? void 0 : object[key];
            }
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                map.forEach((function(value, key) {
                    result[++index] = [ key, value ];
                }));
                return result;
            }
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach((function(value) {
                    result[++index] = value;
                }));
                return result;
            }
            var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
            var coreJsData = root["__core-js_shared__"];
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
            }();
            var nativeObjectToString = objectProto.toString;
            var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            var Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : void 0;
            var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
            var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            function Hash(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
            }
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
            }
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
                return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype["delete"] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
            }
            function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) return false;
                var lastIndex = data.length - 1;
                if (index == lastIndex) data.pop(); else splice.call(data, index, 1);
                --this.size;
                return true;
            }
            function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                    ++this.size;
                    data.push([ key, value ]);
                } else data[index][1] = value;
                return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype["delete"] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                    hash: new Hash,
                    map: new (Map || ListCache),
                    string: new Hash
                };
            }
            function mapCacheDelete(key) {
                var result = getMapData(this, key)["delete"](key);
                this.size -= result ? 1 : 0;
                return result;
            }
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype["delete"] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values) {
                var index = -1, length = values == null ? 0 : values.length;
                this.__data__ = new MapCache;
                while (++index < length) this.add(values[index]);
            }
            function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
            }
            function setCacheHas(value) {
                return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            function stackClear() {
                this.__data__ = new ListCache;
                this.size = 0;
            }
            function stackDelete(key) {
                var data = this.__data__, result = data["delete"](key);
                this.size = data.size;
                return result;
            }
            function stackGet(key) {
                return this.__data__.get(key);
            }
            function stackHas(key) {
                return this.__data__.has(key);
            }
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([ key, value ]);
                        this.size = ++data.size;
                        return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype["delete"] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) result.push(key);
                return result;
            }
            function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) if (eq(array[length][0], key)) return length;
                return -1;
            }
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
            }
            function baseGetTag(value) {
                if (value == null) return value === void 0 ? undefinedTag : nullTag;
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) return true;
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
            }
            function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) return false;
                    objIsArr = true;
                    objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack);
                    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                        stack || (stack = new Stack);
                        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                    }
                }
                if (!isSameTag) return false;
                stack || (stack = new Stack);
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
            }
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) return false;
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            }
            function baseKeys(object) {
                if (!isPrototype(object)) return nativeKeys(object);
                var result = [];
                for (var key in Object(object)) if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
                return result;
            }
            function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) return stacked == other;
                var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : void 0;
                stack.set(array, other);
                stack.set(other, array);
                while (++index < arrLength) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    if (compared !== void 0) {
                        if (compared) continue;
                        result = false;
                        break;
                    }
                    if (seen) {
                        if (!arraySome(other, (function(othValue, othIndex) {
                            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                        }))) {
                            result = false;
                            break;
                        }
                    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        result = false;
                        break;
                    }
                }
                stack["delete"](array);
                stack["delete"](other);
                return result;
            }
            function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
                    object = object.buffer;
                    other = other.buffer;

                  case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
                    return true;

                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);

                  case errorTag:
                    return object.name == other.name && object.message == other.message;

                  case regexpTag:
                  case stringTag:
                    return object == other + "";

                  case mapTag:
                    var convert = mapToArray;

                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) return false;
                    var stacked = stack.get(object);
                    if (stacked) return stacked == other;
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack["delete"](object);
                    return result;

                  case symbolTag:
                    if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
                return false;
            }
            function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) return false;
                var index = objLength;
                while (index--) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
                }
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) return stacked == other;
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                        result = false;
                        break;
                    }
                    skipCtor || (skipCtor = key == "constructor");
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
                }
                stack["delete"](object);
                stack["delete"](other);
                return result;
            }
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
            }
            function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
            }
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = void 0;
                    var unmasked = true;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                if (unmasked) if (isOwn) value[symToStringTag] = tag; else delete value[symToStringTag];
                return result;
            }
            var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                if (object == null) return [];
                object = Object(object);
                return arrayFilter(nativeGetSymbols(object), (function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                }));
            };
            var getTag = baseGetTag;
            if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                if (ctorString) switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
                return result;
            };
            function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
            }
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
            }
            function objectToString(value) {
                return nativeObjectToString.call(value);
            }
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + "";
                    } catch (e) {}
                }
                return "";
            }
            function eq(value, other) {
                return value === other || value !== value && other !== other;
            }
            var isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            };
            var isArray = Array.isArray;
            function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
            }
            var isBuffer = nativeIsBuffer || stubFalse;
            function isEqual(value, other) {
                return baseIsEqual(value, other);
            }
            function isFunction(value) {
                if (!isObject(value)) return false;
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
            }
            function isObjectLike(value) {
                return value != null && typeof value == "object";
            }
            var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            function stubArray() {
                return [];
            }
            function stubFalse() {
                return false;
            }
            module.exports = isEqual;
        },
        106: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            const cloneDeep = __webpack_require__(193);
            const isEqual = __webpack_require__(142);
            var AttributeMap;
            (function(AttributeMap) {
                function compose(a = {}, b = {}, keepNull = false) {
                    if (typeof a !== "object") a = {};
                    if (typeof b !== "object") b = {};
                    let attributes = cloneDeep(b);
                    if (!keepNull) attributes = Object.keys(attributes).reduce(((copy, key) => {
                        if (attributes[key] != null) copy[key] = attributes[key];
                        return copy;
                    }), {});
                    for (const key in a) if (a[key] !== void 0 && b[key] === void 0) attributes[key] = a[key];
                    return Object.keys(attributes).length > 0 ? attributes : void 0;
                }
                AttributeMap.compose = compose;
                function diff(a = {}, b = {}) {
                    if (typeof a !== "object") a = {};
                    if (typeof b !== "object") b = {};
                    const attributes = Object.keys(a).concat(Object.keys(b)).reduce(((attrs, key) => {
                        if (!isEqual(a[key], b[key])) attrs[key] = b[key] === void 0 ? null : b[key];
                        return attrs;
                    }), {});
                    return Object.keys(attributes).length > 0 ? attributes : void 0;
                }
                AttributeMap.diff = diff;
                function invert(attr = {}, base = {}) {
                    attr = attr || {};
                    const baseInverted = Object.keys(base).reduce(((memo, key) => {
                        if (base[key] !== attr[key] && attr[key] !== void 0) memo[key] = base[key];
                        return memo;
                    }), {});
                    return Object.keys(attr).reduce(((memo, key) => {
                        if (attr[key] !== base[key] && base[key] === void 0) memo[key] = null;
                        return memo;
                    }), baseInverted);
                }
                AttributeMap.invert = invert;
                function transform(a, b, priority = false) {
                    if (typeof a !== "object") return b;
                    if (typeof b !== "object") return;
                    if (!priority) return b;
                    const attributes = Object.keys(b).reduce(((attrs, key) => {
                        if (a[key] === void 0) attrs[key] = b[key];
                        return attrs;
                    }), {});
                    return Object.keys(attributes).length > 0 ? attributes : void 0;
                }
                AttributeMap.transform = transform;
            })(AttributeMap || (AttributeMap = {}));
            exports["default"] = AttributeMap;
        },
        660: (module, exports, __webpack_require__) => {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.AttributeMap = exports.OpIterator = exports.Op = void 0;
            const diff = __webpack_require__(606);
            const cloneDeep = __webpack_require__(193);
            const isEqual = __webpack_require__(142);
            const AttributeMap_1 = __webpack_require__(106);
            exports.AttributeMap = AttributeMap_1.default;
            const Op_1 = __webpack_require__(759);
            exports.Op = Op_1.default;
            const OpIterator_1 = __webpack_require__(317);
            exports.OpIterator = OpIterator_1.default;
            const NULL_CHARACTER = String.fromCharCode(0);
            const getEmbedTypeAndData = (a, b) => {
                if (typeof a !== "object" || a === null) throw new Error(`cannot retain a ${typeof a}`);
                if (typeof b !== "object" || b === null) throw new Error(`cannot retain a ${typeof b}`);
                const embedType = Object.keys(a)[0];
                if (!embedType || embedType !== Object.keys(b)[0]) throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);
                return [ embedType, a[embedType], b[embedType] ];
            };
            class Delta {
                constructor(ops) {
                    if (Array.isArray(ops)) this.ops = ops; else if (ops != null && Array.isArray(ops.ops)) this.ops = ops.ops; else this.ops = [];
                }
                static registerEmbed(embedType, handler) {
                    this.handlers[embedType] = handler;
                }
                static unregisterEmbed(embedType) {
                    delete this.handlers[embedType];
                }
                static getHandler(embedType) {
                    const handler = this.handlers[embedType];
                    if (!handler) throw new Error(`no handlers for embed type "${embedType}"`);
                    return handler;
                }
                insert(arg, attributes) {
                    const newOp = {};
                    if (typeof arg === "string" && arg.length === 0) return this;
                    newOp.insert = arg;
                    if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) newOp.attributes = attributes;
                    return this.push(newOp);
                }
                delete(length) {
                    if (length <= 0) return this;
                    return this.push({
                        delete: length
                    });
                }
                retain(length, attributes) {
                    if (typeof length === "number" && length <= 0) return this;
                    const newOp = {
                        retain: length
                    };
                    if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) newOp.attributes = attributes;
                    return this.push(newOp);
                }
                push(newOp) {
                    let index = this.ops.length;
                    let lastOp = this.ops[index - 1];
                    newOp = cloneDeep(newOp);
                    if (typeof lastOp === "object") {
                        if (typeof newOp.delete === "number" && typeof lastOp.delete === "number") {
                            this.ops[index - 1] = {
                                delete: lastOp.delete + newOp.delete
                            };
                            return this;
                        }
                        if (typeof lastOp.delete === "number" && newOp.insert != null) {
                            index -= 1;
                            lastOp = this.ops[index - 1];
                            if (typeof lastOp !== "object") {
                                this.ops.unshift(newOp);
                                return this;
                            }
                        }
                        if (isEqual(newOp.attributes, lastOp.attributes)) if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                            this.ops[index - 1] = {
                                insert: lastOp.insert + newOp.insert
                            };
                            if (typeof newOp.attributes === "object") this.ops[index - 1].attributes = newOp.attributes;
                            return this;
                        } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                            this.ops[index - 1] = {
                                retain: lastOp.retain + newOp.retain
                            };
                            if (typeof newOp.attributes === "object") this.ops[index - 1].attributes = newOp.attributes;
                            return this;
                        }
                    }
                    if (index === this.ops.length) this.ops.push(newOp); else this.ops.splice(index, 0, newOp);
                    return this;
                }
                chop() {
                    const lastOp = this.ops[this.ops.length - 1];
                    if (lastOp && typeof lastOp.retain === "number" && !lastOp.attributes) this.ops.pop();
                    return this;
                }
                filter(predicate) {
                    return this.ops.filter(predicate);
                }
                forEach(predicate) {
                    this.ops.forEach(predicate);
                }
                map(predicate) {
                    return this.ops.map(predicate);
                }
                partition(predicate) {
                    const passed = [];
                    const failed = [];
                    this.forEach((op => {
                        const target = predicate(op) ? passed : failed;
                        target.push(op);
                    }));
                    return [ passed, failed ];
                }
                reduce(predicate, initialValue) {
                    return this.ops.reduce(predicate, initialValue);
                }
                changeLength() {
                    return this.reduce(((length, elem) => {
                        if (elem.insert) return length + Op_1.default.length(elem); else if (elem.delete) return length - elem.delete;
                        return length;
                    }), 0);
                }
                length() {
                    return this.reduce(((length, elem) => length + Op_1.default.length(elem)), 0);
                }
                slice(start = 0, end = 1 / 0) {
                    const ops = [];
                    const iter = new OpIterator_1.default(this.ops);
                    let index = 0;
                    while (index < end && iter.hasNext()) {
                        let nextOp;
                        if (index < start) nextOp = iter.next(start - index); else {
                            nextOp = iter.next(end - index);
                            ops.push(nextOp);
                        }
                        index += Op_1.default.length(nextOp);
                    }
                    return new Delta(ops);
                }
                compose(other) {
                    const thisIter = new OpIterator_1.default(this.ops);
                    const otherIter = new OpIterator_1.default(other.ops);
                    const ops = [];
                    const firstOther = otherIter.peek();
                    if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
                        let firstLeft = firstOther.retain;
                        while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
                            firstLeft -= thisIter.peekLength();
                            ops.push(thisIter.next());
                        }
                        if (firstOther.retain - firstLeft > 0) otherIter.next(firstOther.retain - firstLeft);
                    }
                    const delta = new Delta(ops);
                    while (thisIter.hasNext() || otherIter.hasNext()) if (otherIter.peekType() === "insert") delta.push(otherIter.next()); else if (thisIter.peekType() === "delete") delta.push(thisIter.next()); else {
                        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                        const thisOp = thisIter.next(length);
                        const otherOp = otherIter.next(length);
                        if (otherOp.retain) {
                            const newOp = {};
                            if (typeof thisOp.retain === "number") newOp.retain = typeof otherOp.retain === "number" ? length : otherOp.retain; else if (typeof otherOp.retain === "number") if (thisOp.retain == null) newOp.insert = thisOp.insert; else newOp.retain = thisOp.retain; else {
                                const action = thisOp.retain == null ? "insert" : "retain";
                                const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);
                                const handler = Delta.getHandler(embedType);
                                newOp[action] = {
                                    [embedType]: handler.compose(thisData, otherData, action === "retain")
                                };
                            }
                            const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                            if (attributes) newOp.attributes = attributes;
                            delta.push(newOp);
                            if (!otherIter.hasNext() && isEqual(delta.ops[delta.ops.length - 1], newOp)) {
                                const rest = new Delta(thisIter.rest());
                                return delta.concat(rest).chop();
                            }
                        } else if (typeof otherOp.delete === "number" && (typeof thisOp.retain === "number" || typeof thisOp.retain === "object" && thisOp.retain !== null)) delta.push(otherOp);
                    }
                    return delta.chop();
                }
                concat(other) {
                    const delta = new Delta(this.ops.slice());
                    if (other.ops.length > 0) {
                        delta.push(other.ops[0]);
                        delta.ops = delta.ops.concat(other.ops.slice(1));
                    }
                    return delta;
                }
                diff(other, cursor) {
                    if (this.ops === other.ops) return new Delta;
                    const strings = [ this, other ].map((delta => delta.map((op => {
                        if (op.insert != null) return typeof op.insert === "string" ? op.insert : NULL_CHARACTER;
                        const prep = delta === other ? "on" : "with";
                        throw new Error("diff() called " + prep + " non-document");
                    })).join("")));
                    const retDelta = new Delta;
                    const diffResult = diff(strings[0], strings[1], cursor, true);
                    const thisIter = new OpIterator_1.default(this.ops);
                    const otherIter = new OpIterator_1.default(other.ops);
                    diffResult.forEach((component => {
                        let length = component[1].length;
                        while (length > 0) {
                            let opLength = 0;
                            switch (component[0]) {
                              case diff.INSERT:
                                opLength = Math.min(otherIter.peekLength(), length);
                                retDelta.push(otherIter.next(opLength));
                                break;

                              case diff.DELETE:
                                opLength = Math.min(length, thisIter.peekLength());
                                thisIter.next(opLength);
                                retDelta.delete(opLength);
                                break;

                              case diff.EQUAL:
                                opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                                const thisOp = thisIter.next(opLength);
                                const otherOp = otherIter.next(opLength);
                                if (isEqual(thisOp.insert, otherOp.insert)) retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes)); else retDelta.push(otherOp).delete(opLength);
                                break;
                            }
                            length -= opLength;
                        }
                    }));
                    return retDelta.chop();
                }
                eachLine(predicate, newline = "\n") {
                    const iter = new OpIterator_1.default(this.ops);
                    let line = new Delta;
                    let i = 0;
                    while (iter.hasNext()) {
                        if (iter.peekType() !== "insert") return;
                        const thisOp = iter.peek();
                        const start = Op_1.default.length(thisOp) - iter.peekLength();
                        const index = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start) - start : -1;
                        if (index < 0) line.push(iter.next()); else if (index > 0) line.push(iter.next(index)); else {
                            if (predicate(line, iter.next(1).attributes || {}, i) === false) return;
                            i += 1;
                            line = new Delta;
                        }
                    }
                    if (line.length() > 0) predicate(line, {}, i);
                }
                invert(base) {
                    const inverted = new Delta;
                    this.reduce(((baseIndex, op) => {
                        if (op.insert) inverted.delete(Op_1.default.length(op)); else if (typeof op.retain === "number" && op.attributes == null) {
                            inverted.retain(op.retain);
                            return baseIndex + op.retain;
                        } else if (op.delete || typeof op.retain === "number") {
                            const length = op.delete || op.retain;
                            const slice = base.slice(baseIndex, baseIndex + length);
                            slice.forEach((baseOp => {
                                if (op.delete) inverted.push(baseOp); else if (op.retain && op.attributes) inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
                            }));
                            return baseIndex + length;
                        } else if (typeof op.retain === "object" && op.retain !== null) {
                            const slice = base.slice(baseIndex, baseIndex + 1);
                            const baseOp = new OpIterator_1.default(slice.ops).next();
                            const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);
                            const handler = Delta.getHandler(embedType);
                            inverted.retain({
                                [embedType]: handler.invert(opData, baseOpData)
                            }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
                            return baseIndex + 1;
                        }
                        return baseIndex;
                    }), 0);
                    return inverted.chop();
                }
                transform(arg, priority = false) {
                    priority = !!priority;
                    if (typeof arg === "number") return this.transformPosition(arg, priority);
                    const other = arg;
                    const thisIter = new OpIterator_1.default(this.ops);
                    const otherIter = new OpIterator_1.default(other.ops);
                    const delta = new Delta;
                    while (thisIter.hasNext() || otherIter.hasNext()) if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) delta.retain(Op_1.default.length(thisIter.next())); else if (otherIter.peekType() === "insert") delta.push(otherIter.next()); else {
                        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                        const thisOp = thisIter.next(length);
                        const otherOp = otherIter.next(length);
                        if (thisOp.delete) continue; else if (otherOp.delete) delta.push(otherOp); else {
                            const thisData = thisOp.retain;
                            const otherData = otherOp.retain;
                            let transformedData = typeof otherData === "object" && otherData !== null ? otherData : length;
                            if (typeof thisData === "object" && thisData !== null && typeof otherData === "object" && otherData !== null) {
                                const embedType = Object.keys(thisData)[0];
                                if (embedType === Object.keys(otherData)[0]) {
                                    const handler = Delta.getHandler(embedType);
                                    if (handler) transformedData = {
                                        [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority)
                                    };
                                }
                            }
                            delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));
                        }
                    }
                    return delta.chop();
                }
                transformPosition(index, priority = false) {
                    priority = !!priority;
                    const thisIter = new OpIterator_1.default(this.ops);
                    let offset = 0;
                    while (thisIter.hasNext() && offset <= index) {
                        const length = thisIter.peekLength();
                        const nextType = thisIter.peekType();
                        thisIter.next();
                        if (nextType === "delete") {
                            index -= Math.min(length, index - offset);
                            continue;
                        } else if (nextType === "insert" && (offset < index || !priority)) index += length;
                        offset += length;
                    }
                    return index;
                }
            }
            Delta.Op = Op_1.default;
            Delta.OpIterator = OpIterator_1.default;
            Delta.AttributeMap = AttributeMap_1.default;
            Delta.handlers = {};
            exports["default"] = Delta;
            if (true) {
                module.exports = Delta;
                module.exports["default"] = Delta;
            }
        },
        759: (__unused_webpack_module, exports) => {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var Op;
            (function(Op) {
                function length(op) {
                    if (typeof op.delete === "number") return op.delete; else if (typeof op.retain === "number") return op.retain; else if (typeof op.retain === "object" && op.retain !== null) return 1; else return typeof op.insert === "string" ? op.insert.length : 1;
                }
                Op.length = length;
            })(Op || (Op = {}));
            exports["default"] = Op;
        },
        317: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            const Op_1 = __webpack_require__(759);
            class Iterator {
                constructor(ops) {
                    this.ops = ops;
                    this.index = 0;
                    this.offset = 0;
                }
                hasNext() {
                    return this.peekLength() < 1 / 0;
                }
                next(length) {
                    if (!length) length = 1 / 0;
                    const nextOp = this.ops[this.index];
                    if (nextOp) {
                        const offset = this.offset;
                        const opLength = Op_1.default.length(nextOp);
                        if (length >= opLength - offset) {
                            length = opLength - offset;
                            this.index += 1;
                            this.offset = 0;
                        } else this.offset += length;
                        if (typeof nextOp.delete === "number") return {
                            delete: length
                        }; else {
                            const retOp = {};
                            if (nextOp.attributes) retOp.attributes = nextOp.attributes;
                            if (typeof nextOp.retain === "number") retOp.retain = length; else if (typeof nextOp.retain === "object" && nextOp.retain !== null) retOp.retain = nextOp.retain; else if (typeof nextOp.insert === "string") retOp.insert = nextOp.insert.substr(offset, length); else retOp.insert = nextOp.insert;
                            return retOp;
                        }
                    } else return {
                        retain: 1 / 0
                    };
                }
                peek() {
                    return this.ops[this.index];
                }
                peekLength() {
                    if (this.ops[this.index]) return Op_1.default.length(this.ops[this.index]) - this.offset; else return 1 / 0;
                }
                peekType() {
                    const op = this.ops[this.index];
                    if (op) if (typeof op.delete === "number") return "delete"; else if (typeof op.retain === "number" || typeof op.retain === "object" && op.retain !== null) return "retain"; else return "insert";
                    return "retain";
                }
                rest() {
                    if (!this.hasNext()) return []; else if (this.offset === 0) return this.ops.slice(this.index); else {
                        const offset = this.offset;
                        const index = this.index;
                        const next = this.next();
                        const rest = this.ops.slice(this.index);
                        this.offset = offset;
                        this.index = index;
                        return [ next ].concat(rest);
                    }
                }
            }
            exports["default"] = Iterator;
        },
        697: module => {
            "use strict";
            var has = Object.prototype.hasOwnProperty, prefix = "~";
            function Events() {}
            if (Object.create) {
                Events.prototype = Object.create(null);
                if (!(new Events).__proto__) prefix = false;
            }
            function EE(fn, context, once) {
                this.fn = fn;
                this.context = context;
                this.once = once || false;
            }
            function addListener(emitter, event, fn, context, once) {
                if (typeof fn !== "function") throw new TypeError("The listener must be a function");
                var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
                if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++; else if (!emitter._events[evt].fn) emitter._events[evt].push(listener); else emitter._events[evt] = [ emitter._events[evt], listener ];
                return emitter;
            }
            function clearEvent(emitter, evt) {
                if (--emitter._eventsCount === 0) emitter._events = new Events; else delete emitter._events[evt];
            }
            function EventEmitter() {
                this._events = new Events;
                this._eventsCount = 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
                var events, name, names = [];
                if (this._eventsCount === 0) return names;
                for (name in events = this._events) if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
                if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
                return names;
            };
            EventEmitter.prototype.listeners = function listeners(event) {
                var evt = prefix ? prefix + event : event, handlers = this._events[evt];
                if (!handlers) return [];
                if (handlers.fn) return [ handlers.fn ];
                for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn;
                return ee;
            };
            EventEmitter.prototype.listenerCount = function listenerCount(event) {
                var evt = prefix ? prefix + event : event, listeners = this._events[evt];
                if (!listeners) return 0;
                if (listeners.fn) return 1;
                return listeners.length;
            };
            EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt]) return false;
                var args, i, listeners = this._events[evt], len = arguments.length;
                if (listeners.fn) {
                    if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
                    switch (len) {
                      case 1:
                        return listeners.fn.call(listeners.context), true;

                      case 2:
                        return listeners.fn.call(listeners.context, a1), true;

                      case 3:
                        return listeners.fn.call(listeners.context, a1, a2), true;

                      case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), true;

                      case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

                      case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                    }
                    for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
                    listeners.fn.apply(listeners.context, args);
                } else {
                    var j, length = listeners.length;
                    for (i = 0; i < length; i++) {
                        if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
                        switch (len) {
                          case 1:
                            listeners[i].fn.call(listeners[i].context);
                            break;

                          case 2:
                            listeners[i].fn.call(listeners[i].context, a1);
                            break;

                          case 3:
                            listeners[i].fn.call(listeners[i].context, a1, a2);
                            break;

                          case 4:
                            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                            break;

                          default:
                            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
                            listeners[i].fn.apply(listeners[i].context, args);
                        }
                    }
                }
                return true;
            };
            EventEmitter.prototype.on = function on(event, fn, context) {
                return addListener(this, event, fn, context, false);
            };
            EventEmitter.prototype.once = function once(event, fn, context) {
                return addListener(this, event, fn, context, true);
            };
            EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt]) return this;
                if (!fn) {
                    clearEvent(this, evt);
                    return this;
                }
                var listeners = this._events[evt];
                if (listeners.fn) {
                    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
                } else {
                    for (var i = 0, events = [], length = listeners.length; i < length; i++) if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
                    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events; else clearEvent(this, evt);
                }
                return this;
            };
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                var evt;
                if (event) {
                    evt = prefix ? prefix + event : event;
                    if (this._events[evt]) clearEvent(this, evt);
                } else {
                    this._events = new Events;
                    this._eventsCount = 0;
                }
                return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.addListener = EventEmitter.prototype.on;
            EventEmitter.prefixed = prefix;
            EventEmitter.EventEmitter = EventEmitter;
            if (true) module.exports = EventEmitter;
        },
        144: function(module) {
            !function(e, t) {
                true ? module.exports = t() : 0;
            }(0, (function() {
                "use strict";
                const e = "undefined" != typeof window, t = e && !("onscroll" in window) || "undefined" != typeof navigator && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent), a = e && window.devicePixelRatio > 1, n = {
                    elements_selector: ".lazy",
                    container: t || e ? document : null,
                    threshold: 300,
                    thresholds: null,
                    data_src: "src",
                    data_srcset: "srcset",
                    data_sizes: "sizes",
                    data_bg: "bg",
                    data_bg_hidpi: "bg-hidpi",
                    data_bg_multi: "bg-multi",
                    data_bg_multi_hidpi: "bg-multi-hidpi",
                    data_bg_set: "bg-set",
                    data_poster: "poster",
                    class_applied: "applied",
                    class_loading: "loading",
                    class_loaded: "loaded",
                    class_error: "error",
                    class_entered: "entered",
                    class_exited: "exited",
                    unobserve_completed: !0,
                    unobserve_entered: !1,
                    cancel_on_exit: !0,
                    callback_enter: null,
                    callback_exit: null,
                    callback_applied: null,
                    callback_loading: null,
                    callback_loaded: null,
                    callback_error: null,
                    callback_finish: null,
                    callback_cancel: null,
                    use_native: !1,
                    restore_on_error: !1
                }, s = e => Object.assign({}, n, e), l = function(e, t) {
                    let a;
                    const n = "LazyLoad::Initialized", s = new e(t);
                    try {
                        a = new CustomEvent(n, {
                            detail: {
                                instance: s
                            }
                        });
                    } catch (e) {
                        a = document.createEvent("CustomEvent"), a.initCustomEvent(n, !1, !1, {
                            instance: s
                        });
                    }
                    window.dispatchEvent(a);
                }, o = "src", r = "srcset", i = "sizes", d = "poster", c = "llOriginalAttrs", _ = "data", u = "loading", g = "loaded", b = "applied", h = "error", m = "native", p = "data-", f = "ll-status", v = (e, t) => e.getAttribute(p + t), E = e => v(e, f), I = (e, t) => ((e, t, a) => {
                    const n = p + t;
                    null !== a ? e.setAttribute(n, a) : e.removeAttribute(n);
                })(e, f, t), y = e => I(e, null), k = e => null === E(e), A = e => E(e) === m, L = [ u, g, b, h ], w = (e, t, a, n) => {
                    e && "function" == typeof e && (void 0 === n ? void 0 === a ? e(t) : e(t, a) : e(t, a, n));
                }, x = (t, a) => {
                    e && "" !== a && t.classList.add(a);
                }, C = (t, a) => {
                    e && "" !== a && t.classList.remove(a);
                }, O = e => e.llTempImage, M = (e, t) => {
                    if (!t) return;
                    const a = t._observer;
                    a && a.unobserve(e);
                }, z = (e, t) => {
                    e && (e.loadingCount += t);
                }, N = (e, t) => {
                    e && (e.toLoadCount = t);
                }, T = e => {
                    let t = [];
                    for (let a, n = 0; a = e.children[n]; n += 1) "SOURCE" === a.tagName && t.push(a);
                    return t;
                }, R = (e, t) => {
                    const a = e.parentNode;
                    a && "PICTURE" === a.tagName && T(a).forEach(t);
                }, G = (e, t) => {
                    T(e).forEach(t);
                }, D = [ o ], H = [ o, d ], V = [ o, r, i ], F = [ _ ], j = e => !!e[c], B = e => e[c], J = e => delete e[c], S = (e, t) => {
                    if (j(e)) return;
                    const a = {};
                    t.forEach((t => {
                        a[t] = e.getAttribute(t);
                    })), e[c] = a;
                }, P = (e, t) => {
                    if (!j(e)) return;
                    const a = B(e);
                    t.forEach((t => {
                        ((e, t, a) => {
                            a ? e.setAttribute(t, a) : e.removeAttribute(t);
                        })(e, t, a[t]);
                    }));
                }, U = (e, t, a) => {
                    x(e, t.class_applied), I(e, b), a && (t.unobserve_completed && M(e, t), w(t.callback_applied, e, a));
                }, $ = (e, t, a) => {
                    x(e, t.class_loading), I(e, u), a && (z(a, 1), w(t.callback_loading, e, a));
                }, q = (e, t, a) => {
                    a && e.setAttribute(t, a);
                }, K = (e, t) => {
                    q(e, i, v(e, t.data_sizes)), q(e, r, v(e, t.data_srcset)), q(e, o, v(e, t.data_src));
                }, Q = {
                    IMG: (e, t) => {
                        R(e, (e => {
                            S(e, V), K(e, t);
                        })), S(e, V), K(e, t);
                    },
                    IFRAME: (e, t) => {
                        S(e, D), q(e, o, v(e, t.data_src));
                    },
                    VIDEO: (e, t) => {
                        G(e, (e => {
                            S(e, D), q(e, o, v(e, t.data_src));
                        })), S(e, H), q(e, d, v(e, t.data_poster)), q(e, o, v(e, t.data_src)), e.load();
                    },
                    OBJECT: (e, t) => {
                        S(e, F), q(e, _, v(e, t.data_src));
                    }
                }, W = [ "IMG", "IFRAME", "VIDEO", "OBJECT" ], X = (e, t) => {
                    !t || (e => e.loadingCount > 0)(t) || (e => e.toLoadCount > 0)(t) || w(e.callback_finish, t);
                }, Y = (e, t, a) => {
                    e.addEventListener(t, a), e.llEvLisnrs[t] = a;
                }, Z = (e, t, a) => {
                    e.removeEventListener(t, a);
                }, ee = e => !!e.llEvLisnrs, te = e => {
                    if (!ee(e)) return;
                    const t = e.llEvLisnrs;
                    for (let a in t) {
                        const n = t[a];
                        Z(e, a, n);
                    }
                    delete e.llEvLisnrs;
                }, ae = (e, t, a) => {
                    (e => {
                        delete e.llTempImage;
                    })(e), z(a, -1), (e => {
                        e && (e.toLoadCount -= 1);
                    })(a), C(e, t.class_loading), t.unobserve_completed && M(e, a);
                }, ne = (e, t, a) => {
                    const n = O(e) || e;
                    ee(n) || ((e, t, a) => {
                        ee(e) || (e.llEvLisnrs = {});
                        const n = "VIDEO" === e.tagName ? "loadeddata" : "load";
                        Y(e, n, t), Y(e, "error", a);
                    })(n, (s => {
                        ((e, t, a, n) => {
                            const s = A(t);
                            ae(t, a, n), x(t, a.class_loaded), I(t, g), w(a.callback_loaded, t, n), s || X(a, n);
                        })(0, e, t, a), te(n);
                    }), (s => {
                        ((e, t, a, n) => {
                            const s = A(t);
                            ae(t, a, n), x(t, a.class_error), I(t, h), w(a.callback_error, t, n), a.restore_on_error && P(t, V), 
                            s || X(a, n);
                        })(0, e, t, a), te(n);
                    }));
                }, se = (e, t, n) => {
                    (e => W.indexOf(e.tagName) > -1)(e) ? ((e, t, a) => {
                        ne(e, t, a), ((e, t, a) => {
                            const n = Q[e.tagName];
                            n && (n(e, t), $(e, t, a));
                        })(e, t, a);
                    })(e, t, n) : ((e, t, n) => {
                        (e => {
                            e.llTempImage = document.createElement("IMG");
                        })(e), ne(e, t, n), (e => {
                            j(e) || (e[c] = {
                                backgroundImage: e.style.backgroundImage
                            });
                        })(e), ((e, t, n) => {
                            const s = v(e, t.data_bg), l = v(e, t.data_bg_hidpi), r = a && l ? l : s;
                            r && (e.style.backgroundImage = `url("${r}")`, O(e).setAttribute(o, r), $(e, t, n));
                        })(e, t, n), ((e, t, n) => {
                            const s = v(e, t.data_bg_multi), l = v(e, t.data_bg_multi_hidpi), o = a && l ? l : s;
                            o && (e.style.backgroundImage = o, U(e, t, n));
                        })(e, t, n), ((e, t, a) => {
                            const n = v(e, t.data_bg_set);
                            if (!n) return;
                            let s = n.split("|").map((e => `image-set(${e})`));
                            e.style.backgroundImage = s.join(), U(e, t, a);
                        })(e, t, n);
                    })(e, t, n);
                }, le = e => {
                    e.removeAttribute(o), e.removeAttribute(r), e.removeAttribute(i);
                }, oe = e => {
                    R(e, (e => {
                        P(e, V);
                    })), P(e, V);
                }, re = {
                    IMG: oe,
                    IFRAME: e => {
                        P(e, D);
                    },
                    VIDEO: e => {
                        G(e, (e => {
                            P(e, D);
                        })), P(e, H), e.load();
                    },
                    OBJECT: e => {
                        P(e, F);
                    }
                }, ie = (e, t) => {
                    (e => {
                        const t = re[e.tagName];
                        t ? t(e) : (e => {
                            if (!j(e)) return;
                            const t = B(e);
                            e.style.backgroundImage = t.backgroundImage;
                        })(e);
                    })(e), ((e, t) => {
                        k(e) || A(e) || (C(e, t.class_entered), C(e, t.class_exited), C(e, t.class_applied), 
                        C(e, t.class_loading), C(e, t.class_loaded), C(e, t.class_error));
                    })(e, t), y(e), J(e);
                }, de = [ "IMG", "IFRAME", "VIDEO" ], ce = e => e.use_native && "loading" in HTMLImageElement.prototype, _e = (e, t, a) => {
                    e.forEach((e => (e => e.isIntersecting || e.intersectionRatio > 0)(e) ? ((e, t, a, n) => {
                        const s = (e => L.indexOf(E(e)) >= 0)(e);
                        I(e, "entered"), x(e, a.class_entered), C(e, a.class_exited), ((e, t, a) => {
                            t.unobserve_entered && M(e, a);
                        })(e, a, n), w(a.callback_enter, e, t, n), s || se(e, a, n);
                    })(e.target, e, t, a) : ((e, t, a, n) => {
                        k(e) || (x(e, a.class_exited), ((e, t, a, n) => {
                            a.cancel_on_exit && (e => E(e) === u)(e) && "IMG" === e.tagName && (te(e), (e => {
                                R(e, (e => {
                                    le(e);
                                })), le(e);
                            })(e), oe(e), C(e, a.class_loading), z(n, -1), y(e), w(a.callback_cancel, e, t, n));
                        })(e, t, a, n), w(a.callback_exit, e, t, n));
                    })(e.target, e, t, a)));
                }, ue = e => Array.prototype.slice.call(e), ge = e => e.container.querySelectorAll(e.elements_selector), be = e => (e => E(e) === h)(e), he = (e, t) => (e => ue(e).filter(k))(e || ge(t)), me = function(t, a) {
                    const n = s(t);
                    this._settings = n, this.loadingCount = 0, ((e, t) => {
                        ce(e) || (t._observer = new IntersectionObserver((a => {
                            _e(a, e, t);
                        }), (e => ({
                            root: e.container === document ? null : e.container,
                            rootMargin: e.thresholds || e.threshold + "px"
                        }))(e)));
                    })(n, this), ((t, a) => {
                        e && (a._onlineHandler = () => {
                            ((e, t) => {
                                var a;
                                (a = ge(e), ue(a).filter(be)).forEach((t => {
                                    C(t, e.class_error), y(t);
                                })), t.update();
                            })(t, a);
                        }, window.addEventListener("online", a._onlineHandler));
                    })(n, this), this.update(a);
                };
                return me.prototype = {
                    update: function(e) {
                        const a = this._settings, n = he(e, a);
                        var s, l;
                        N(this, n.length), t ? this.loadAll(n) : ce(a) ? ((e, t, a) => {
                            e.forEach((e => {
                                -1 !== de.indexOf(e.tagName) && ((e, t, a) => {
                                    e.setAttribute("loading", "lazy"), ne(e, t, a), ((e, t) => {
                                        const a = Q[e.tagName];
                                        a && a(e, t);
                                    })(e, t), I(e, m);
                                })(e, t, a);
                            })), N(a, 0);
                        })(n, a, this) : (l = n, (e => {
                            e.disconnect();
                        })(s = this._observer), ((e, t) => {
                            t.forEach((t => {
                                e.observe(t);
                            }));
                        })(s, l));
                    },
                    destroy: function() {
                        this._observer && this._observer.disconnect(), e && window.removeEventListener("online", this._onlineHandler), 
                        ge(this._settings).forEach((e => {
                            J(e);
                        })), delete this._observer, delete this._settings, delete this._onlineHandler, delete this.loadingCount, 
                        delete this.toLoadCount;
                    },
                    loadAll: function(e) {
                        const t = this._settings;
                        he(e, t).forEach((e => {
                            M(e, this), se(e, t, this);
                        }));
                    },
                    restoreAll: function() {
                        const e = this._settings;
                        ge(e).forEach((t => {
                            ie(t, e);
                        }));
                    }
                }, me.load = (e, t) => {
                    const a = s(t);
                    se(e, a);
                }, me.resetStatus = e => {
                    y(e);
                }, e && ((e, t) => {
                    if (t) if (t.length) for (let a, n = 0; a = t[n]; n += 1) l(e, a); else l(e, t);
                })(me, window.lazyLoadOptions), me;
            }));
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            loaded: false,
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
    }
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.g = function() {
            if (typeof globalThis === "object") return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if (typeof window === "object") return window;
            }
        }();
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        __webpack_require__.r = exports => {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            });
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
        };
    })();
    (() => {
        __webpack_require__.nmd = module => {
            module.paths = [];
            if (!module.children) module.children = [];
            return module;
        };
    })();
    (() => {
        "use strict";
        var parchment_namespaceObject = {};
        __webpack_require__.r(parchment_namespaceObject);
        __webpack_require__.d(parchment_namespaceObject, {
            Attributor: () => Attributor,
            AttributorStore: () => AttributorStore$1,
            BlockBlot: () => BlockBlot$1,
            ClassAttributor: () => ClassAttributor$1,
            ContainerBlot: () => ContainerBlot$1,
            EmbedBlot: () => EmbedBlot$1,
            InlineBlot: () => InlineBlot$1,
            LeafBlot: () => LeafBlot$1,
            ParentBlot: () => ParentBlot$1,
            Registry: () => Registry,
            Scope: () => Scope,
            ScrollBlot: () => ScrollBlot$1,
            StyleAttributor: () => StyleAttributor$1,
            TextBlot: () => TextBlot$1
        });
        const modules_flsModules = {};
        function addLoadedClass() {
            if (!document.documentElement.classList.contains("loading")) window.addEventListener("load", (function() {
                setTimeout((function() {
                    document.documentElement.classList.add("loaded");
                }), 0);
            }));
        }
        function functions_getHash() {
            if (location.hash) return location.hash.replace("#", "");
        }
        function setHash(hash) {
            hash = hash ? `#${hash}` : window.location.href.split("#")[0];
            history.pushState("", "", hash);
        }
        let _slideUp = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = `${target.offsetHeight}px`;
                target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    !showmore ? target.style.removeProperty("height") : null;
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideDown = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty("height") : null;
                let height = target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                target.offsetHeight;
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = height + "px";
                target.style.removeProperty("padding-top");
                target.style.removeProperty("padding-bottom");
                target.style.removeProperty("margin-top");
                target.style.removeProperty("margin-bottom");
                window.setTimeout((() => {
                    target.style.removeProperty("height");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideToggle = (target, duration = 500) => {
            if (target.hidden) return _slideDown(target, duration); else return _slideUp(target, duration);
        };
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 500) => {
            if (bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    lockPaddingElements.forEach((lockPaddingElement => {
                        lockPaddingElement.style.paddingRight = "";
                    }));
                    document.body.style.paddingRight = "";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            if (bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                const lockPaddingValue = window.innerWidth - document.body.offsetWidth + "px";
                lockPaddingElements.forEach((lockPaddingElement => {
                    lockPaddingElement.style.paddingRight = lockPaddingValue;
                }));
                document.body.style.paddingRight = lockPaddingValue;
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function spollers() {
            const spollersArray = document.querySelectorAll("[data-spollers]");
            if (spollersArray.length > 0) {
                document.addEventListener("click", setSpollerAction);
                const spollersRegular = Array.from(spollersArray).filter((function(item, index, self) {
                    return !item.dataset.spollers.split(",")[0];
                }));
                if (spollersRegular.length) initSpollers(spollersRegular);
                let mdQueriesArray = dataMediaQueries(spollersArray, "spollers");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
                function initSpollers(spollersArray, matchMedia = false) {
                    spollersArray.forEach((spollersBlock => {
                        spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;
                        if (matchMedia.matches || !matchMedia) {
                            spollersBlock.classList.add("_spoller-init");
                            initSpollerBody(spollersBlock);
                        } else {
                            spollersBlock.classList.remove("_spoller-init");
                            initSpollerBody(spollersBlock, false);
                        }
                    }));
                }
                function initSpollerBody(spollersBlock, hideSpollerBody = false) {
                    let spollerItems = spollersBlock.querySelectorAll("details");
                    if (spollerItems.length) spollerItems.forEach((spollerItem => {
                        let spollerTitle = spollerItem.querySelector("summary");
                        if (hideSpollerBody) {
                            spollerTitle.removeAttribute("tabindex");
                            if (!spollerItem.hasAttribute("data-open")) {
                                spollerItem.open = false;
                                spollerTitle.nextElementSibling.hidden = true;
                            } else {
                                spollerTitle.classList.add("_spoller-active");
                                spollerItem.open = true;
                            }
                        } else {
                            spollerTitle.setAttribute("tabindex", "-1");
                            spollerTitle.classList.remove("_spoller-active");
                            spollerItem.open = true;
                            spollerTitle.nextElementSibling.hidden = false;
                        }
                    }));
                }
                function setSpollerAction(e) {
                    const el = e.target;
                    if (el.closest("summary") && el.closest("[data-spollers]")) {
                        e.preventDefault();
                        if (el.closest("[data-spollers]").classList.contains("_spoller-init")) {
                            const spollerTitle = el.closest("summary");
                            const spollerBlock = spollerTitle.closest("details");
                            const spollersBlock = spollerTitle.closest("[data-spollers]");
                            const oneSpoller = spollersBlock.hasAttribute("data-one-spoller");
                            const scrollSpoller = spollerBlock.hasAttribute("data-spoller-scroll");
                            const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                            if (!spollersBlock.querySelectorAll("._slide").length) {
                                if (oneSpoller && !spollerBlock.open) hideSpollersBody(spollersBlock);
                                !spollerBlock.open ? spollerBlock.open = true : setTimeout((() => {
                                    spollerBlock.open = false;
                                }), spollerSpeed);
                                spollerTitle.classList.toggle("_spoller-active");
                                _slideToggle(spollerTitle.nextElementSibling, spollerSpeed);
                                if (scrollSpoller && spollerTitle.classList.contains("_spoller-active")) {
                                    const scrollSpollerValue = spollerBlock.dataset.spollerScroll;
                                    const scrollSpollerOffset = +scrollSpollerValue ? +scrollSpollerValue : 0;
                                    const scrollSpollerNoHeader = spollerBlock.hasAttribute("data-spoller-scroll-noheader") ? document.querySelector(".header").offsetHeight : 0;
                                    window.scrollTo({
                                        top: spollerBlock.offsetTop - (scrollSpollerOffset + scrollSpollerNoHeader),
                                        behavior: "smooth"
                                    });
                                }
                            }
                        }
                    }
                    if (!el.closest("[data-spollers]")) {
                        const spollersClose = document.querySelectorAll("[data-spoller-close]");
                        if (spollersClose.length) spollersClose.forEach((spollerClose => {
                            const spollersBlock = spollerClose.closest("[data-spollers]");
                            const spollerCloseBlock = spollerClose.parentNode;
                            if (spollersBlock.classList.contains("_spoller-init")) {
                                const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                                spollerClose.classList.remove("_spoller-active");
                                _slideUp(spollerClose.nextElementSibling, spollerSpeed);
                                setTimeout((() => {
                                    spollerCloseBlock.open = false;
                                }), spollerSpeed);
                            }
                        }));
                    }
                }
                function hideSpollersBody(spollersBlock) {
                    const spollerActiveBlock = spollersBlock.querySelector("details[open]");
                    if (spollerActiveBlock && !spollersBlock.querySelectorAll("._slide").length) {
                        const spollerActiveTitle = spollerActiveBlock.querySelector("summary");
                        const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                        spollerActiveTitle.classList.remove("_spoller-active");
                        _slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed);
                        setTimeout((() => {
                            spollerActiveBlock.open = false;
                        }), spollerSpeed);
                    }
                }
            }
        }
        function tabs() {
            const tabs = document.querySelectorAll("[data-tabs]");
            let tabsActiveHash = [];
            if (tabs.length > 0) {
                const hash = functions_getHash();
                if (hash && hash.startsWith("tab-")) tabsActiveHash = hash.replace("tab-", "").split("-");
                tabs.forEach(((tabsBlock, index) => {
                    tabsBlock.classList.add("_tab-init");
                    tabsBlock.setAttribute("data-tabs-index", index);
                    tabsBlock.addEventListener("click", setTabsAction);
                    initTabs(tabsBlock);
                }));
                let mdQueriesArray = dataMediaQueries(tabs, "tabs");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
            }
            function setTitlePosition(tabsMediaArray, matchMedia) {
                tabsMediaArray.forEach((tabsMediaItem => {
                    tabsMediaItem = tabsMediaItem.item;
                    let tabsTitles = tabsMediaItem.querySelector("[data-tabs-titles]");
                    let tabsTitleItems = tabsMediaItem.querySelectorAll("[data-tabs-title]");
                    let tabsContent = tabsMediaItem.querySelector("[data-tabs-body]");
                    let tabsContentItems = tabsMediaItem.querySelectorAll("[data-tabs-item]");
                    tabsTitleItems = Array.from(tabsTitleItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems = Array.from(tabsContentItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems.forEach(((tabsContentItem, index) => {
                        if (matchMedia.matches) {
                            tabsContent.append(tabsTitleItems[index]);
                            tabsContent.append(tabsContentItem);
                            tabsMediaItem.classList.add("_tab-spoller");
                        } else {
                            tabsTitles.append(tabsTitleItems[index]);
                            tabsMediaItem.classList.remove("_tab-spoller");
                        }
                    }));
                }));
            }
            function initTabs(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-titles]>*");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-body]>*");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                const tabsActiveHashBlock = tabsActiveHash[0] == tabsBlockIndex;
                if (tabsActiveHashBlock) {
                    const tabsActiveTitle = tabsBlock.querySelector("[data-tabs-titles]>._tab-active");
                    tabsActiveTitle ? tabsActiveTitle.classList.remove("_tab-active") : null;
                }
                if (tabsContent.length) tabsContent.forEach(((tabsContentItem, index) => {
                    tabsTitles[index].setAttribute("data-tabs-title", "");
                    tabsContentItem.setAttribute("data-tabs-item", "");
                    if (tabsActiveHashBlock && index == tabsActiveHash[1]) tabsTitles[index].classList.add("_tab-active");
                    tabsContentItem.hidden = !tabsTitles[index].classList.contains("_tab-active");
                }));
            }
            function setTabsStatus(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-title]");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-item]");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                function isTabsAnamate(tabsBlock) {
                    if (tabsBlock.hasAttribute("data-tabs-animate")) return tabsBlock.dataset.tabsAnimate > 0 ? Number(tabsBlock.dataset.tabsAnimate) : 500;
                }
                const tabsBlockAnimate = isTabsAnamate(tabsBlock);
                if (tabsContent.length > 0) {
                    const isHash = tabsBlock.hasAttribute("data-tabs-hash");
                    tabsContent = Array.from(tabsContent).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsTitles = Array.from(tabsTitles).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsContent.forEach(((tabsContentItem, index) => {
                        if (tabsTitles[index].classList.contains("_tab-active")) {
                            if (tabsBlockAnimate) _slideDown(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = false;
                            if (isHash && !tabsContentItem.closest(".popup")) setHash(`tab-${tabsBlockIndex}-${index}`);
                        } else if (tabsBlockAnimate) _slideUp(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = true;
                    }));
                }
            }
            function setTabsAction(e) {
                const el = e.target;
                if (el.closest("[data-tabs-title]")) {
                    const tabTitle = el.closest("[data-tabs-title]");
                    const tabsBlock = tabTitle.closest("[data-tabs]");
                    if (!tabTitle.classList.contains("_tab-active") && !tabsBlock.querySelector("._slide")) {
                        let tabActiveTitle = tabsBlock.querySelectorAll("[data-tabs-title]._tab-active");
                        tabActiveTitle.length ? tabActiveTitle = Array.from(tabActiveTitle).filter((item => item.closest("[data-tabs]") === tabsBlock)) : null;
                        tabActiveTitle.length ? tabActiveTitle[0].classList.remove("_tab-active") : null;
                        tabTitle.classList.add("_tab-active");
                        setTabsStatus(tabsBlock);
                    }
                    e.preventDefault();
                }
            }
        }
        function menuInit() {
            if (document.querySelector(".icon-menu")) document.addEventListener("click", (function(e) {
                if (bodyLockStatus && e.target.closest(".icon-menu")) {
                    if (window.innerWidth <= 767.98) bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function functions_menuClose() {
            if (window.innerWidth <= 767.98) bodyUnlock();
            document.documentElement.classList.remove("menu-open");
        }
        function FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        function uniqArray(array) {
            return array.filter((function(item, index, self) {
                return self.indexOf(item) === index;
            }));
        }
        function dataMediaQueries(array, dataSetValue) {
            const media = Array.from(array).filter((function(item, index, self) {
                if (item.dataset[dataSetValue]) return item.dataset[dataSetValue].split(",")[0];
            }));
            if (media.length) {
                const breakpointsArray = [];
                media.forEach((item => {
                    const params = item.dataset[dataSetValue];
                    const breakpoint = {};
                    const paramsArray = params.split(",");
                    breakpoint.value = paramsArray[0];
                    breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
                    breakpoint.item = item;
                    breakpointsArray.push(breakpoint);
                }));
                let mdQueries = breakpointsArray.map((function(item) {
                    return "(" + item.type + "-width: " + item.value + "px)," + item.value + "," + item.type;
                }));
                mdQueries = uniqArray(mdQueries);
                const mdQueriesArray = [];
                if (mdQueries.length) {
                    mdQueries.forEach((breakpoint => {
                        const paramsArray = breakpoint.split(",");
                        const mediaBreakpoint = paramsArray[1];
                        const mediaType = paramsArray[2];
                        const matchMedia = window.matchMedia(paramsArray[0]);
                        const itemsArray = breakpointsArray.filter((function(item) {
                            if (item.value === mediaBreakpoint && item.type === mediaType) return true;
                        }));
                        mdQueriesArray.push({
                            itemsArray,
                            matchMedia
                        });
                    }));
                    return mdQueriesArray;
                }
            }
        }
        class Popup {
            constructor(options) {
                let config = {
                    logging: true,
                    init: true,
                    attributeOpenButton: "data-popup",
                    attributeCloseButton: "data-close",
                    fixElementSelector: "[data-lp]",
                    youtubeAttribute: "data-popup-youtube",
                    youtubePlaceAttribute: "data-popup-youtube-place",
                    setAutoplayYoutube: true,
                    classes: {
                        popup: "popup",
                        popupContent: "popup__content",
                        popupActive: "popup_show",
                        bodyActive: "popup-show"
                    },
                    focusCatch: true,
                    closeEsc: true,
                    bodyLock: true,
                    hashSettings: {
                        location: true,
                        goHash: true
                    },
                    on: {
                        beforeOpen: function() {},
                        afterOpen: function() {},
                        beforeClose: function() {},
                        afterClose: function() {}
                    }
                };
                this.youTubeCode;
                this.isOpen = false;
                this.targetOpen = {
                    selector: false,
                    element: false
                };
                this.previousOpen = {
                    selector: false,
                    element: false
                };
                this.lastClosed = {
                    selector: false,
                    element: false
                };
                this._dataValue = false;
                this.hash = false;
                this._reopen = false;
                this._selectorOpen = false;
                this.lastFocusEl = false;
                this._focusEl = [ "a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])' ];
                this.options = {
                    ...config,
                    ...options,
                    classes: {
                        ...config.classes,
                        ...options?.classes
                    },
                    hashSettings: {
                        ...config.hashSettings,
                        ...options?.hashSettings
                    },
                    on: {
                        ...config.on,
                        ...options?.on
                    }
                };
                this.bodyLock = false;
                this.options.init ? this.initPopups() : null;
            }
            initPopups() {
                this.popupLogging(`Прокинувся`);
                this.eventsPopup();
            }
            eventsPopup() {
                document.addEventListener("click", function(e) {
                    const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
                    if (buttonOpen) {
                        e.preventDefault();
                        this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
                        this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
                        if (this._dataValue !== "error") {
                            if (!this.isOpen) this.lastFocusEl = buttonOpen;
                            this.targetOpen.selector = `${this._dataValue}`;
                            this._selectorOpen = true;
                            this.open();
                            return;
                        } else this.popupLogging(`Йой, не заповнено атрибут у ${buttonOpen.classList}`);
                        return;
                    }
                    const buttonCancel = e.target.closest(".slim-btn-cancel");
                    const buttonConfirm = e.target.closest(".slim-btn-confirm");
                    if (buttonCancel || buttonConfirm) {
                        e.stopPropagation();
                        e.preventDefault();
                        return;
                    }
                    const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
                    if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    if (this.options.closeEsc && e.which == 27 && e.code === "Escape" && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                    if (this.options.focusCatch && e.which == 9 && this.isOpen) {
                        this._focusCatch(e);
                        return;
                    }
                }.bind(this));
                if (this.options.hashSettings.goHash) {
                    window.addEventListener("hashchange", function() {
                        if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
                    }.bind(this));
                    window.addEventListener("load", function() {
                        if (window.location.hash) this._openToHash();
                    }.bind(this));
                }
            }
            open(selectorValue) {
                if (bodyLockStatus) {
                    this.bodyLock = document.documentElement.classList.contains("lock") && !this.isOpen ? true : false;
                    if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") {
                        this.targetOpen.selector = selectorValue;
                        this._selectorOpen = true;
                    }
                    if (this.isOpen) {
                        this._reopen = true;
                        this.close();
                    }
                    if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
                    if (!this._reopen) this.previousActiveElement = document.activeElement;
                    this.targetOpen.element = document.querySelector(this.targetOpen.selector);
                    if (this.targetOpen.element) {
                        if (this.youTubeCode) {
                            const codeVideo = this.youTubeCode;
                            const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                            const iframe = document.createElement("iframe");
                            iframe.setAttribute("allowfullscreen", "");
                            const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
                            iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
                            iframe.setAttribute("src", urlVideo);
                            if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
                                this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
                            }
                            this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
                        }
                        if (this.options.hashSettings.location) {
                            this._getHash();
                            this._setHash();
                        }
                        this.options.on.beforeOpen(this);
                        document.dispatchEvent(new CustomEvent("beforePopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.targetOpen.element.classList.add(this.options.classes.popupActive);
                        document.documentElement.classList.add(this.options.classes.bodyActive);
                        if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
                        this.targetOpen.element.setAttribute("aria-hidden", "false");
                        this.previousOpen.selector = this.targetOpen.selector;
                        this.previousOpen.element = this.targetOpen.element;
                        this._selectorOpen = false;
                        this.isOpen = true;
                        setTimeout((() => {
                            this._focusTrap();
                        }), 50);
                        this.options.on.afterOpen(this);
                        document.dispatchEvent(new CustomEvent("afterPopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.popupLogging(`Відкрив попап`);
                    } else this.popupLogging(`Йой, такого попапу немає. Перевірте коректність введення. `);
                }
            }
            close(selectorValue) {
                if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") this.previousOpen.selector = selectorValue;
                if (!this.isOpen || !bodyLockStatus) return;
                this.options.on.beforeClose(this);
                document.dispatchEvent(new CustomEvent("beforePopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
                this.previousOpen.element.classList.remove(this.options.classes.popupActive);
                this.previousOpen.element.setAttribute("aria-hidden", "true");
                if (!this._reopen) {
                    document.documentElement.classList.remove(this.options.classes.bodyActive);
                    !this.bodyLock ? bodyUnlock() : null;
                    this.isOpen = false;
                }
                this._removeHash();
                if (this._selectorOpen) {
                    this.lastClosed.selector = this.previousOpen.selector;
                    this.lastClosed.element = this.previousOpen.element;
                }
                this.options.on.afterClose(this);
                document.dispatchEvent(new CustomEvent("afterPopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                setTimeout((() => {
                    this._focusTrap();
                }), 50);
                this.popupLogging(`Закрив попап`);
            }
            _getHash() {
                if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
            }
            _openToHash() {
                let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
                const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
                this.youTubeCode = buttons.getAttribute(this.options.youtubeAttribute) ? buttons.getAttribute(this.options.youtubeAttribute) : null;
                if (buttons && classInHash) this.open(classInHash);
            }
            _setHash() {
                history.pushState("", "", this.hash);
            }
            _removeHash() {
                history.pushState("", "", window.location.href.split("#")[0]);
            }
            _focusCatch(e) {
                const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
                const focusArray = Array.prototype.slice.call(focusable);
                const focusedIndex = focusArray.indexOf(document.activeElement);
                if (e.shiftKey && focusedIndex === 0) {
                    focusArray[focusArray.length - 1].focus();
                    e.preventDefault();
                }
                if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
                    focusArray[0].focus();
                    e.preventDefault();
                }
            }
            _focusTrap() {
                const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
                if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
            }
            popupLogging(message) {
                this.options.logging ? FLS(`[Попапос]: ${message}`) : null;
            }
        }
        modules_flsModules.popup = new Popup({});
        let gotoblock_gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {
            const targetBlockElement = document.querySelector(targetBlock);
            if (targetBlockElement) {
                let headerItem = "";
                let headerItemHeight = 0;
                if (noHeader) {
                    headerItem = "header.header";
                    const headerElement = document.querySelector(headerItem);
                    if (!headerElement.classList.contains("_header-scroll")) {
                        headerElement.style.cssText = `transition-duration: 0s;`;
                        headerElement.classList.add("_header-scroll");
                        headerItemHeight = headerElement.offsetHeight;
                        headerElement.classList.remove("_header-scroll");
                        setTimeout((() => {
                            headerElement.style.cssText = ``;
                        }), 0);
                    } else headerItemHeight = headerElement.offsetHeight;
                }
                let options = {
                    speedAsDuration: true,
                    speed,
                    header: headerItem,
                    offset: offsetTop,
                    easing: "easeOutQuad"
                };
                document.documentElement.classList.contains("menu-open") ? functions_menuClose() : null;
                if (typeof SmoothScroll !== "undefined") (new SmoothScroll).animateScroll(targetBlockElement, "", options); else {
                    let targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;
                    targetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;
                    targetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;
                    window.scrollTo({
                        top: targetBlockElementPosition,
                        behavior: "smooth"
                    });
                }
                FLS(`[gotoBlock]: Юхуу...їдемо до ${targetBlock}`);
            } else FLS(`[gotoBlock]: Йой... Такого блоку немає на сторінці: ${targetBlock}`);
        };
        function formFieldsInit(options = {
            viewPass: false,
            autoHeight: false
        }) {
            document.body.addEventListener("focusin", (function(e) {
                const targetElement = e.target;
                if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
                    if (!targetElement.hasAttribute("data-no-focus-classes")) {
                        targetElement.classList.add("_form-focus");
                        targetElement.parentElement.classList.add("_form-focus");
                    }
                    formValidate.removeError(targetElement);
                    targetElement.hasAttribute("data-validate") ? formValidate.removeError(targetElement) : null;
                }
            }));
            document.body.addEventListener("focusout", (function(e) {
                const targetElement = e.target;
                if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
                    if (!targetElement.hasAttribute("data-no-focus-classes")) {
                        targetElement.classList.remove("_form-focus");
                        targetElement.parentElement.classList.remove("_form-focus");
                    }
                    targetElement.hasAttribute("data-validate") ? formValidate.validateInput(targetElement) : null;
                }
            }));
            if (options.viewPass) document.addEventListener("click", (function(e) {
                let targetElement = e.target;
                if (targetElement.closest('[class*="__viewpass"]')) {
                    let inputType = targetElement.classList.contains("_viewpass-active") ? "password" : "text";
                    targetElement.parentElement.querySelector("input").setAttribute("type", inputType);
                    targetElement.classList.toggle("_viewpass-active");
                }
            }));
            if (options.autoHeight) {
                const textareas = document.querySelectorAll("textarea[data-autoheight]");
                if (textareas.length) {
                    textareas.forEach((textarea => {
                        const startHeight = textarea.hasAttribute("data-autoheight-min") ? Number(textarea.dataset.autoheightMin) : Number(textarea.offsetHeight);
                        const maxHeight = textarea.hasAttribute("data-autoheight-max") ? Number(textarea.dataset.autoheightMax) : 1 / 0;
                        setHeight(textarea, Math.min(startHeight, maxHeight));
                        textarea.addEventListener("input", (() => {
                            if (textarea.scrollHeight > startHeight) {
                                textarea.style.height = `auto`;
                                setHeight(textarea, Math.min(Math.max(textarea.scrollHeight, startHeight), maxHeight));
                            }
                        }));
                    }));
                    function setHeight(textarea, height) {
                        textarea.style.height = `${height}px`;
                    }
                }
            }
        }
        let formValidate = {
            getErrors(form) {
                let error = 0;
                let formRequiredItems = form.querySelectorAll("*[data-required]");
                if (formRequiredItems.length) formRequiredItems.forEach((formRequiredItem => {
                    if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) error += this.validateInput(formRequiredItem);
                }));
                return error;
            },
            validateInput(formRequiredItem) {
                let error = 0;
                if (formRequiredItem.dataset.required === "email") {
                    formRequiredItem.value = formRequiredItem.value.replace(" ", "");
                    if (this.emailTest(formRequiredItem)) {
                        this.addError(formRequiredItem);
                        error++;
                    } else this.removeError(formRequiredItem);
                } else if (formRequiredItem.type === "checkbox" && !formRequiredItem.checked) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (!formRequiredItem.value.trim()) {
                    this.addError(formRequiredItem);
                    error++;
                } else this.removeError(formRequiredItem);
                return error;
            },
            addError(formRequiredItem) {
                formRequiredItem.classList.add("_form-error");
                formRequiredItem.parentElement.classList.add("_form-error");
                let inputError = formRequiredItem.parentElement.querySelector(".form__error");
                if (inputError) formRequiredItem.parentElement.removeChild(inputError);
                if (formRequiredItem.dataset.error) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${formRequiredItem.dataset.error}</div>`);
            },
            removeError(formRequiredItem) {
                formRequiredItem.classList.remove("_form-error");
                formRequiredItem.parentElement.classList.remove("_form-error");
                if (formRequiredItem.parentElement.querySelector(".form__error")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__error"));
            },
            formClean(form) {
                form.reset();
                setTimeout((() => {
                    let inputs = form.querySelectorAll("input,textarea");
                    for (let index = 0; index < inputs.length; index++) {
                        const el = inputs[index];
                        el.parentElement.classList.remove("_form-focus");
                        el.classList.remove("_form-focus");
                        formValidate.removeError(el);
                    }
                    let checkboxes = form.querySelectorAll(".checkbox__input");
                    if (checkboxes.length > 0) for (let index = 0; index < checkboxes.length; index++) {
                        const checkbox = checkboxes[index];
                        checkbox.checked = false;
                    }
                    if (modules_flsModules.select) {
                        let selects = form.querySelectorAll("div.select");
                        if (selects.length) for (let index = 0; index < selects.length; index++) {
                            const select = selects[index].querySelector("select");
                            modules_flsModules.select.selectBuild(select);
                        }
                    }
                }), 0);
            },
            emailTest(formRequiredItem) {
                return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
            }
        };
        function formSubmit() {
            const forms = document.forms;
            if (forms.length) for (const form of forms) {
                form.addEventListener("submit", (function(e) {
                    const form = e.target;
                    formSubmitAction(form, e);
                }));
                form.addEventListener("reset", (function(e) {
                    const form = e.target;
                    formValidate.formClean(form);
                }));
            }
            async function formSubmitAction(form, e) {
                const error = !form.hasAttribute("data-no-validate") ? formValidate.getErrors(form) : 0;
                if (error === 0) {
                    const ajax = form.hasAttribute("data-ajax");
                    if (ajax) {
                        e.preventDefault();
                        const formAction = form.getAttribute("action") ? form.getAttribute("action").trim() : "#";
                        const formMethod = form.getAttribute("method") ? form.getAttribute("method").trim() : "GET";
                        const formData = new FormData(form);
                        form.classList.add("_sending");
                        const response = await fetch(formAction, {
                            method: formMethod,
                            body: formData
                        });
                        if (response.ok) {
                            let responseResult = await response.json();
                            form.classList.remove("_sending");
                            formSent(form, responseResult);
                        } else {
                            alert("Помилка");
                            form.classList.remove("_sending");
                        }
                    } else if (form.hasAttribute("data-dev")) {
                        e.preventDefault();
                        formSent(form);
                    }
                } else {
                    e.preventDefault();
                    if (form.querySelector("._form-error") && form.hasAttribute("data-goto-error")) {
                        const formGoToErrorClass = form.dataset.gotoError ? form.dataset.gotoError : "._form-error";
                        gotoblock_gotoBlock(formGoToErrorClass, true, 1e3);
                    }
                }
            }
            function formSent(form, responseResult = ``) {
                document.dispatchEvent(new CustomEvent("formSent", {
                    detail: {
                        form
                    }
                }));
                setTimeout((() => {
                    if (modules_flsModules.popup) {
                        const popup = form.dataset.popupMessage;
                        popup ? modules_flsModules.popup.open(popup) : null;
                    }
                }), 0);
                formValidate.formClean(form);
                formLogging(`Форму відправлено!`);
            }
            function formLogging(message) {
                FLS(`[Форми]: ${message}`);
            }
        }
        function formRating() {
            const ratings = document.querySelectorAll("[data-rating]");
            if (ratings) ratings.forEach((rating => {
                const ratingValue = +rating.dataset.ratingValue;
                const ratingSize = +rating.dataset.ratingSize ? +rating.dataset.ratingSize : 5;
                formRatingInit(rating, ratingSize);
                ratingValue ? formRatingSet(rating, ratingValue) : null;
                document.addEventListener("click", formRatingAction);
            }));
            function formRatingAction(e) {
                const targetElement = e.target;
                if (targetElement.closest(".rating__input")) {
                    const currentElement = targetElement.closest(".rating__input");
                    const ratingValue = +currentElement.value;
                    const rating = currentElement.closest(".rating");
                    const ratingSet = rating.dataset.rating === "set";
                    ratingSet ? formRatingGet(rating, ratingValue) : null;
                }
            }
            function formRatingInit(rating, ratingSize) {
                let ratingItems = ``;
                for (let index = 0; index < ratingSize; index++) {
                    index === 0 ? ratingItems += `<div class="rating__items">` : null;
                    ratingItems += `\n\t\t\t\t<label class="rating__item">\n\t\t\t\t\t<input class="rating__input" type="radio" name="rating" value="${index + 1}">\n\t\t\t\t</label>`;
                    index === ratingSize ? ratingItems += `</div">` : null;
                }
                rating.insertAdjacentHTML("beforeend", ratingItems);
            }
            function formRatingGet(rating, ratingValue) {
                const resultRating = ratingValue;
                formRatingSet(rating, resultRating);
            }
            function formRatingSet(rating, value) {
                const ratingItems = rating.querySelectorAll(".rating__item");
                const resultFullItems = parseInt(value);
                const resultPartItem = value - resultFullItems;
                rating.hasAttribute("data-rating-title") ? rating.title = value : null;
                ratingItems.forEach(((ratingItem, index) => {
                    ratingItem.classList.remove("rating__item--active");
                    ratingItem.querySelector("span") ? ratingItems[index].querySelector("span").remove() : null;
                    if (index <= resultFullItems - 1) ratingItem.classList.add("rating__item--active");
                    if (index === resultFullItems && resultPartItem) ratingItem.insertAdjacentHTML("beforeend", `<span style="width:${resultPartItem * 100}%"></span>`);
                }));
            }
        }
        class SelectConstructor {
            constructor(props, data = null) {
                let defaultConfig = {
                    init: true,
                    logging: true,
                    speed: 150
                };
                this.config = Object.assign(defaultConfig, props);
                this.selectClasses = {
                    classSelect: "select",
                    classSelectBody: "select__body",
                    classSelectTitle: "select__title",
                    classSelectValue: "select__value",
                    classSelectLabel: "select__label",
                    classSelectInput: "select__input",
                    classSelectText: "select__text",
                    classSelectLink: "select__link",
                    classSelectOptions: "select__options",
                    classSelectOptionsScroll: "select__scroll",
                    classSelectOption: "select__option",
                    classSelectContent: "select__content",
                    classSelectRow: "select__row",
                    classSelectData: "select__asset",
                    classSelectDisabled: "_select-disabled",
                    classSelectTag: "_select-tag",
                    classSelectOpen: "_select-open",
                    classSelectActive: "_select-active",
                    classSelectFocus: "_select-focus",
                    classSelectMultiple: "_select-multiple",
                    classSelectCheckBox: "_select-checkbox",
                    classSelectOptionSelected: "_select-selected",
                    classSelectPseudoLabel: "_select-pseudo-label"
                };
                this._this = this;
                if (this.config.init) {
                    const selectItems = data ? document.querySelectorAll(data) : document.querySelectorAll("select");
                    if (selectItems.length) {
                        this.selectsInit(selectItems);
                        this.setLogging(`Прокинувся, построїв селектов: (${selectItems.length})`);
                    } else this.setLogging("Сплю, немає жодного select");
                }
            }
            getSelectClass(className) {
                return `.${className}`;
            }
            getSelectElement(selectItem, className) {
                return {
                    originalSelect: selectItem.querySelector("select"),
                    selectElement: selectItem.querySelector(this.getSelectClass(className))
                };
            }
            selectsInit(selectItems) {
                selectItems.forEach(((originalSelect, index) => {
                    this.selectInit(originalSelect, index + 1);
                }));
                document.addEventListener("click", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusin", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusout", function(e) {
                    this.selectsActions(e);
                }.bind(this));
            }
            selectInit(originalSelect, index) {
                const _this = this;
                let selectItem = document.createElement("div");
                selectItem.classList.add(this.selectClasses.classSelect);
                originalSelect.parentNode.insertBefore(selectItem, originalSelect);
                selectItem.appendChild(originalSelect);
                originalSelect.hidden = true;
                index ? originalSelect.dataset.id = index : null;
                if (this.getSelectPlaceholder(originalSelect)) {
                    originalSelect.dataset.placeholder = this.getSelectPlaceholder(originalSelect).value;
                    if (this.getSelectPlaceholder(originalSelect).label.show) {
                        const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                        selectItemTitle.insertAdjacentHTML("afterbegin", `<span class="${this.selectClasses.classSelectLabel}">${this.getSelectPlaceholder(originalSelect).label.text ? this.getSelectPlaceholder(originalSelect).label.text : this.getSelectPlaceholder(originalSelect).value}</span>`);
                    }
                }
                selectItem.insertAdjacentHTML("beforeend", `<div class="${this.selectClasses.classSelectBody}"><div hidden class="${this.selectClasses.classSelectOptions}"></div></div>`);
                this.selectBuild(originalSelect);
                originalSelect.dataset.speed = originalSelect.dataset.speed ? originalSelect.dataset.speed : this.config.speed;
                this.config.speed = +originalSelect.dataset.speed;
                originalSelect.addEventListener("change", (function(e) {
                    _this.selectChange(e);
                }));
            }
            selectBuild(originalSelect) {
                const selectItem = originalSelect.parentElement;
                selectItem.dataset.id = originalSelect.dataset.id;
                originalSelect.dataset.classModif ? selectItem.classList.add(`select_${originalSelect.dataset.classModif}`) : null;
                originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectMultiple) : selectItem.classList.remove(this.selectClasses.classSelectMultiple);
                originalSelect.hasAttribute("data-checkbox") && originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectCheckBox) : selectItem.classList.remove(this.selectClasses.classSelectCheckBox);
                this.setSelectTitleValue(selectItem, originalSelect);
                this.setOptions(selectItem, originalSelect);
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
                originalSelect.hasAttribute("data-open") ? this.selectAction(selectItem) : null;
                this.selectDisabled(selectItem, originalSelect);
            }
            selectsActions(e) {
                const targetElement = e.target;
                const targetType = e.type;
                if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect)) || targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                    const selectItem = targetElement.closest(".select") ? targetElement.closest(".select") : document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag)).dataset.selectId}"]`);
                    const originalSelect = this.getSelectElement(selectItem).originalSelect;
                    if (targetType === "click") {
                        if (!originalSelect.disabled) if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                            const targetTag = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag));
                            const optionItem = document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetTag.dataset.selectId}"] .select__option[data-value="${targetTag.dataset.value}"]`);
                            this.optionAction(selectItem, originalSelect, optionItem);
                        } else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTitle))) this.selectAction(selectItem); else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption))) {
                            const optionItem = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption));
                            this.optionAction(selectItem, originalSelect, optionItem);
                        }
                    } else if (targetType === "focusin" || targetType === "focusout") {
                        if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect))) targetType === "focusin" ? selectItem.classList.add(this.selectClasses.classSelectFocus) : selectItem.classList.remove(this.selectClasses.classSelectFocus);
                    } else if (targetType === "keydown" && e.code === "Escape") this.selectsСlose();
                } else this.selectsСlose();
            }
            selectsСlose(selectOneGroup) {
                const selectsGroup = selectOneGroup ? selectOneGroup : document;
                const selectActiveItems = selectsGroup.querySelectorAll(`${this.getSelectClass(this.selectClasses.classSelect)}${this.getSelectClass(this.selectClasses.classSelectOpen)}`);
                if (selectActiveItems.length) selectActiveItems.forEach((selectActiveItem => {
                    this.selectСlose(selectActiveItem);
                }));
            }
            selectСlose(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                if (!selectOptions.classList.contains("_slide")) {
                    selectItem.classList.remove(this.selectClasses.classSelectOpen);
                    _slideUp(selectOptions, originalSelect.dataset.speed);
                    setTimeout((() => {
                        selectItem.style.zIndex = "";
                    }), originalSelect.dataset.speed);
                }
            }
            selectAction(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOpenzIndex = originalSelect.dataset.zIndex ? originalSelect.dataset.zIndex : 3;
                this.setOptionsPosition(selectItem);
                if (originalSelect.closest("[data-one-select]")) {
                    const selectOneGroup = originalSelect.closest("[data-one-select]");
                    this.selectsСlose(selectOneGroup);
                }
                setTimeout((() => {
                    if (!selectOptions.classList.contains("_slide")) {
                        selectItem.classList.toggle(this.selectClasses.classSelectOpen);
                        _slideToggle(selectOptions, originalSelect.dataset.speed);
                        if (selectItem.classList.contains(this.selectClasses.classSelectOpen)) selectItem.style.zIndex = selectOpenzIndex; else setTimeout((() => {
                            selectItem.style.zIndex = "";
                        }), originalSelect.dataset.speed);
                    }
                }), 0);
            }
            setSelectTitleValue(selectItem, originalSelect) {
                const selectItemBody = this.getSelectElement(selectItem, this.selectClasses.classSelectBody).selectElement;
                const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                if (selectItemTitle) selectItemTitle.remove();
                selectItemBody.insertAdjacentHTML("afterbegin", this.getSelectTitleValue(selectItem, originalSelect));
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
            }
            getSelectTitleValue(selectItem, originalSelect) {
                let selectTitleValue = this.getSelectedOptionsData(originalSelect, 2).html;
                if (originalSelect.multiple && originalSelect.hasAttribute("data-tags")) {
                    selectTitleValue = this.getSelectedOptionsData(originalSelect).elements.map((option => `<span role="button" data-select-id="${selectItem.dataset.id}" data-value="${option.value}" class="_select-tag">${this.getSelectElementContent(option)}</span>`)).join("");
                    if (originalSelect.dataset.tags && document.querySelector(originalSelect.dataset.tags)) {
                        document.querySelector(originalSelect.dataset.tags).innerHTML = selectTitleValue;
                        if (originalSelect.hasAttribute("data-search")) selectTitleValue = false;
                    }
                }
                selectTitleValue = selectTitleValue.length ? selectTitleValue : originalSelect.dataset.placeholder ? originalSelect.dataset.placeholder : "";
                let pseudoAttribute = "";
                let pseudoAttributeClass = "";
                if (originalSelect.hasAttribute("data-pseudo-label")) {
                    pseudoAttribute = originalSelect.dataset.pseudoLabel ? ` data-pseudo-label="${originalSelect.dataset.pseudoLabel}"` : ` data-pseudo-label="Заповніть атрибут"`;
                    pseudoAttributeClass = ` ${this.selectClasses.classSelectPseudoLabel}`;
                }
                this.getSelectedOptionsData(originalSelect).values.length ? selectItem.classList.add(this.selectClasses.classSelectActive) : selectItem.classList.remove(this.selectClasses.classSelectActive);
                if (originalSelect.hasAttribute("data-search")) return `<div class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}"><input autocomplete="off" type="text" placeholder="${selectTitleValue}" data-placeholder="${selectTitleValue}" class="${this.selectClasses.classSelectInput}"></span></div>`; else {
                    const customClass = this.getSelectedOptionsData(originalSelect).elements.length && this.getSelectedOptionsData(originalSelect).elements[0].dataset.class ? ` ${this.getSelectedOptionsData(originalSelect).elements[0].dataset.class}` : "";
                    return `<button type="button" class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}${pseudoAttributeClass}"><span class="${this.selectClasses.classSelectContent}${customClass}">${selectTitleValue}</span></span></button>`;
                }
            }
            getSelectElementContent(selectOption) {
                const selectOptionData = selectOption.dataset.asset ? `${selectOption.dataset.asset}` : "";
                const selectOptionDataHTML = selectOptionData.indexOf("img") >= 0 ? `<img src="${selectOptionData}" alt="">` : selectOptionData;
                let selectOptionContentHTML = ``;
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectRow}">` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectData}">` : "";
                selectOptionContentHTML += selectOptionData ? selectOptionDataHTML : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectText}">` : "";
                selectOptionContentHTML += selectOption.textContent;
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                return selectOptionContentHTML;
            }
            getSelectPlaceholder(originalSelect) {
                const selectPlaceholder = Array.from(originalSelect.options).find((option => !option.value));
                if (selectPlaceholder) return {
                    value: selectPlaceholder.textContent,
                    show: selectPlaceholder.hasAttribute("data-show"),
                    label: {
                        show: selectPlaceholder.hasAttribute("data-label"),
                        text: selectPlaceholder.dataset.label
                    }
                };
            }
            getSelectedOptionsData(originalSelect, type) {
                let selectedOptions = [];
                if (originalSelect.multiple) selectedOptions = Array.from(originalSelect.options).filter((option => option.value)).filter((option => option.selected)); else selectedOptions.push(originalSelect.options[originalSelect.selectedIndex]);
                return {
                    elements: selectedOptions.map((option => option)),
                    values: selectedOptions.filter((option => option.value)).map((option => option.value)),
                    html: selectedOptions.map((option => this.getSelectElementContent(option)))
                };
            }
            getOptions(originalSelect) {
                const selectOptionsScroll = originalSelect.hasAttribute("data-scroll") ? `data-simplebar` : "";
                const customMaxHeightValue = +originalSelect.dataset.scroll ? +originalSelect.dataset.scroll : null;
                let selectOptions = Array.from(originalSelect.options);
                if (selectOptions.length > 0) {
                    let selectOptionsHTML = ``;
                    if (this.getSelectPlaceholder(originalSelect) && !this.getSelectPlaceholder(originalSelect).show || originalSelect.multiple) selectOptions = selectOptions.filter((option => option.value));
                    selectOptionsHTML += `<div ${selectOptionsScroll} ${selectOptionsScroll ? `style="max-height: ${customMaxHeightValue}px"` : ""} class="${this.selectClasses.classSelectOptionsScroll}">`;
                    selectOptions.forEach((selectOption => {
                        selectOptionsHTML += this.getOption(selectOption, originalSelect);
                    }));
                    selectOptionsHTML += `</div>`;
                    return selectOptionsHTML;
                }
            }
            getOption(selectOption, originalSelect) {
                const selectOptionSelected = selectOption.selected && originalSelect.multiple ? ` ${this.selectClasses.classSelectOptionSelected}` : "";
                const selectOptionHide = selectOption.selected && !originalSelect.hasAttribute("data-show-selected") && !originalSelect.multiple ? `hidden` : ``;
                const selectOptionClass = selectOption.dataset.class ? ` ${selectOption.dataset.class}` : "";
                const selectOptionLink = selectOption.dataset.href ? selectOption.dataset.href : false;
                const selectOptionLinkTarget = selectOption.hasAttribute("data-href-blank") ? `target="_blank"` : "";
                let selectOptionHTML = ``;
                selectOptionHTML += selectOptionLink ? `<a ${selectOptionLinkTarget} ${selectOptionHide} href="${selectOptionLink}" data-value="${selectOption.value}" class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}">` : `<button ${selectOptionHide} class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}" data-value="${selectOption.value}" type="button">`;
                selectOptionHTML += this.getSelectElementContent(selectOption);
                selectOptionHTML += selectOptionLink ? `</a>` : `</button>`;
                return selectOptionHTML;
            }
            setOptions(selectItem, originalSelect) {
                const selectItemOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                selectItemOptions.innerHTML = this.getOptions(originalSelect);
            }
            setOptionsPosition(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectItemScroll = this.getSelectElement(selectItem, this.selectClasses.classSelectOptionsScroll).selectElement;
                const customMaxHeightValue = +originalSelect.dataset.scroll ? `${+originalSelect.dataset.scroll}px` : ``;
                const selectOptionsPosMargin = +originalSelect.dataset.optionsMargin ? +originalSelect.dataset.optionsMargin : 10;
                if (!selectItem.classList.contains(this.selectClasses.classSelectOpen)) {
                    selectOptions.hidden = false;
                    const selectItemScrollHeight = selectItemScroll.offsetHeight ? selectItemScroll.offsetHeight : parseInt(window.getComputedStyle(selectItemScroll).getPropertyValue("max-height"));
                    const selectOptionsHeight = selectOptions.offsetHeight > selectItemScrollHeight ? selectOptions.offsetHeight : selectItemScrollHeight + selectOptions.offsetHeight;
                    const selectOptionsScrollHeight = selectOptionsHeight - selectItemScrollHeight;
                    selectOptions.hidden = true;
                    const selectItemHeight = selectItem.offsetHeight;
                    const selectItemPos = selectItem.getBoundingClientRect().top;
                    const selectItemTotal = selectItemPos + selectOptionsHeight + selectItemHeight + selectOptionsScrollHeight;
                    const selectItemResult = window.innerHeight - (selectItemTotal + selectOptionsPosMargin);
                    if (selectItemResult < 0) {
                        const newMaxHeightValue = selectOptionsHeight + selectItemResult;
                        if (newMaxHeightValue < 100) {
                            selectItem.classList.add("select--show-top");
                            selectItemScroll.style.maxHeight = selectItemPos < selectOptionsHeight ? `${selectItemPos - (selectOptionsHeight - selectItemPos)}px` : customMaxHeightValue;
                        } else {
                            selectItem.classList.remove("select--show-top");
                            selectItemScroll.style.maxHeight = `${newMaxHeightValue}px`;
                        }
                    }
                } else setTimeout((() => {
                    selectItem.classList.remove("select--show-top");
                    selectItemScroll.style.maxHeight = customMaxHeightValue;
                }), +originalSelect.dataset.speed);
            }
            optionAction(selectItem, originalSelect, optionItem) {
                const selectOptions = selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOptions)}`);
                if (!selectOptions.classList.contains("_slide")) {
                    if (originalSelect.multiple) {
                        optionItem.classList.toggle(this.selectClasses.classSelectOptionSelected);
                        const originalSelectSelectedItems = this.getSelectedOptionsData(originalSelect).elements;
                        originalSelectSelectedItems.forEach((originalSelectSelectedItem => {
                            originalSelectSelectedItem.removeAttribute("selected");
                        }));
                        const selectSelectedItems = selectItem.querySelectorAll(this.getSelectClass(this.selectClasses.classSelectOptionSelected));
                        selectSelectedItems.forEach((selectSelectedItems => {
                            originalSelect.querySelector(`option[value = "${selectSelectedItems.dataset.value}"]`).setAttribute("selected", "selected");
                        }));
                    } else {
                        if (!originalSelect.hasAttribute("data-show-selected")) setTimeout((() => {
                            if (selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`)) selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`).hidden = false;
                            optionItem.hidden = true;
                        }), this.config.speed);
                        originalSelect.value = optionItem.hasAttribute("data-value") ? optionItem.dataset.value : optionItem.textContent;
                        this.selectAction(selectItem);
                    }
                    this.setSelectTitleValue(selectItem, originalSelect);
                    this.setSelectChange(originalSelect);
                }
            }
            selectChange(e) {
                const originalSelect = e.target;
                this.selectBuild(originalSelect);
                this.setSelectChange(originalSelect);
            }
            setSelectChange(originalSelect) {
                if (originalSelect.hasAttribute("data-validate")) formValidate.validateInput(originalSelect);
                if (originalSelect.hasAttribute("data-submit") && originalSelect.value) {
                    let tempButton = document.createElement("button");
                    tempButton.type = "submit";
                    originalSelect.closest("form").append(tempButton);
                    tempButton.click();
                    tempButton.remove();
                }
                const selectItem = originalSelect.parentElement;
                this.selectCallback(selectItem, originalSelect);
            }
            selectDisabled(selectItem, originalSelect) {
                if (originalSelect.disabled) {
                    selectItem.classList.add(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = true;
                } else {
                    selectItem.classList.remove(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = false;
                }
            }
            searchActions(selectItem) {
                this.getSelectElement(selectItem).originalSelect;
                const selectInput = this.getSelectElement(selectItem, this.selectClasses.classSelectInput).selectElement;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOptionsItems = selectOptions.querySelectorAll(`.${this.selectClasses.classSelectOption} `);
                const _this = this;
                selectInput.addEventListener("input", (function() {
                    selectOptionsItems.forEach((selectOptionsItem => {
                        if (selectOptionsItem.textContent.toUpperCase().includes(selectInput.value.toUpperCase())) selectOptionsItem.hidden = false; else selectOptionsItem.hidden = true;
                    }));
                    selectOptions.hidden === true ? _this.selectAction(selectItem) : null;
                }));
            }
            selectCallback(selectItem, originalSelect) {
                document.dispatchEvent(new CustomEvent("selectCallback", {
                    detail: {
                        select: originalSelect
                    }
                }));
            }
            setLogging(message) {
                this.config.logging ? FLS(`[select]: ${message} `) : null;
            }
        }
        modules_flsModules.select = new SelectConstructor({});
        __webpack_require__(958);
        const inputMasks = document.querySelectorAll("input");
        if (inputMasks.length) modules_flsModules.inputmask = Inputmask().mask(inputMasks);
        var PipsMode;
        (function(PipsMode) {
            PipsMode["Range"] = "range";
            PipsMode["Steps"] = "steps";
            PipsMode["Positions"] = "positions";
            PipsMode["Count"] = "count";
            PipsMode["Values"] = "values";
        })(PipsMode || (PipsMode = {}));
        var PipsType;
        (function(PipsType) {
            PipsType[PipsType["None"] = -1] = "None";
            PipsType[PipsType["NoValue"] = 0] = "NoValue";
            PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
            PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
        })(PipsType || (PipsType = {}));
        function isValidFormatter(entry) {
            return isValidPartialFormatter(entry) && typeof entry.from === "function";
        }
        function isValidPartialFormatter(entry) {
            return typeof entry === "object" && typeof entry.to === "function";
        }
        function removeElement(el) {
            el.parentElement.removeChild(el);
        }
        function isSet(value) {
            return value !== null && value !== void 0;
        }
        function preventDefault(e) {
            e.preventDefault();
        }
        function unique(array) {
            return array.filter((function(a) {
                return !this[a] ? this[a] = true : false;
            }), {});
        }
        function closest(value, to) {
            return Math.round(value / to) * to;
        }
        function offset(elem, orientation) {
            var rect = elem.getBoundingClientRect();
            var doc = elem.ownerDocument;
            var docElem = doc.documentElement;
            var pageOffset = getPageOffset(doc);
            if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) pageOffset.x = 0;
            return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
        }
        function isNumeric(a) {
            return typeof a === "number" && !isNaN(a) && isFinite(a);
        }
        function addClassFor(element, className, duration) {
            if (duration > 0) {
                addClass(element, className);
                setTimeout((function() {
                    removeClass(element, className);
                }), duration);
            }
        }
        function limit(a) {
            return Math.max(Math.min(a, 100), 0);
        }
        function asArray(a) {
            return Array.isArray(a) ? a : [ a ];
        }
        function countDecimals(numStr) {
            numStr = String(numStr);
            var pieces = numStr.split(".");
            return pieces.length > 1 ? pieces[1].length : 0;
        }
        function addClass(el, className) {
            if (el.classList && !/\s/.test(className)) el.classList.add(className); else el.className += " " + className;
        }
        function removeClass(el, className) {
            if (el.classList && !/\s/.test(className)) el.classList.remove(className); else el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
        function hasClass(el, className) {
            return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
        }
        function getPageOffset(doc) {
            var supportPageOffset = window.pageXOffset !== void 0;
            var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
            var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
            var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
            return {
                x,
                y
            };
        }
        function getActions() {
            return window.navigator.pointerEnabled ? {
                start: "pointerdown",
                move: "pointermove",
                end: "pointerup"
            } : window.navigator.msPointerEnabled ? {
                start: "MSPointerDown",
                move: "MSPointerMove",
                end: "MSPointerUp"
            } : {
                start: "mousedown touchstart",
                move: "mousemove touchmove",
                end: "mouseup touchend"
            };
        }
        function getSupportsPassive() {
            var supportsPassive = false;
            try {
                var opts = Object.defineProperty({}, "passive", {
                    get: function() {
                        supportsPassive = true;
                    }
                });
                window.addEventListener("test", null, opts);
            } catch (e) {}
            return supportsPassive;
        }
        function getSupportsTouchActionNone() {
            return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
        }
        function subRangeRatio(pa, pb) {
            return 100 / (pb - pa);
        }
        function fromPercentage(range, value, startRange) {
            return value * 100 / (range[startRange + 1] - range[startRange]);
        }
        function toPercentage(range, value) {
            return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
        }
        function isPercentage(range, value) {
            return value * (range[1] - range[0]) / 100 + range[0];
        }
        function getJ(value, arr) {
            var j = 1;
            while (value >= arr[j]) j += 1;
            return j;
        }
        function toStepping(xVal, xPct, value) {
            if (value >= xVal.slice(-1)[0]) return 100;
            var j = getJ(value, xVal);
            var va = xVal[j - 1];
            var vb = xVal[j];
            var pa = xPct[j - 1];
            var pb = xPct[j];
            return pa + toPercentage([ va, vb ], value) / subRangeRatio(pa, pb);
        }
        function fromStepping(xVal, xPct, value) {
            if (value >= 100) return xVal.slice(-1)[0];
            var j = getJ(value, xPct);
            var va = xVal[j - 1];
            var vb = xVal[j];
            var pa = xPct[j - 1];
            var pb = xPct[j];
            return isPercentage([ va, vb ], (value - pa) * subRangeRatio(pa, pb));
        }
        function getStep(xPct, xSteps, snap, value) {
            if (value === 100) return value;
            var j = getJ(value, xPct);
            var a = xPct[j - 1];
            var b = xPct[j];
            if (snap) {
                if (value - a > (b - a) / 2) return b;
                return a;
            }
            if (!xSteps[j - 1]) return value;
            return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
        }
        var Spectrum = function() {
            function Spectrum(entry, snap, singleStep) {
                this.xPct = [];
                this.xVal = [];
                this.xSteps = [];
                this.xNumSteps = [];
                this.xHighestCompleteStep = [];
                this.xSteps = [ singleStep || false ];
                this.xNumSteps = [ false ];
                this.snap = snap;
                var index;
                var ordered = [];
                Object.keys(entry).forEach((function(index) {
                    ordered.push([ asArray(entry[index]), index ]);
                }));
                ordered.sort((function(a, b) {
                    return a[0][0] - b[0][0];
                }));
                for (index = 0; index < ordered.length; index++) this.handleEntryPoint(ordered[index][1], ordered[index][0]);
                this.xNumSteps = this.xSteps.slice(0);
                for (index = 0; index < this.xNumSteps.length; index++) this.handleStepPoint(index, this.xNumSteps[index]);
            }
            Spectrum.prototype.getDistance = function(value) {
                var distances = [];
                for (var index = 0; index < this.xNumSteps.length - 1; index++) distances[index] = fromPercentage(this.xVal, value, index);
                return distances;
            };
            Spectrum.prototype.getAbsoluteDistance = function(value, distances, direction) {
                var xPct_index = 0;
                if (value < this.xPct[this.xPct.length - 1]) while (value > this.xPct[xPct_index + 1]) xPct_index++; else if (value === this.xPct[this.xPct.length - 1]) xPct_index = this.xPct.length - 2;
                if (!direction && value === this.xPct[xPct_index + 1]) xPct_index++;
                if (distances === null) distances = [];
                var start_factor;
                var rest_factor = 1;
                var rest_rel_distance = distances[xPct_index];
                var range_pct = 0;
                var rel_range_distance = 0;
                var abs_distance_counter = 0;
                var range_counter = 0;
                if (direction) start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]); else start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
                while (rest_rel_distance > 0) {
                    range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
                    if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                        rel_range_distance = range_pct * start_factor;
                        rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                        start_factor = 1;
                    } else {
                        rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
                        rest_factor = 0;
                    }
                    if (direction) {
                        abs_distance_counter -= rel_range_distance;
                        if (this.xPct.length + range_counter >= 1) range_counter--;
                    } else {
                        abs_distance_counter += rel_range_distance;
                        if (this.xPct.length - range_counter >= 1) range_counter++;
                    }
                    rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
                }
                return value + abs_distance_counter;
            };
            Spectrum.prototype.toStepping = function(value) {
                value = toStepping(this.xVal, this.xPct, value);
                return value;
            };
            Spectrum.prototype.fromStepping = function(value) {
                return fromStepping(this.xVal, this.xPct, value);
            };
            Spectrum.prototype.getStep = function(value) {
                value = getStep(this.xPct, this.xSteps, this.snap, value);
                return value;
            };
            Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
                var j = getJ(value, this.xPct);
                if (value === 100 || isDown && value === this.xPct[j - 1]) j = Math.max(j - 1, 1);
                return (this.xVal[j] - this.xVal[j - 1]) / size;
            };
            Spectrum.prototype.getNearbySteps = function(value) {
                var j = getJ(value, this.xPct);
                return {
                    stepBefore: {
                        startValue: this.xVal[j - 2],
                        step: this.xNumSteps[j - 2],
                        highestStep: this.xHighestCompleteStep[j - 2]
                    },
                    thisStep: {
                        startValue: this.xVal[j - 1],
                        step: this.xNumSteps[j - 1],
                        highestStep: this.xHighestCompleteStep[j - 1]
                    },
                    stepAfter: {
                        startValue: this.xVal[j],
                        step: this.xNumSteps[j],
                        highestStep: this.xHighestCompleteStep[j]
                    }
                };
            };
            Spectrum.prototype.countStepDecimals = function() {
                var stepDecimals = this.xNumSteps.map(countDecimals);
                return Math.max.apply(null, stepDecimals);
            };
            Spectrum.prototype.hasNoSize = function() {
                return this.xVal[0] === this.xVal[this.xVal.length - 1];
            };
            Spectrum.prototype.convert = function(value) {
                return this.getStep(this.toStepping(value));
            };
            Spectrum.prototype.handleEntryPoint = function(index, value) {
                var percentage;
                if (index === "min") percentage = 0; else if (index === "max") percentage = 100; else percentage = parseFloat(index);
                if (!isNumeric(percentage) || !isNumeric(value[0])) throw new Error("noUiSlider: 'range' value isn't numeric.");
                this.xPct.push(percentage);
                this.xVal.push(value[0]);
                var value1 = Number(value[1]);
                if (!percentage) {
                    if (!isNaN(value1)) this.xSteps[0] = value1;
                } else this.xSteps.push(isNaN(value1) ? false : value1);
                this.xHighestCompleteStep.push(0);
            };
            Spectrum.prototype.handleStepPoint = function(i, n) {
                if (!n) return;
                if (this.xVal[i] === this.xVal[i + 1]) {
                    this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
                    return;
                }
                this.xSteps[i] = fromPercentage([ this.xVal[i], this.xVal[i + 1] ], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
                var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
                var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
                var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
                this.xHighestCompleteStep[i] = step;
            };
            return Spectrum;
        }();
        var defaultFormatter = {
            to: function(value) {
                return value === void 0 ? "" : value.toFixed(2);
            },
            from: Number
        };
        var cssClasses = {
            target: "target",
            base: "base",
            origin: "origin",
            handle: "handle",
            handleLower: "handle-lower",
            handleUpper: "handle-upper",
            touchArea: "touch-area",
            horizontal: "horizontal",
            vertical: "vertical",
            background: "background",
            connect: "connect",
            connects: "connects",
            ltr: "ltr",
            rtl: "rtl",
            textDirectionLtr: "txt-dir-ltr",
            textDirectionRtl: "txt-dir-rtl",
            draggable: "draggable",
            drag: "state-drag",
            tap: "state-tap",
            active: "active",
            tooltip: "tooltip",
            pips: "pips",
            pipsHorizontal: "pips-horizontal",
            pipsVertical: "pips-vertical",
            marker: "marker",
            markerHorizontal: "marker-horizontal",
            markerVertical: "marker-vertical",
            markerNormal: "marker-normal",
            markerLarge: "marker-large",
            markerSub: "marker-sub",
            value: "value",
            valueHorizontal: "value-horizontal",
            valueVertical: "value-vertical",
            valueNormal: "value-normal",
            valueLarge: "value-large",
            valueSub: "value-sub"
        };
        var INTERNAL_EVENT_NS = {
            tooltips: ".__tooltips",
            aria: ".__aria"
        };
        function testStep(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'step' is not numeric.");
            parsed.singleStep = entry;
        }
        function testKeyboardPageMultiplier(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
            parsed.keyboardPageMultiplier = entry;
        }
        function testKeyboardMultiplier(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
            parsed.keyboardMultiplier = entry;
        }
        function testKeyboardDefaultStep(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
            parsed.keyboardDefaultStep = entry;
        }
        function testRange(parsed, entry) {
            if (typeof entry !== "object" || Array.isArray(entry)) throw new Error("noUiSlider: 'range' is not an object.");
            if (entry.min === void 0 || entry.max === void 0) throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
            parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
        }
        function testStart(parsed, entry) {
            entry = asArray(entry);
            if (!Array.isArray(entry) || !entry.length) throw new Error("noUiSlider: 'start' option is incorrect.");
            parsed.handles = entry.length;
            parsed.start = entry;
        }
        function testSnap(parsed, entry) {
            if (typeof entry !== "boolean") throw new Error("noUiSlider: 'snap' option must be a boolean.");
            parsed.snap = entry;
        }
        function testAnimate(parsed, entry) {
            if (typeof entry !== "boolean") throw new Error("noUiSlider: 'animate' option must be a boolean.");
            parsed.animate = entry;
        }
        function testAnimationDuration(parsed, entry) {
            if (typeof entry !== "number") throw new Error("noUiSlider: 'animationDuration' option must be a number.");
            parsed.animationDuration = entry;
        }
        function testConnect(parsed, entry) {
            var connect = [ false ];
            var i;
            if (entry === "lower") entry = [ true, false ]; else if (entry === "upper") entry = [ false, true ];
            if (entry === true || entry === false) {
                for (i = 1; i < parsed.handles; i++) connect.push(entry);
                connect.push(false);
            } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) throw new Error("noUiSlider: 'connect' option doesn't match handle count."); else connect = entry;
            parsed.connect = connect;
        }
        function testOrientation(parsed, entry) {
            switch (entry) {
              case "horizontal":
                parsed.ort = 0;
                break;

              case "vertical":
                parsed.ort = 1;
                break;

              default:
                throw new Error("noUiSlider: 'orientation' option is invalid.");
            }
        }
        function testMargin(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'margin' option must be numeric.");
            if (entry === 0) return;
            parsed.margin = parsed.spectrum.getDistance(entry);
        }
        function testLimit(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'limit' option must be numeric.");
            parsed.limit = parsed.spectrum.getDistance(entry);
            if (!parsed.limit || parsed.handles < 2) throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
        function testPadding(parsed, entry) {
            var index;
            if (!isNumeric(entry) && !Array.isArray(entry)) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
            if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
            if (entry === 0) return;
            if (!Array.isArray(entry)) entry = [ entry, entry ];
            parsed.padding = [ parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1]) ];
            for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
            var totalPadding = entry[0] + entry[1];
            var firstValue = parsed.spectrum.xVal[0];
            var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
            if (totalPadding / (lastValue - firstValue) > 1) throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
        function testDirection(parsed, entry) {
            switch (entry) {
              case "ltr":
                parsed.dir = 0;
                break;

              case "rtl":
                parsed.dir = 1;
                break;

              default:
                throw new Error("noUiSlider: 'direction' option was not recognized.");
            }
        }
        function testBehaviour(parsed, entry) {
            if (typeof entry !== "string") throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
            var tap = entry.indexOf("tap") >= 0;
            var drag = entry.indexOf("drag") >= 0;
            var fixed = entry.indexOf("fixed") >= 0;
            var snap = entry.indexOf("snap") >= 0;
            var hover = entry.indexOf("hover") >= 0;
            var unconstrained = entry.indexOf("unconstrained") >= 0;
            var invertConnects = entry.indexOf("invert-connects") >= 0;
            var dragAll = entry.indexOf("drag-all") >= 0;
            var smoothSteps = entry.indexOf("smooth-steps") >= 0;
            if (fixed) {
                if (parsed.handles !== 2) throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
                testMargin(parsed, parsed.start[1] - parsed.start[0]);
            }
            if (invertConnects && parsed.handles !== 2) throw new Error("noUiSlider: 'invert-connects' behaviour must be used with 2 handles");
            if (unconstrained && (parsed.margin || parsed.limit)) throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
            parsed.events = {
                tap: tap || snap,
                drag,
                dragAll,
                smoothSteps,
                fixed,
                snap,
                hover,
                unconstrained,
                invertConnects
            };
        }
        function testTooltips(parsed, entry) {
            if (entry === false) return;
            if (entry === true || isValidPartialFormatter(entry)) {
                parsed.tooltips = [];
                for (var i = 0; i < parsed.handles; i++) parsed.tooltips.push(entry);
            } else {
                entry = asArray(entry);
                if (entry.length !== parsed.handles) throw new Error("noUiSlider: must pass a formatter for all handles.");
                entry.forEach((function(formatter) {
                    if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
                }));
                parsed.tooltips = entry;
            }
        }
        function testHandleAttributes(parsed, entry) {
            if (entry.length !== parsed.handles) throw new Error("noUiSlider: must pass a attributes for all handles.");
            parsed.handleAttributes = entry;
        }
        function testAriaFormat(parsed, entry) {
            if (!isValidPartialFormatter(entry)) throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
            parsed.ariaFormat = entry;
        }
        function testFormat(parsed, entry) {
            if (!isValidFormatter(entry)) throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
            parsed.format = entry;
        }
        function testKeyboardSupport(parsed, entry) {
            if (typeof entry !== "boolean") throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
            parsed.keyboardSupport = entry;
        }
        function testDocumentElement(parsed, entry) {
            parsed.documentElement = entry;
        }
        function testCssPrefix(parsed, entry) {
            if (typeof entry !== "string" && entry !== false) throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
            parsed.cssPrefix = entry;
        }
        function testCssClasses(parsed, entry) {
            if (typeof entry !== "object") throw new Error("noUiSlider: 'cssClasses' must be an object.");
            if (typeof parsed.cssPrefix === "string") {
                parsed.cssClasses = {};
                Object.keys(entry).forEach((function(key) {
                    parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
                }));
            } else parsed.cssClasses = entry;
        }
        function testOptions(options) {
            var parsed = {
                margin: null,
                limit: null,
                padding: null,
                animate: true,
                animationDuration: 300,
                ariaFormat: defaultFormatter,
                format: defaultFormatter
            };
            var tests = {
                step: {
                    r: false,
                    t: testStep
                },
                keyboardPageMultiplier: {
                    r: false,
                    t: testKeyboardPageMultiplier
                },
                keyboardMultiplier: {
                    r: false,
                    t: testKeyboardMultiplier
                },
                keyboardDefaultStep: {
                    r: false,
                    t: testKeyboardDefaultStep
                },
                start: {
                    r: true,
                    t: testStart
                },
                connect: {
                    r: true,
                    t: testConnect
                },
                direction: {
                    r: true,
                    t: testDirection
                },
                snap: {
                    r: false,
                    t: testSnap
                },
                animate: {
                    r: false,
                    t: testAnimate
                },
                animationDuration: {
                    r: false,
                    t: testAnimationDuration
                },
                range: {
                    r: true,
                    t: testRange
                },
                orientation: {
                    r: false,
                    t: testOrientation
                },
                margin: {
                    r: false,
                    t: testMargin
                },
                limit: {
                    r: false,
                    t: testLimit
                },
                padding: {
                    r: false,
                    t: testPadding
                },
                behaviour: {
                    r: true,
                    t: testBehaviour
                },
                ariaFormat: {
                    r: false,
                    t: testAriaFormat
                },
                format: {
                    r: false,
                    t: testFormat
                },
                tooltips: {
                    r: false,
                    t: testTooltips
                },
                keyboardSupport: {
                    r: true,
                    t: testKeyboardSupport
                },
                documentElement: {
                    r: false,
                    t: testDocumentElement
                },
                cssPrefix: {
                    r: true,
                    t: testCssPrefix
                },
                cssClasses: {
                    r: true,
                    t: testCssClasses
                },
                handleAttributes: {
                    r: false,
                    t: testHandleAttributes
                }
            };
            var defaults = {
                connect: false,
                direction: "ltr",
                behaviour: "tap",
                orientation: "horizontal",
                keyboardSupport: true,
                cssPrefix: "noUi-",
                cssClasses,
                keyboardPageMultiplier: 5,
                keyboardMultiplier: 1,
                keyboardDefaultStep: 10
            };
            if (options.format && !options.ariaFormat) options.ariaFormat = options.format;
            Object.keys(tests).forEach((function(name) {
                if (!isSet(options[name]) && defaults[name] === void 0) {
                    if (tests[name].r) throw new Error("noUiSlider: '" + name + "' is required.");
                    return;
                }
                tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
            }));
            parsed.pips = options.pips;
            var d = document.createElement("div");
            var msPrefix = d.style.msTransform !== void 0;
            var noPrefix = d.style.transform !== void 0;
            parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
            var styles = [ [ "left", "top" ], [ "right", "bottom" ] ];
            parsed.style = styles[parsed.dir][parsed.ort];
            return parsed;
        }
        function scope(target, options, originalOptions) {
            var actions = getActions();
            var supportsTouchActionNone = getSupportsTouchActionNone();
            var supportsPassive = supportsTouchActionNone && getSupportsPassive();
            var scope_Target = target;
            var scope_Base;
            var scope_ConnectBase;
            var scope_Handles;
            var scope_Connects;
            var scope_Pips;
            var scope_Tooltips;
            var scope_Spectrum = options.spectrum;
            var scope_Values = [];
            var scope_Locations = [];
            var scope_HandleNumbers = [];
            var scope_ActiveHandlesCount = 0;
            var scope_Events = {};
            var scope_ConnectsInverted = false;
            var scope_Document = target.ownerDocument;
            var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
            var scope_Body = scope_Document.body;
            var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
            function addNodeTo(addTarget, className) {
                var div = scope_Document.createElement("div");
                if (className) addClass(div, className);
                addTarget.appendChild(div);
                return div;
            }
            function addOrigin(base, handleNumber) {
                var origin = addNodeTo(base, options.cssClasses.origin);
                var handle = addNodeTo(origin, options.cssClasses.handle);
                addNodeTo(handle, options.cssClasses.touchArea);
                handle.setAttribute("data-handle", String(handleNumber));
                if (options.keyboardSupport) {
                    handle.setAttribute("tabindex", "0");
                    handle.addEventListener("keydown", (function(event) {
                        return eventKeydown(event, handleNumber);
                    }));
                }
                if (options.handleAttributes !== void 0) {
                    var attributes_1 = options.handleAttributes[handleNumber];
                    Object.keys(attributes_1).forEach((function(attribute) {
                        handle.setAttribute(attribute, attributes_1[attribute]);
                    }));
                }
                handle.setAttribute("role", "slider");
                handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
                if (handleNumber === 0) addClass(handle, options.cssClasses.handleLower); else if (handleNumber === options.handles - 1) addClass(handle, options.cssClasses.handleUpper);
                origin.handle = handle;
                return origin;
            }
            function addConnect(base, add) {
                if (!add) return false;
                return addNodeTo(base, options.cssClasses.connect);
            }
            function addElements(connectOptions, base) {
                scope_ConnectBase = addNodeTo(base, options.cssClasses.connects);
                scope_Handles = [];
                scope_Connects = [];
                scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[0]));
                for (var i = 0; i < options.handles; i++) {
                    scope_Handles.push(addOrigin(base, i));
                    scope_HandleNumbers[i] = i;
                    scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[i + 1]));
                }
            }
            function addSlider(addTarget) {
                addClass(addTarget, options.cssClasses.target);
                if (options.dir === 0) addClass(addTarget, options.cssClasses.ltr); else addClass(addTarget, options.cssClasses.rtl);
                if (options.ort === 0) addClass(addTarget, options.cssClasses.horizontal); else addClass(addTarget, options.cssClasses.vertical);
                var textDirection = getComputedStyle(addTarget).direction;
                if (textDirection === "rtl") addClass(addTarget, options.cssClasses.textDirectionRtl); else addClass(addTarget, options.cssClasses.textDirectionLtr);
                return addNodeTo(addTarget, options.cssClasses.base);
            }
            function addTooltip(handle, handleNumber) {
                if (!options.tooltips || !options.tooltips[handleNumber]) return false;
                return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
            }
            function isSliderDisabled() {
                return scope_Target.hasAttribute("disabled");
            }
            function isHandleDisabled(handleNumber) {
                var handleOrigin = scope_Handles[handleNumber];
                return handleOrigin.hasAttribute("disabled");
            }
            function disable(handleNumber) {
                if (handleNumber !== null && handleNumber !== void 0) {
                    scope_Handles[handleNumber].setAttribute("disabled", "");
                    scope_Handles[handleNumber].handle.removeAttribute("tabindex");
                } else {
                    scope_Target.setAttribute("disabled", "");
                    scope_Handles.forEach((function(handle) {
                        handle.handle.removeAttribute("tabindex");
                    }));
                }
            }
            function enable(handleNumber) {
                if (handleNumber !== null && handleNumber !== void 0) {
                    scope_Handles[handleNumber].removeAttribute("disabled");
                    scope_Handles[handleNumber].handle.setAttribute("tabindex", "0");
                } else {
                    scope_Target.removeAttribute("disabled");
                    scope_Handles.forEach((function(handle) {
                        handle.removeAttribute("disabled");
                        handle.handle.setAttribute("tabindex", "0");
                    }));
                }
            }
            function removeTooltips() {
                if (scope_Tooltips) {
                    removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
                    scope_Tooltips.forEach((function(tooltip) {
                        if (tooltip) removeElement(tooltip);
                    }));
                    scope_Tooltips = null;
                }
            }
            function tooltips() {
                removeTooltips();
                scope_Tooltips = scope_Handles.map(addTooltip);
                bindEvent("update" + INTERNAL_EVENT_NS.tooltips, (function(values, handleNumber, unencoded) {
                    if (!scope_Tooltips || !options.tooltips) return;
                    if (scope_Tooltips[handleNumber] === false) return;
                    var formattedValue = values[handleNumber];
                    if (options.tooltips[handleNumber] !== true) formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
                    scope_Tooltips[handleNumber].innerHTML = formattedValue;
                }));
            }
            function aria() {
                removeEvent("update" + INTERNAL_EVENT_NS.aria);
                bindEvent("update" + INTERNAL_EVENT_NS.aria, (function(values, handleNumber, unencoded, tap, positions) {
                    scope_HandleNumbers.forEach((function(index) {
                        var handle = scope_Handles[index];
                        var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
                        var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
                        var now = positions[index];
                        var text = String(options.ariaFormat.to(unencoded[index]));
                        min = scope_Spectrum.fromStepping(min).toFixed(1);
                        max = scope_Spectrum.fromStepping(max).toFixed(1);
                        now = scope_Spectrum.fromStepping(now).toFixed(1);
                        handle.children[0].setAttribute("aria-valuemin", min);
                        handle.children[0].setAttribute("aria-valuemax", max);
                        handle.children[0].setAttribute("aria-valuenow", now);
                        handle.children[0].setAttribute("aria-valuetext", text);
                    }));
                }));
            }
            function getGroup(pips) {
                if (pips.mode === PipsMode.Range || pips.mode === PipsMode.Steps) return scope_Spectrum.xVal;
                if (pips.mode === PipsMode.Count) {
                    if (pips.values < 2) throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
                    var interval = pips.values - 1;
                    var spread = 100 / interval;
                    var values = [];
                    while (interval--) values[interval] = interval * spread;
                    values.push(100);
                    return mapToRange(values, pips.stepped);
                }
                if (pips.mode === PipsMode.Positions) return mapToRange(pips.values, pips.stepped);
                if (pips.mode === PipsMode.Values) {
                    if (pips.stepped) return pips.values.map((function(value) {
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                    }));
                    return pips.values;
                }
                return [];
            }
            function mapToRange(values, stepped) {
                return values.map((function(value) {
                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                }));
            }
            function generateSpread(pips) {
                function safeIncrement(value, increment) {
                    return Number((value + increment).toFixed(7));
                }
                var group = getGroup(pips);
                var indexes = {};
                var firstInRange = scope_Spectrum.xVal[0];
                var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
                var ignoreFirst = false;
                var ignoreLast = false;
                var prevPct = 0;
                group = unique(group.slice().sort((function(a, b) {
                    return a - b;
                })));
                if (group[0] !== firstInRange) {
                    group.unshift(firstInRange);
                    ignoreFirst = true;
                }
                if (group[group.length - 1] !== lastInRange) {
                    group.push(lastInRange);
                    ignoreLast = true;
                }
                group.forEach((function(current, index) {
                    var step;
                    var i;
                    var q;
                    var low = current;
                    var high = group[index + 1];
                    var newPct;
                    var pctDifference;
                    var pctPos;
                    var type;
                    var steps;
                    var realSteps;
                    var stepSize;
                    var isSteps = pips.mode === PipsMode.Steps;
                    if (isSteps) step = scope_Spectrum.xNumSteps[index];
                    if (!step) step = high - low;
                    if (high === void 0) high = low;
                    step = Math.max(step, 1e-7);
                    for (i = low; i <= high; i = safeIncrement(i, step)) {
                        newPct = scope_Spectrum.toStepping(i);
                        pctDifference = newPct - prevPct;
                        steps = pctDifference / (pips.density || 1);
                        realSteps = Math.round(steps);
                        stepSize = pctDifference / realSteps;
                        for (q = 1; q <= realSteps; q += 1) {
                            pctPos = prevPct + q * stepSize;
                            indexes[pctPos.toFixed(5)] = [ scope_Spectrum.fromStepping(pctPos), 0 ];
                        }
                        type = group.indexOf(i) > -1 ? PipsType.LargeValue : isSteps ? PipsType.SmallValue : PipsType.NoValue;
                        if (!index && ignoreFirst && i !== high) type = 0;
                        if (!(i === high && ignoreLast)) indexes[newPct.toFixed(5)] = [ i, type ];
                        prevPct = newPct;
                    }
                }));
                return indexes;
            }
            function addMarking(spread, filterFunc, formatter) {
                var _a, _b;
                var element = scope_Document.createElement("div");
                var valueSizeClasses = (_a = {}, _a[PipsType.None] = "", _a[PipsType.NoValue] = options.cssClasses.valueNormal, 
                _a[PipsType.LargeValue] = options.cssClasses.valueLarge, _a[PipsType.SmallValue] = options.cssClasses.valueSub, 
                _a);
                var markerSizeClasses = (_b = {}, _b[PipsType.None] = "", _b[PipsType.NoValue] = options.cssClasses.markerNormal, 
                _b[PipsType.LargeValue] = options.cssClasses.markerLarge, _b[PipsType.SmallValue] = options.cssClasses.markerSub, 
                _b);
                var valueOrientationClasses = [ options.cssClasses.valueHorizontal, options.cssClasses.valueVertical ];
                var markerOrientationClasses = [ options.cssClasses.markerHorizontal, options.cssClasses.markerVertical ];
                addClass(element, options.cssClasses.pips);
                addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
                function getClasses(type, source) {
                    var a = source === options.cssClasses.value;
                    var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
                    var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
                    return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
                }
                function addSpread(offset, value, type) {
                    type = filterFunc ? filterFunc(value, type) : type;
                    if (type === PipsType.None) return;
                    var node = addNodeTo(element, false);
                    node.className = getClasses(type, options.cssClasses.marker);
                    node.style[options.style] = offset + "%";
                    if (type > PipsType.NoValue) {
                        node = addNodeTo(element, false);
                        node.className = getClasses(type, options.cssClasses.value);
                        node.setAttribute("data-value", String(value));
                        node.style[options.style] = offset + "%";
                        node.innerHTML = String(formatter.to(value));
                    }
                }
                Object.keys(spread).forEach((function(offset) {
                    addSpread(offset, spread[offset][0], spread[offset][1]);
                }));
                return element;
            }
            function removePips() {
                if (scope_Pips) {
                    removeElement(scope_Pips);
                    scope_Pips = null;
                }
            }
            function pips(pips) {
                removePips();
                var spread = generateSpread(pips);
                var filter = pips.filter;
                var format = pips.format || {
                    to: function(value) {
                        return String(Math.round(value));
                    }
                };
                scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
                return scope_Pips;
            }
            function baseSize() {
                var rect = scope_Base.getBoundingClientRect();
                var alt = "offset" + [ "Width", "Height" ][options.ort];
                return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
            }
            function attachEvent(events, element, callback, data) {
                var method = function(event) {
                    var e = fixEvent(event, data.pageOffset, data.target || element);
                    if (!e) return false;
                    if (isSliderDisabled() && !data.doNotReject) return false;
                    if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) return false;
                    if (events === actions.start && e.buttons !== void 0 && e.buttons > 1) return false;
                    if (data.hover && e.buttons) return false;
                    if (!supportsPassive) e.preventDefault();
                    e.calcPoint = e.points[options.ort];
                    callback(e, data);
                    return;
                };
                var methods = [];
                events.split(" ").forEach((function(eventName) {
                    element.addEventListener(eventName, method, supportsPassive ? {
                        passive: true
                    } : false);
                    methods.push([ eventName, method ]);
                }));
                return methods;
            }
            function fixEvent(e, pageOffset, eventTarget) {
                var touch = e.type.indexOf("touch") === 0;
                var mouse = e.type.indexOf("mouse") === 0;
                var pointer = e.type.indexOf("pointer") === 0;
                var x = 0;
                var y = 0;
                if (e.type.indexOf("MSPointer") === 0) pointer = true;
                if (e.type === "mousedown" && !e.buttons && !e.touches) return false;
                if (touch) {
                    var isTouchOnTarget = function(checkTouch) {
                        var target = checkTouch.target;
                        return target === eventTarget || eventTarget.contains(target) || e.composed && e.composedPath().shift() === eventTarget;
                    };
                    if (e.type === "touchstart") {
                        var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                        if (targetTouches.length > 1) return false;
                        x = targetTouches[0].pageX;
                        y = targetTouches[0].pageY;
                    } else {
                        var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                        if (!targetTouch) return false;
                        x = targetTouch.pageX;
                        y = targetTouch.pageY;
                    }
                }
                pageOffset = pageOffset || getPageOffset(scope_Document);
                if (mouse || pointer) {
                    x = e.clientX + pageOffset.x;
                    y = e.clientY + pageOffset.y;
                }
                e.pageOffset = pageOffset;
                e.points = [ x, y ];
                e.cursor = mouse || pointer;
                return e;
            }
            function calcPointToPercentage(calcPoint) {
                var location = calcPoint - offset(scope_Base, options.ort);
                var proposal = location * 100 / baseSize();
                proposal = limit(proposal);
                return options.dir ? 100 - proposal : proposal;
            }
            function getClosestHandle(clickedPosition) {
                var smallestDifference = 100;
                var handleNumber = false;
                scope_Handles.forEach((function(handle, index) {
                    if (isHandleDisabled(index)) return;
                    var handlePosition = scope_Locations[index];
                    var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
                    var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
                    var isCloser = differenceWithThisHandle < smallestDifference;
                    var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
                    if (isCloser || isCloserAfter || clickAtEdge) {
                        handleNumber = index;
                        smallestDifference = differenceWithThisHandle;
                    }
                }));
                return handleNumber;
            }
            function documentLeave(event, data) {
                if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) eventEnd(event, data);
            }
            function eventMove(event, data) {
                if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) return eventEnd(event, data);
                var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
                var proposal = movement * 100 / data.baseSize;
                moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
            }
            function eventEnd(event, data) {
                if (data.handle) {
                    removeClass(data.handle, options.cssClasses.active);
                    scope_ActiveHandlesCount -= 1;
                }
                data.listeners.forEach((function(c) {
                    scope_DocumentElement.removeEventListener(c[0], c[1]);
                }));
                if (scope_ActiveHandlesCount === 0) {
                    removeClass(scope_Target, options.cssClasses.drag);
                    setZindex();
                    if (event.cursor) {
                        scope_Body.style.cursor = "";
                        scope_Body.removeEventListener("selectstart", preventDefault);
                    }
                }
                if (options.events.smoothSteps) {
                    data.handleNumbers.forEach((function(handleNumber) {
                        setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
                    }));
                    data.handleNumbers.forEach((function(handleNumber) {
                        fireEvent("update", handleNumber);
                    }));
                }
                data.handleNumbers.forEach((function(handleNumber) {
                    fireEvent("change", handleNumber);
                    fireEvent("set", handleNumber);
                    fireEvent("end", handleNumber);
                }));
            }
            function eventStart(event, data) {
                if (data.handleNumbers.some(isHandleDisabled)) return;
                var handle;
                if (data.handleNumbers.length === 1) {
                    var handleOrigin = scope_Handles[data.handleNumbers[0]];
                    handle = handleOrigin.children[0];
                    scope_ActiveHandlesCount += 1;
                    addClass(handle, options.cssClasses.active);
                }
                event.stopPropagation();
                var listeners = [];
                var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                    target: event.target,
                    handle,
                    connect: data.connect,
                    listeners,
                    startCalcPoint: event.calcPoint,
                    baseSize: baseSize(),
                    pageOffset: event.pageOffset,
                    handleNumbers: data.handleNumbers,
                    buttonsProperty: event.buttons,
                    locations: scope_Locations.slice()
                });
                var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                    target: event.target,
                    handle,
                    listeners,
                    doNotReject: true,
                    handleNumbers: data.handleNumbers
                });
                var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                    target: event.target,
                    handle,
                    listeners,
                    doNotReject: true,
                    handleNumbers: data.handleNumbers
                });
                listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
                if (event.cursor) {
                    scope_Body.style.cursor = getComputedStyle(event.target).cursor;
                    if (scope_Handles.length > 1) addClass(scope_Target, options.cssClasses.drag);
                    scope_Body.addEventListener("selectstart", preventDefault, false);
                }
                data.handleNumbers.forEach((function(handleNumber) {
                    fireEvent("start", handleNumber);
                }));
            }
            function eventTap(event) {
                event.stopPropagation();
                var proposal = calcPointToPercentage(event.calcPoint);
                var handleNumber = getClosestHandle(proposal);
                if (handleNumber === false) return;
                if (!options.events.snap) addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
                setHandle(handleNumber, proposal, true, true);
                setZindex();
                fireEvent("slide", handleNumber, true);
                fireEvent("update", handleNumber, true);
                if (!options.events.snap) {
                    fireEvent("change", handleNumber, true);
                    fireEvent("set", handleNumber, true);
                } else eventStart(event, {
                    handleNumbers: [ handleNumber ]
                });
            }
            function eventHover(event) {
                var proposal = calcPointToPercentage(event.calcPoint);
                var to = scope_Spectrum.getStep(proposal);
                var value = scope_Spectrum.fromStepping(to);
                Object.keys(scope_Events).forEach((function(targetEvent) {
                    if ("hover" === targetEvent.split(".")[0]) scope_Events[targetEvent].forEach((function(callback) {
                        callback.call(scope_Self, value);
                    }));
                }));
            }
            function eventKeydown(event, handleNumber) {
                if (isSliderDisabled() || isHandleDisabled(handleNumber)) return false;
                var horizontalKeys = [ "Left", "Right" ];
                var verticalKeys = [ "Down", "Up" ];
                var largeStepKeys = [ "PageDown", "PageUp" ];
                var edgeKeys = [ "Home", "End" ];
                if (options.dir && !options.ort) horizontalKeys.reverse(); else if (options.ort && !options.dir) {
                    verticalKeys.reverse();
                    largeStepKeys.reverse();
                }
                var key = event.key.replace("Arrow", "");
                var isLargeDown = key === largeStepKeys[0];
                var isLargeUp = key === largeStepKeys[1];
                var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
                var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
                var isMin = key === edgeKeys[0];
                var isMax = key === edgeKeys[1];
                if (!isDown && !isUp && !isMin && !isMax) return true;
                event.preventDefault();
                var to;
                if (isUp || isDown) {
                    var direction = isDown ? 0 : 1;
                    var steps = getNextStepsForHandle(handleNumber);
                    var step = steps[direction];
                    if (step === null) return false;
                    if (step === false) step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
                    if (isLargeUp || isLargeDown) step *= options.keyboardPageMultiplier; else step *= options.keyboardMultiplier;
                    step = Math.max(step, 1e-7);
                    step *= isDown ? -1 : 1;
                    to = scope_Values[handleNumber] + step;
                } else if (isMax) to = options.spectrum.xVal[options.spectrum.xVal.length - 1]; else to = options.spectrum.xVal[0];
                setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
                fireEvent("slide", handleNumber);
                fireEvent("update", handleNumber);
                fireEvent("change", handleNumber);
                fireEvent("set", handleNumber);
                return false;
            }
            function bindSliderEvents(behaviour) {
                if (!behaviour.fixed) scope_Handles.forEach((function(handle, index) {
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [ index ]
                    });
                }));
                if (behaviour.tap) attachEvent(actions.start, scope_Base, eventTap, {});
                if (behaviour.hover) attachEvent(actions.move, scope_Base, eventHover, {
                    hover: true
                });
                if (behaviour.drag) scope_Connects.forEach((function(connect, index) {
                    if (connect === false || index === 0 || index === scope_Connects.length - 1) return;
                    var handleBefore = scope_Handles[index - 1];
                    var handleAfter = scope_Handles[index];
                    var eventHolders = [ connect ];
                    var handlesToDrag = [ handleBefore, handleAfter ];
                    var handleNumbersToDrag = [ index - 1, index ];
                    addClass(connect, options.cssClasses.draggable);
                    if (behaviour.fixed) {
                        eventHolders.push(handleBefore.children[0]);
                        eventHolders.push(handleAfter.children[0]);
                    }
                    if (behaviour.dragAll) {
                        handlesToDrag = scope_Handles;
                        handleNumbersToDrag = scope_HandleNumbers;
                    }
                    eventHolders.forEach((function(eventHolder) {
                        attachEvent(actions.start, eventHolder, eventStart, {
                            handles: handlesToDrag,
                            handleNumbers: handleNumbersToDrag,
                            connect
                        });
                    }));
                }));
            }
            function bindEvent(namespacedEvent, callback) {
                scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
                scope_Events[namespacedEvent].push(callback);
                if (namespacedEvent.split(".")[0] === "update") scope_Handles.forEach((function(a, index) {
                    fireEvent("update", index);
                }));
            }
            function isInternalNamespace(namespace) {
                return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
            }
            function removeEvent(namespacedEvent) {
                var event = namespacedEvent && namespacedEvent.split(".")[0];
                var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
                Object.keys(scope_Events).forEach((function(bind) {
                    var tEvent = bind.split(".")[0];
                    var tNamespace = bind.substring(tEvent.length);
                    if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) if (!isInternalNamespace(tNamespace) || namespace === tNamespace) delete scope_Events[bind];
                }));
            }
            function fireEvent(eventName, handleNumber, tap) {
                Object.keys(scope_Events).forEach((function(targetEvent) {
                    var eventType = targetEvent.split(".")[0];
                    if (eventName === eventType) scope_Events[targetEvent].forEach((function(callback) {
                        callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || false, scope_Locations.slice(), scope_Self);
                    }));
                }));
            }
            function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
                var distance;
                if (scope_Handles.length > 1 && !options.events.unconstrained) {
                    if (lookBackward && handleNumber > 0) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
                        to = Math.max(to, distance);
                    }
                    if (lookForward && handleNumber < scope_Handles.length - 1) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
                        to = Math.min(to, distance);
                    }
                }
                if (scope_Handles.length > 1 && options.limit) {
                    if (lookBackward && handleNumber > 0) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
                        to = Math.min(to, distance);
                    }
                    if (lookForward && handleNumber < scope_Handles.length - 1) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
                        to = Math.max(to, distance);
                    }
                }
                if (options.padding) {
                    if (handleNumber === 0) {
                        distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
                        to = Math.max(to, distance);
                    }
                    if (handleNumber === scope_Handles.length - 1) {
                        distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
                        to = Math.min(to, distance);
                    }
                }
                if (!smoothSteps) to = scope_Spectrum.getStep(to);
                to = limit(to);
                if (to === reference[handleNumber] && !getValue) return false;
                return to;
            }
            function inRuleOrder(v, a) {
                var o = options.ort;
                return (o ? a : v) + ", " + (o ? v : a);
            }
            function moveHandles(upward, proposal, locations, handleNumbers, connect) {
                var proposals = locations.slice();
                var firstHandle = handleNumbers[0];
                var smoothSteps = options.events.smoothSteps;
                var b = [ !upward, upward ];
                var f = [ upward, !upward ];
                handleNumbers = handleNumbers.slice();
                if (upward) handleNumbers.reverse();
                if (handleNumbers.length > 1) handleNumbers.forEach((function(handleNumber, o) {
                    var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps);
                    if (to === false) proposal = 0; else {
                        proposal = to - proposals[handleNumber];
                        proposals[handleNumber] = to;
                    }
                })); else b = f = [ true ];
                var state = false;
                handleNumbers.forEach((function(handleNumber, o) {
                    state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;
                }));
                if (state) {
                    handleNumbers.forEach((function(handleNumber) {
                        fireEvent("update", handleNumber);
                        fireEvent("slide", handleNumber);
                    }));
                    if (connect != void 0) fireEvent("drag", firstHandle);
                }
            }
            function transformDirection(a, b) {
                return options.dir ? 100 - a - b : a;
            }
            function updateHandlePosition(handleNumber, to) {
                scope_Locations[handleNumber] = to;
                scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
                var translation = transformDirection(to, 0) - scope_DirOffset;
                var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
                scope_Handles[handleNumber].style[options.transformRule] = translateRule;
                if (options.events.invertConnects && scope_Locations.length > 1) {
                    var handlesAreInOrder = scope_Locations.every((function(position, index, locations) {
                        return index === 0 || position >= locations[index - 1];
                    }));
                    if (scope_ConnectsInverted !== !handlesAreInOrder) {
                        invertConnects();
                        return;
                    }
                }
                updateConnect(handleNumber);
                updateConnect(handleNumber + 1);
                if (scope_ConnectsInverted) {
                    updateConnect(handleNumber - 1);
                    updateConnect(handleNumber + 2);
                }
            }
            function setZindex() {
                scope_HandleNumbers.forEach((function(handleNumber) {
                    var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
                    var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
                    scope_Handles[handleNumber].style.zIndex = String(zIndex);
                }));
            }
            function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
                if (!exactInput) to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
                if (to === false) return false;
                updateHandlePosition(handleNumber, to);
                return true;
            }
            function updateConnect(index) {
                if (!scope_Connects[index]) return;
                var locations = scope_Locations.slice();
                if (scope_ConnectsInverted) locations.sort((function(a, b) {
                    return a - b;
                }));
                var l = 0;
                var h = 100;
                if (index !== 0) l = locations[index - 1];
                if (index !== scope_Connects.length - 1) h = locations[index];
                var connectWidth = h - l;
                var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
                var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
                scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
            }
            function resolveToValue(to, handleNumber) {
                if (to === null || to === false || to === void 0) return scope_Locations[handleNumber];
                if (typeof to === "number") to = String(to);
                to = options.format.from(to);
                if (to !== false) to = scope_Spectrum.toStepping(to);
                if (to === false || isNaN(to)) return scope_Locations[handleNumber];
                return to;
            }
            function valueSet(input, fireSetEvent, exactInput) {
                var values = asArray(input);
                var isInit = scope_Locations[0] === void 0;
                fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
                if (options.animate && !isInit) addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
                scope_HandleNumbers.forEach((function(handleNumber) {
                    setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
                }));
                var i = scope_HandleNumbers.length === 1 ? 0 : 1;
                if (isInit && scope_Spectrum.hasNoSize()) {
                    exactInput = true;
                    scope_Locations[0] = 0;
                    if (scope_HandleNumbers.length > 1) {
                        var space_1 = 100 / (scope_HandleNumbers.length - 1);
                        scope_HandleNumbers.forEach((function(handleNumber) {
                            scope_Locations[handleNumber] = handleNumber * space_1;
                        }));
                    }
                }
                for (;i < scope_HandleNumbers.length; ++i) scope_HandleNumbers.forEach((function(handleNumber) {
                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
                }));
                setZindex();
                scope_HandleNumbers.forEach((function(handleNumber) {
                    fireEvent("update", handleNumber);
                    if (values[handleNumber] !== null && fireSetEvent) fireEvent("set", handleNumber);
                }));
            }
            function valueReset(fireSetEvent) {
                valueSet(options.start, fireSetEvent);
            }
            function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
                handleNumber = Number(handleNumber);
                if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
                setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
                fireEvent("update", handleNumber);
                if (fireSetEvent) fireEvent("set", handleNumber);
            }
            function valueGet(unencoded) {
                if (unencoded === void 0) unencoded = false;
                if (unencoded) return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
                var values = scope_Values.map(options.format.to);
                if (values.length === 1) return values[0];
                return values;
            }
            function destroy() {
                removeEvent(INTERNAL_EVENT_NS.aria);
                removeEvent(INTERNAL_EVENT_NS.tooltips);
                Object.keys(options.cssClasses).forEach((function(key) {
                    removeClass(scope_Target, options.cssClasses[key]);
                }));
                while (scope_Target.firstChild) scope_Target.removeChild(scope_Target.firstChild);
                delete scope_Target.noUiSlider;
            }
            function getNextStepsForHandle(handleNumber) {
                var location = scope_Locations[handleNumber];
                var nearbySteps = scope_Spectrum.getNearbySteps(location);
                var value = scope_Values[handleNumber];
                var increment = nearbySteps.thisStep.step;
                var decrement = null;
                if (options.snap) return [ value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null ];
                if (increment !== false) if (value + increment > nearbySteps.stepAfter.startValue) increment = nearbySteps.stepAfter.startValue - value;
                if (value > nearbySteps.thisStep.startValue) decrement = nearbySteps.thisStep.step; else if (nearbySteps.stepBefore.step === false) decrement = false; else decrement = value - nearbySteps.stepBefore.highestStep;
                if (location === 100) increment = null; else if (location === 0) decrement = null;
                var stepDecimals = scope_Spectrum.countStepDecimals();
                if (increment !== null && increment !== false) increment = Number(increment.toFixed(stepDecimals));
                if (decrement !== null && decrement !== false) decrement = Number(decrement.toFixed(stepDecimals));
                return [ decrement, increment ];
            }
            function getNextSteps() {
                return scope_HandleNumbers.map(getNextStepsForHandle);
            }
            function updateOptions(optionsToUpdate, fireSetEvent) {
                var v = valueGet();
                var updateAble = [ "margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips", "connect" ];
                updateAble.forEach((function(name) {
                    if (optionsToUpdate[name] !== void 0) originalOptions[name] = optionsToUpdate[name];
                }));
                var newOptions = testOptions(originalOptions);
                updateAble.forEach((function(name) {
                    if (optionsToUpdate[name] !== void 0) options[name] = newOptions[name];
                }));
                scope_Spectrum = newOptions.spectrum;
                options.margin = newOptions.margin;
                options.limit = newOptions.limit;
                options.padding = newOptions.padding;
                if (options.pips) pips(options.pips); else removePips();
                if (options.tooltips) tooltips(); else removeTooltips();
                scope_Locations = [];
                valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
                if (optionsToUpdate.connect) updateConnectOption();
            }
            function updateConnectOption() {
                while (scope_ConnectBase.firstChild) scope_ConnectBase.removeChild(scope_ConnectBase.firstChild);
                for (var i = 0; i <= options.handles; i++) {
                    scope_Connects[i] = addConnect(scope_ConnectBase, options.connect[i]);
                    updateConnect(i);
                }
                bindSliderEvents({
                    drag: options.events.drag,
                    fixed: true
                });
            }
            function invertConnects() {
                scope_ConnectsInverted = !scope_ConnectsInverted;
                testConnect(options, options.connect.map((function(b) {
                    return !b;
                })));
                updateConnectOption();
            }
            function setupSlider() {
                scope_Base = addSlider(scope_Target);
                addElements(options.connect, scope_Base);
                bindSliderEvents(options.events);
                valueSet(options.start);
                if (options.pips) pips(options.pips);
                if (options.tooltips) tooltips();
                aria();
            }
            setupSlider();
            var scope_Self = {
                destroy,
                steps: getNextSteps,
                on: bindEvent,
                off: removeEvent,
                get: valueGet,
                set: valueSet,
                setHandle: valueSetHandle,
                reset: valueReset,
                disable,
                enable,
                __moveHandles: function(upward, proposal, handleNumbers) {
                    moveHandles(upward, proposal, scope_Locations, handleNumbers);
                },
                options: originalOptions,
                updateOptions,
                target: scope_Target,
                removePips,
                removeTooltips,
                getPositions: function() {
                    return scope_Locations.slice();
                },
                getTooltips: function() {
                    return scope_Tooltips;
                },
                getOrigins: function() {
                    return scope_Handles;
                },
                pips
            };
            return scope_Self;
        }
        function initialize(target, originalOptions) {
            if (!target || !target.nodeName) throw new Error("noUiSlider: create requires a single element, got: " + target);
            if (target.noUiSlider) throw new Error("noUiSlider: Slider was already initialized.");
            var options = testOptions(originalOptions);
            var api = scope(target, options, originalOptions);
            target.noUiSlider = api;
            return api;
        }
        function rangeInit() {
            const rangeHight = document.getElementById("range-hight");
            const rangeWeight = document.getElementById("range-weight");
            var rangeHightValue = document.getElementById("range-span-hight");
            var rangeWeightValue = document.getElementById("range-span-weight");
            if (rangeHight, rangeWeight !== null) {
                initialize(rangeHight, {
                    start: 180,
                    animate: false,
                    connect: [ true, false ],
                    range: {
                        min: 50,
                        max: 220
                    }
                });
                rangeHight.noUiSlider.on("update", (function(values, handle) {
                    rangeHightValue.innerHTML = values[handle];
                    rangeHightValue.innerHTML = parseFloat(values[handle]).toFixed(0);
                }));
                initialize(rangeWeight, {
                    start: 74,
                    animate: false,
                    connect: [ true, false ],
                    range: {
                        min: 50,
                        max: 90
                    }
                });
                rangeWeight.noUiSlider.on("update", (function(values, handle) {
                    rangeWeightValue.innerHTML = values[handle];
                    rangeWeightValue.innerHTML = parseFloat(values[handle]).toFixed(0);
                }));
            }
            const rangeOld = document.getElementById("range-old");
            var rangeOldValue = document.getElementById("range-span-old");
            const rangeOldSearch = document.getElementById("range-old-search");
            var rangeOldSearchValue = document.getElementById("range-span-search-old");
            if (rangeOld, rangeOldValue !== null) {
                initialize(rangeOld, {
                    start: [ 25, 50 ],
                    animate: false,
                    connect: true,
                    range: {
                        min: 18,
                        max: 70
                    }
                });
                rangeOld.noUiSlider.on("update", (function(values, handle) {
                    rangeOldValue.innerHTML = Math.round(values[0]) + " - " + Math.round(values[1]);
                }));
            }
            if (rangeOldSearch, rangeOldSearchValue !== null) {
                initialize(rangeOldSearch, {
                    start: [ 25, 50 ],
                    animate: false,
                    connect: true,
                    range: {
                        min: 18,
                        max: 70
                    }
                });
                rangeOldSearch.noUiSlider.on("update", (function(values, handle) {
                    rangeOldSearchValue.innerHTML = Math.round(values[0]) + " - " + Math.round(values[1]);
                }));
            }
            const rangeHightScope = document.getElementById("range-hight-scope");
            const rangeWeightScope = document.getElementById("range-weight-scope");
            var rangeHightValueScope = document.getElementById("range-scope-hight");
            var rangeWeightValueScope = document.getElementById("range-scope-weight");
            if (rangeHightScope, rangeWeightScope !== null) {
                initialize(rangeHightScope, {
                    start: [ 155, 175 ],
                    animate: false,
                    connect: true,
                    range: {
                        min: 150,
                        max: 220
                    }
                });
                rangeHightScope.noUiSlider.on("update", (function(values, handle) {
                    rangeHightValueScope.innerHTML = Math.round(values[0]) + " - " + Math.round(values[1]);
                }));
                initialize(rangeWeightScope, {
                    start: [ 65, 85 ],
                    animate: false,
                    connect: true,
                    range: {
                        min: 50,
                        max: 120
                    }
                });
                rangeWeightScope.noUiSlider.on("update", (function(values, handle) {
                    rangeWeightValueScope.innerHTML = Math.round(values[0]) + " - " + Math.round(values[1]);
                }));
            }
        }
        rangeInit();
        function ssr_window_esm_isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target, src) {
            if (target === void 0) target = {};
            if (src === void 0) src = {};
            Object.keys(src).forEach((key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function utils_classesToTokens(classes) {
            if (classes === void 0) classes = "";
            return classes.trim().split(" ").filter((c => !!c.trim()));
        }
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay) {
            if (delay === void 0) delay = 0;
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis) {
            if (axis === void 0) axis = "x";
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function utils_extend() {
            const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < arguments.length; i += 1) {
                const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll(_ref) {
            let {swiper, targetPosition, side} = _ref;
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function utils_getSlideTransformEl(slideEl) {
            return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
        }
        function utils_elementChildren(element, selector) {
            if (selector === void 0) selector = "";
            const children = [ ...element.children ];
            if (element instanceof HTMLSlotElement) children.push(...element.assignedElements());
            if (!selector) return children;
            return children.filter((el => el.matches(selector)));
        }
        function elementIsChildOf(el, parent) {
            const isChild = parent.contains(el);
            if (!isChild && parent instanceof HTMLSlotElement) {
                const children = [ ...parent.assignedElements() ];
                return children.includes(el);
            }
            return isChild;
        }
        function showWarning(text) {
            try {
                console.warn(text);
                return;
            } catch (err) {}
        }
        function utils_createElement(tag, classes) {
            if (classes === void 0) classes = [];
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : utils_classesToTokens(classes));
            return el;
        }
        function elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function elementStyle(el, prop) {
            const window = ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function utils_elementTransitionEnd(el, callback) {
            function fireCallBack(e) {
                if (e.target !== el) return;
                callback.call(el, e);
                el.removeEventListener("transitionend", fireCallBack);
            }
            if (callback) el.addEventListener("transitionend", fireCallBack);
        }
        function elementOuterSize(el, size, includeMargins) {
            const window = ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        function utils_makeElementsArray(el) {
            return (Array.isArray(el) ? el : [ el ]).filter((e => !!e));
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice(_temp) {
            let {userAgent} = _temp === void 0 ? {} : _temp;
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides) {
            if (overrides === void 0) overrides = {};
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            const device = getDevice();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
            const isSafariBrowser = isSafari();
            const need3dFix = isSafariBrowser || isWebView && device.ios;
            return {
                isSafari: needPerspectiveFix || isSafariBrowser,
                needPerspectiveFix,
                need3dFix,
                isWebView
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize(_ref) {
            let {swiper, on, emit} = _ref;
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((_ref2 => {
                            let {contentBoxSize, contentRect, target} = _ref2;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = function(target, options) {
                if (options === void 0) options = {};
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = utils_elementParents(swiper.hostEl);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.hostEl, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        var eventsEmitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler() {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit() {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach((slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            }));
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slides); else if (swiper.grid) swiper.grid.unsetSlides();
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slides);
                if (slides[i] && elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[swiper.getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide, "width", true) : elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).forEach((slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                }));
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
                snapGrid = snapGrid.map((snap => {
                    if (snap <= 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
                if (allSlidesSize + offsetSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            swiper.emit("slidesUpdated");
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        const toggleSlideClasses$1 = (slideEl, condition, className) => {
            if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
        };
        function updateSlidesProgress(translate) {
            if (translate === void 0) translate = this && this.translate || 0;
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                }
                toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
                toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        const toggleSlideClasses = (slideEl, condition, className) => {
            if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
        };
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const getFilteredSlide = selector => utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            let activeSlide;
            let prevSlide;
            let nextSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else if (gridEnabled) {
                activeSlide = slides.filter((slideEl => slideEl.column === activeIndex))[0];
                nextSlide = slides.filter((slideEl => slideEl.column === activeIndex + 1))[0];
                prevSlide = slides.filter((slideEl => slideEl.column === activeIndex - 1))[0];
            } else activeSlide = slides[activeIndex];
            if (activeSlide) if (!gridEnabled) {
                nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !nextSlide) nextSlide = slides[0];
                prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
            }
            slides.forEach((slideEl => {
                toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
                toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
                toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
            }));
            swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (!lazyEl && swiper.isElement) if (slideEl.shadowRoot) lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`); else requestAnimationFrame((() => {
                    if (slideEl.shadowRoot) {
                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (lazyEl) lazyEl.remove();
                    }
                }));
                if (lazyEl) lazyEl.remove();
            }
        };
        const unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            if (swiper.params.grid && swiper.params.grid.rows > 1) {
                const activeColumn = activeIndex;
                const preloadColumns = [ activeColumn - amount ];
                preloadColumns.push(...Array.from({
                    length: amount
                }).map(((_, i) => activeColumn + slidesPerView + i)));
                swiper.slides.forEach(((slideEl, i) => {
                    if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
                }));
                return;
            }
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind || swiper.params.loop) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            } else for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) unlazy(swiper, i);
        };
        function getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex && !swiper.params.loop) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                return;
            }
            if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
                swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (gridEnabled) {
                const firstSlideInColumn = swiper.slides.filter((slideEl => slideEl.column === activeIndex))[0];
                let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
                if (Number.isNaN(activeSlideIndex)) activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
                realIndex = Math.floor(activeSlideIndex / params.grid.rows);
            } else if (swiper.slides[activeIndex]) {
                const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
                if (slideIndex) realIndex = parseInt(slideIndex, 10); else realIndex = activeIndex;
            } else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) {
                if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
                swiper.emit("slideChange");
            }
        }
        function updateClickedSlide(el, path) {
            const swiper = this;
            const params = swiper.params;
            let slide = el.closest(`.${params.slideClass}, swiper-slide`);
            if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) [ ...path.slice(path.indexOf(el) + 1, path.length) ].forEach((pathEl => {
                if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) slide = pathEl;
            }));
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        var update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis) {
            if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
            if (translate === void 0) translate = 0;
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (translateBounds === void 0) translateBounds = true;
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        swiper.animating = false;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        var translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) {
                swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
                swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
            }
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit(_ref) {
            let {swiper, runCallbacks, direction, step} = _ref;
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === "reset") {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        var transition = {
            setTransition,
            transitionStart,
            transitionEnd
        };
        function slideTo(index, speed, runCallbacks, internal, initial) {
            if (index === void 0) index = 0;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) return false;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const isInitialVirtual = isVirtual && initial;
            if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame((() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }));
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index, speed, runCallbacks, internal) {
            if (index === void 0) index = 0;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else {
                let targetSlideIndex;
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    targetSlideIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
                } else targetSlideIndex = swiper.getSlideIndexByData(newIndex);
                const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
                const {centeredSlides} = swiper.params;
                let slidesPerView = swiper.params.slidesPerView;
                if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                    slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                    if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
                }
                let needLoopFix = cols - targetSlideIndex < slidesPerView;
                if (centeredSlides) needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
                if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) needLoopFix = false;
                if (needLoopFix) {
                    const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
                    swiper.loopFix({
                        direction,
                        slideTo: true,
                        activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                        slideRealIndex: direction === "next" ? swiper.realIndex : void 0
                    });
                }
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    newIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
                } else newIndex = swiper.getSlideIndexByData(newIndex);
            }
            requestAnimationFrame((() => {
                swiper.slideTo(newIndex, speed, runCallbacks, internal);
            }));
            return swiper;
        }
        function slideNext(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
                if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
                    requestAnimationFrame((() => {
                        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
                    }));
                    return true;
                }
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
                requestAnimationFrame((() => {
                    swiper.slideTo(prevIndex, speed, runCallbacks, internal);
                }));
                return true;
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed, runCallbacks, internal, threshold) {
            if (runCallbacks === void 0) runCallbacks = true;
            if (threshold === void 0) threshold = .5;
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            if (swiper.destroyed) return;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        var slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate(slideRealIndex) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const initSlides = () => {
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                slides.forEach(((el, index) => {
                    el.setAttribute("data-swiper-slide-index", index);
                }));
            };
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
            const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
            const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
            const addBlankSlides = amountOfSlides => {
                for (let i = 0; i < amountOfSlides; i += 1) {
                    const slideEl = swiper.isElement ? utils_createElement("swiper-slide", [ params.slideBlankClass ]) : utils_createElement("div", [ params.slideClass, params.slideBlankClass ]);
                    swiper.slidesEl.append(slideEl);
                }
            };
            if (shouldFillGroup) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else if (shouldFillGrid) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else initSlides();
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next"
            });
        }
        function loopFix(_temp) {
            let {slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel} = _temp === void 0 ? {} : _temp;
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            const {centeredSlides} = params;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            let slidesPerView = params.slidesPerView;
            if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
                if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
            }
            const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
            let loopedSlides = slidesPerGroup;
            if (loopedSlides % slidesPerGroup !== 0) loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
            loopedSlides += params.loopAdditionalSlides;
            swiper.loopedSlides = loopedSlides;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            if (slides.length < slidesPerView + loopedSlides) showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"); else if (gridEnabled && params.grid.fill === "row") showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            let activeIndex = swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
            const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
            const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === "undefined" ? -slidesPerView / 2 + .5 : 0);
            if (activeColIndexWithShift < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) {
                        const colIndexToPrepend = cols - index - 1;
                        for (let i = slides.length - 1; i >= 0; i -= 1) if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
                    } else prependSlidesIndexes.push(cols - index - 1);
                }
            } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
                slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) slides.forEach(((slide, slideIndex) => {
                        if (slide.column === index) appendSlidesIndexes.push(slideIndex);
                    })); else appendSlidesIndexes.push(index);
                }
            }
            swiper.__preventObserver__ = true;
            requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
            if (isPrev) prependSlidesIndexes.forEach((index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            }));
            if (isNext) appendSlidesIndexes.forEach((index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            }));
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides(); else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) swiper.slides.forEach(((slide, slideIndex) => {
                swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
            }));
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                        if (setTranslate) {
                            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                        }
                    }
                } else if (setTranslate) {
                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                    swiper.touchEventsData.currentTranslate = swiper.translate;
                }
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c => {
                    if (!c.destroyed && c.params.loop) c.loopFix({
                        ...loopParams,
                        slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                    });
                })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix({
                    ...loopParams,
                    slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
                });
            }
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach((slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            }));
            swiper.slides.forEach((slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
            newSlidesOrder.forEach((slideEl => {
                slidesEl.append(slideEl);
            }));
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        var loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        var grabCursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base) {
            if (base === void 0) base = this;
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function preventEdgeSwipe(swiper, event, startX) {
            const window = ssr_window_esm_getWindow();
            const {params} = swiper;
            const edgeSwipeDetection = params.edgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
                if (edgeSwipeDetection === "prevent") {
                    event.preventDefault();
                    return true;
                }
                return false;
            }
            return true;
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            const data = swiper.touchEventsData;
            if (e.type === "pointerdown") {
                if (data.pointerId !== null && data.pointerId !== e.pointerId) return;
                data.pointerId = e.pointerId;
            } else if (e.type === "touchstart" && e.targetTouches.length === 1) data.touchId = e.targetTouches[0].identifier;
            if (e.type === "touchstart") {
                preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
                return;
            }
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = e.composedPath ? e.composedPath() : e.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            if (!preventEdgeSwipe(swiper, e, startX)) return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === "mouse" || e.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (e.type === "pointermove") {
                if (data.touchId !== null) return;
                const id = e.pointerId;
                if (id !== data.pointerId) return;
            }
            let targetTouch;
            if (e.type === "touchmove") {
                targetTouch = [ ...e.changedTouches ].filter((t => t.identifier === data.touchId))[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            } else targetTouch = e;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== "mouse") document.activeElement.blur();
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            touches.previousX = touches.currentX;
            touches.previousY = touches.currentY;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
            if (!data.isMoved) {
                if (isLoop && allowLoopFix) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true,
                        detail: {
                            bySwiperTouchMove: true
                        }
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            (new Date).getTime();
            if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY,
                    startTranslate: data.currentTranslate
                });
                data.loopSwapReset = true;
                data.startTranslate = data.currentTranslate;
                return;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetTouch;
            const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
            if (!isTouchEvent) {
                if (data.touchId !== null) return;
                if (e.pointerId !== data.pointerId) return;
                targetTouch = e;
            } else {
                targetTouch = [ ...e.changedTouches ].filter((t => t.identifier === data.touchId))[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            }
            if ([ "pointercancel", "pointerout", "pointerleave", "contextmenu" ].includes(e.type)) {
                const proceed = [ "pointercancel", "contextmenu" ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            data.pointerId = null;
            data.touchId = null;
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (swipeToLast || currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout((() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }), 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function onLoad(e) {
            const swiper = this;
            processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        function onDocumentTouchStart() {
            const swiper = this;
            if (swiper.documentTouchHandlerProceeded) return;
            swiper.documentTouchHandlerProceeded = true;
            if (swiper.params.touchReleaseOnEdges) swiper.el.style.touchAction = "auto";
        }
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            if (!el || typeof el === "string") return;
            document[domMethod]("touchstart", swiper.onDocumentTouchStart, {
                passive: false,
                capture
            });
            el[domMethod]("touchstart", swiper.onTouchStart, {
                passive: false
            });
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("touchmove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("touchend", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("touchcancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("contextmenu", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function attachEvents() {
            const swiper = this;
            const {params} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            swiper.onLoad = onLoad.bind(swiper);
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        var events$1 = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasGrabCursor = swiper.params.grabCursor;
            const isGrabCursor = breakpointParams.grabCursor;
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            if (wasGrabCursor && !isGrabCursor) swiper.unsetGrabCursor(); else if (!wasGrabCursor && isGrabCursor) swiper.setGrabCursor();
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                if (typeof breakpointParams[prop] === "undefined") return;
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            const wasLoop = params.loop;
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            const hasLoop = swiper.params.loop;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (initialized) if (needsReLoop) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (!wasLoop && hasLoop) {
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (wasLoop && !hasLoop) swiper.loopDestroy();
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base, containerEl) {
            if (base === void 0) base = "window";
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        var breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if (typeof item === "object") Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if (typeof item === "string") resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function swiper_core_removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            if (!el || typeof el === "string") return;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        var classes = {
            addClasses,
            removeClasses: swiper_core_removeClasses
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        var checkOverflow$1 = {
            checkOverflow
        };
        var defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            swiperElementNodeName: "SWIPER-CONTAINER",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            eventsPrefix: "swiper",
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopAddBlankSlides: true,
            loopAdditionalSlides: 0,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-blank",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideFullyVisibleClass: "swiper-slide-fully-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj) {
                if (obj === void 0) obj = {};
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) params[moduleParamName].auto = true;
                if ([ "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) params[moduleParamName].auto = true;
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter,
            update,
            translate,
            transition,
            slide,
            loop,
            grabCursor,
            events: events$1,
            breakpoints,
            checkOverflow: checkOverflow$1,
            classes
        };
        const extendedDefaults = {};
        class swiper_core_Swiper {
            constructor() {
                let el;
                let params;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new swiper_core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        pointerId: null,
                        touchId: null
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getDirectionLabel(property) {
                if (this.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = utils_elementIndex(slides[0]);
                return utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view, exact) {
                if (view === void 0) view = "current";
                if (exact === void 0) exact = false;
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (typeof params.slidesPerView === "number") return params.slidesPerView;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += Math.ceil(slides[i].swiperSlideSize);
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl);
                }));
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
                    setTranslate();
                    if (params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate) {
                if (needUpdate === void 0) needUpdate = true;
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach((slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                        wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
                    hostEl: swiper.isElement ? el.parentNode.host : el,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
                    wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate();
                swiper.attachEvents();
                const lazyElements = [ ...swiper.el.querySelectorAll('[loading="lazy"]') ];
                if (swiper.isElement) lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
                lazyElements.forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e => {
                        processLazyPreloader(swiper, e.target);
                    }));
                }));
                preload(swiper);
                swiper.initialized = true;
                preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance, cleanStyles) {
                if (deleteInstance === void 0) deleteInstance = true;
                if (cleanStyles === void 0) cleanStyles = true;
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    if (el && typeof el !== "string") el.removeAttribute("style");
                    if (wrapperEl) wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach((slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    }));
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (deleteInstance !== false) {
                    if (swiper.el && typeof swiper.el !== "string") swiper.el.swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!swiper_core_Swiper.prototype.__modules__) swiper_core_Swiper.prototype.__modules__ = [];
                const modules = swiper_core_Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => swiper_core_Swiper.installModule(m)));
                    return swiper_core_Swiper;
                }
                swiper_core_Swiper.installModule(module);
                return swiper_core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                swiper_core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        swiper_core_Swiper.use([ Resize, Observer ]);
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && params.auto === true) {
                    let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                    if (!element) {
                        element = utils_createElement("div", checkProps[key]);
                        element.className = checkProps[key];
                        swiper.el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function Navigation(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            });
            swiper.navigation = {
                nextEl: null,
                prevEl: null
            };
            function getEl(el) {
                let res;
                if (el && typeof el === "string" && swiper.isElement) {
                    res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
                    if (res) return res;
                }
                if (el) {
                    if (typeof el === "string") res = [ ...document.querySelectorAll(el) ];
                    if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el); else if (res && res.length === 1) res = res[0];
                }
                if (el && !res) return el;
                return res;
            }
            function toggleEl(el, disabled) {
                const params = swiper.params.navigation;
                el = utils_makeElementsArray(el);
                el.forEach((subEl => {
                    if (subEl) {
                        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                        if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                    }
                }));
            }
            function update() {
                const {nextEl, prevEl} = swiper.navigation;
                if (swiper.params.loop) {
                    toggleEl(prevEl, false);
                    toggleEl(nextEl, false);
                    return;
                }
                toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
                emit("navigationPrev");
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
                emit("navigationNext");
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                let nextEl = getEl(params.nextEl);
                let prevEl = getEl(params.prevEl);
                Object.assign(swiper.navigation, {
                    nextEl,
                    prevEl
                });
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                const initButton = (el, dir) => {
                    if (el) el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(" "));
                };
                nextEl.forEach((el => initButton(el, "next")));
                prevEl.forEach((el => initButton(el, "prev")));
            }
            function destroy() {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                const destroyButton = (el, dir) => {
                    el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
                };
                nextEl.forEach((el => destroyButton(el, "next")));
                prevEl.forEach((el => destroyButton(el, "prev")));
            }
            on("init", (() => {
                if (swiper.params.navigation.enabled === false) disable(); else {
                    init();
                    update();
                }
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                if (swiper.enabled) {
                    update();
                    return;
                }
                [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.add(swiper.params.navigation.lockClass)));
            }));
            on("click", ((_s, e) => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                const targetEl = e.target;
                let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
                if (swiper.isElement && !targetIsButton) {
                    const path = e.path || e.composedPath && e.composedPath();
                    if (path) targetIsButton = path.find((pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl)));
                }
                if (swiper.params.navigation.hideOnClick && !targetIsButton) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass); else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                    if (isHidden === true) emit("navigationShow"); else emit("navigationHide");
                    [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.toggle(swiper.params.navigation.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
                init();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
                destroy();
            };
            Object.assign(swiper.navigation, {
                enable,
                disable,
                update,
                init,
                destroy
            });
        }
        function classes_to_selector_classesToSelector(classes) {
            if (classes === void 0) classes = "";
            return `.${classes.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
        }
        function Pagination(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const pfx = "swiper-pagination";
            extendParams({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: false,
                    hideOnClick: false,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: false,
                    type: "bullets",
                    dynamicBullets: false,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: number => number,
                    formatFractionTotal: number => number,
                    bulletClass: `${pfx}-bullet`,
                    bulletActiveClass: `${pfx}-bullet-active`,
                    modifierClass: `${pfx}-`,
                    currentClass: `${pfx}-current`,
                    totalClass: `${pfx}-total`,
                    hiddenClass: `${pfx}-hidden`,
                    progressbarFillClass: `${pfx}-progressbar-fill`,
                    progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                    clickableClass: `${pfx}-clickable`,
                    lockClass: `${pfx}-lock`,
                    horizontalClass: `${pfx}-horizontal`,
                    verticalClass: `${pfx}-vertical`,
                    paginationDisabledClass: `${pfx}-disabled`
                }
            });
            swiper.pagination = {
                el: null,
                bullets: []
            };
            let bulletSize;
            let dynamicBulletIndex = 0;
            function isPaginationDisabled() {
                return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
            }
            function setSideBullets(bulletEl, position) {
                const {bulletActiveClass} = swiper.params.pagination;
                if (!bulletEl) return;
                bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                if (bulletEl) {
                    bulletEl.classList.add(`${bulletActiveClass}-${position}`);
                    bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                    if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
                }
            }
            function getMoveDirection(prevIndex, nextIndex, length) {
                prevIndex %= length;
                nextIndex %= length;
                if (nextIndex === prevIndex + 1) return "next"; else if (nextIndex === prevIndex - 1) return "previous";
                return;
            }
            function onBulletClick(e) {
                const bulletEl = e.target.closest(classes_to_selector_classesToSelector(swiper.params.pagination.bulletClass));
                if (!bulletEl) return;
                e.preventDefault();
                const index = utils_elementIndex(bulletEl) * swiper.params.slidesPerGroup;
                if (swiper.params.loop) {
                    if (swiper.realIndex === index) return;
                    const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
                    if (moveDirection === "next") swiper.slideNext(); else if (moveDirection === "previous") swiper.slidePrev(); else swiper.slideToLoop(index);
                } else swiper.slideTo(index);
            }
            function update() {
                const rtl = swiper.rtl;
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                el = utils_makeElementsArray(el);
                let current;
                let previousIndex;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.loop) {
                    previousIndex = swiper.previousRealIndex || 0;
                    current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
                } else if (typeof swiper.snapIndex !== "undefined") {
                    current = swiper.snapIndex;
                    previousIndex = swiper.previousSnapIndex;
                } else {
                    previousIndex = swiper.previousIndex || 0;
                    current = swiper.activeIndex || 0;
                }
                if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                    const bullets = swiper.pagination.bullets;
                    let firstIndex;
                    let lastIndex;
                    let midIndex;
                    if (params.dynamicBullets) {
                        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
                        el.forEach((subEl => {
                            subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                        }));
                        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
                            dynamicBulletIndex += current - (previousIndex || 0);
                            if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                        }
                        firstIndex = Math.max(current - dynamicBulletIndex, 0);
                        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                        midIndex = (lastIndex + firstIndex) / 2;
                    }
                    bullets.forEach((bulletEl => {
                        const classesToRemove = [ ...[ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map((suffix => `${params.bulletActiveClass}${suffix}`)) ].map((s => typeof s === "string" && s.includes(" ") ? s.split(" ") : s)).flat();
                        bulletEl.classList.remove(...classesToRemove);
                    }));
                    if (el.length > 1) bullets.forEach((bullet => {
                        const bulletIndex = utils_elementIndex(bullet);
                        if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(" ")); else if (swiper.isElement) bullet.setAttribute("part", "bullet");
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            if (bulletIndex === firstIndex) setSideBullets(bullet, "prev");
                            if (bulletIndex === lastIndex) setSideBullets(bullet, "next");
                        }
                    })); else {
                        const bullet = bullets[current];
                        if (bullet) bullet.classList.add(...params.bulletActiveClass.split(" "));
                        if (swiper.isElement) bullets.forEach(((bulletEl, bulletIndex) => {
                            bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
                        }));
                        if (params.dynamicBullets) {
                            const firstDisplayedBullet = bullets[firstIndex];
                            const lastDisplayedBullet = bullets[lastIndex];
                            for (let i = firstIndex; i <= lastIndex; i += 1) if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            setSideBullets(firstDisplayedBullet, "prev");
                            setSideBullets(lastDisplayedBullet, "next");
                        }
                    }
                    if (params.dynamicBullets) {
                        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                        const offsetProp = rtl ? "right" : "left";
                        bullets.forEach((bullet => {
                            bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
                        }));
                    }
                }
                el.forEach(((subEl, subElIndex) => {
                    if (params.type === "fraction") {
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.currentClass)).forEach((fractionEl => {
                            fractionEl.textContent = params.formatFractionCurrent(current + 1);
                        }));
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.totalClass)).forEach((totalEl => {
                            totalEl.textContent = params.formatFractionTotal(total);
                        }));
                    }
                    if (params.type === "progressbar") {
                        let progressbarDirection;
                        if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                        const scale = (current + 1) / total;
                        let scaleX = 1;
                        let scaleY = 1;
                        if (progressbarDirection === "horizontal") scaleX = scale; else scaleY = scale;
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.progressbarFillClass)).forEach((progressEl => {
                            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                        }));
                    }
                    if (params.type === "custom" && params.renderCustom) {
                        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                        if (subElIndex === 0) emit("paginationRender", subEl);
                    } else {
                        if (subElIndex === 0) emit("paginationRender", subEl);
                        emit("paginationUpdate", subEl);
                    }
                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                }));
            }
            function render() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
                let el = swiper.pagination.el;
                el = utils_makeElementsArray(el);
                let paginationHTML = "";
                if (params.type === "bullets") {
                    let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                    if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
                    for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
                }
                if (params.type === "fraction") if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
                if (params.type === "progressbar") if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                swiper.pagination.bullets = [];
                el.forEach((subEl => {
                    if (params.type !== "custom") subEl.innerHTML = paginationHTML || "";
                    if (params.type === "bullets") swiper.pagination.bullets.push(...subEl.querySelectorAll(classes_to_selector_classesToSelector(params.bulletClass)));
                }));
                if (params.type !== "custom") emit("paginationRender", el[0]);
            }
            function init() {
                swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                    el: "swiper-pagination"
                });
                const params = swiper.params.pagination;
                if (!params.el) return;
                let el;
                if (typeof params.el === "string" && swiper.isElement) el = swiper.el.querySelector(params.el);
                if (!el && typeof params.el === "string") el = [ ...document.querySelectorAll(params.el) ];
                if (!el) el = params.el;
                if (!el || el.length === 0) return;
                if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
                    el = [ ...swiper.el.querySelectorAll(params.el) ];
                    if (el.length > 1) el = el.filter((subEl => {
                        if (utils_elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                        return true;
                    }))[0];
                }
                if (Array.isArray(el) && el.length === 1) el = el[0];
                Object.assign(swiper.pagination, {
                    el
                });
                el = utils_makeElementsArray(el);
                el.forEach((subEl => {
                    if (params.type === "bullets" && params.clickable) subEl.classList.add(...(params.clickableClass || "").split(" "));
                    subEl.classList.add(params.modifierClass + params.type);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                    if (params.type === "bullets" && params.dynamicBullets) {
                        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                        dynamicBulletIndex = 0;
                        if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
                    }
                    if (params.type === "progressbar" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);
                    if (params.clickable) subEl.addEventListener("click", onBulletClick);
                    if (!swiper.enabled) subEl.classList.add(params.lockClass);
                }));
            }
            function destroy() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => {
                        subEl.classList.remove(params.hiddenClass);
                        subEl.classList.remove(params.modifierClass + params.type);
                        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        if (params.clickable) {
                            subEl.classList.remove(...(params.clickableClass || "").split(" "));
                            subEl.removeEventListener("click", onBulletClick);
                        }
                    }));
                }
                if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl => subEl.classList.remove(...params.bulletActiveClass.split(" "))));
            }
            on("changeDirection", (() => {
                if (!swiper.pagination || !swiper.pagination.el) return;
                const params = swiper.params.pagination;
                let {el} = swiper.pagination;
                el = utils_makeElementsArray(el);
                el.forEach((subEl => {
                    subEl.classList.remove(params.horizontalClass, params.verticalClass);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                }));
            }));
            on("init", (() => {
                if (swiper.params.pagination.enabled === false) disable(); else {
                    init();
                    render();
                    update();
                }
            }));
            on("activeIndexChange", (() => {
                if (typeof swiper.snapIndex === "undefined") update();
            }));
            on("snapIndexChange", (() => {
                update();
            }));
            on("snapGridLengthChange", (() => {
                render();
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass)));
                }
            }));
            on("lock unlock", (() => {
                update();
            }));
            on("click", ((_s, e) => {
                const targetEl = e.target;
                const el = utils_makeElementsArray(swiper.pagination.el);
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
                    if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                    const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
                    if (isHidden === true) emit("paginationShow"); else emit("paginationHide");
                    el.forEach((subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass)));
                }
                init();
                render();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass)));
                }
                destroy();
            };
            Object.assign(swiper.pagination, {
                enable,
                disable,
                render,
                update,
                init,
                destroy
            });
        }
        function Autoplay(_ref) {
            let {swiper, extendParams, on, emit, params} = _ref;
            swiper.autoplay = {
                running: false,
                paused: false,
                timeLeft: 0
            };
            extendParams({
                autoplay: {
                    enabled: false,
                    delay: 3e3,
                    waitForTransition: true,
                    disableOnInteraction: false,
                    stopOnLastSlide: false,
                    reverseDirection: false,
                    pauseOnMouseEnter: false
                }
            });
            let timeout;
            let raf;
            let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
            let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
            let autoplayTimeLeft;
            let autoplayStartTime = (new Date).getTime();
            let wasPaused;
            let isTouched;
            let pausedByTouch;
            let touchStartTimeout;
            let slideChanged;
            let pausedByInteraction;
            let pausedByPointerEnter;
            function onTransitionEnd(e) {
                if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
                if (e.target !== swiper.wrapperEl) return;
                swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
                if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) return;
                resume();
            }
            const calcTimeLeft = () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.autoplay.paused) wasPaused = true; else if (wasPaused) {
                    autoplayDelayCurrent = autoplayTimeLeft;
                    wasPaused = false;
                }
                const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (new Date).getTime();
                swiper.autoplay.timeLeft = timeLeft;
                emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
                raf = requestAnimationFrame((() => {
                    calcTimeLeft();
                }));
            };
            const getSlideDelay = () => {
                let activeSlideEl;
                if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.filter((slideEl => slideEl.classList.contains("swiper-slide-active")))[0]; else activeSlideEl = swiper.slides[swiper.activeIndex];
                if (!activeSlideEl) return;
                const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
                return currentSlideDelay;
            };
            const run = delayForce => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                cancelAnimationFrame(raf);
                calcTimeLeft();
                let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
                autoplayDelayTotal = swiper.params.autoplay.delay;
                autoplayDelayCurrent = swiper.params.autoplay.delay;
                const currentSlideDelay = getSlideDelay();
                if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
                    delay = currentSlideDelay;
                    autoplayDelayTotal = currentSlideDelay;
                    autoplayDelayCurrent = currentSlideDelay;
                }
                autoplayTimeLeft = delay;
                const speed = swiper.params.speed;
                const proceed = () => {
                    if (!swiper || swiper.destroyed) return;
                    if (swiper.params.autoplay.reverseDirection) {
                        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                            swiper.slidePrev(speed, true, true);
                            emit("autoplay");
                        } else if (!swiper.params.autoplay.stopOnLastSlide) {
                            swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                            emit("autoplay");
                        }
                    } else if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                        swiper.slideNext(speed, true, true);
                        emit("autoplay");
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        swiper.slideTo(0, speed, true, true);
                        emit("autoplay");
                    }
                    if (swiper.params.cssMode) {
                        autoplayStartTime = (new Date).getTime();
                        requestAnimationFrame((() => {
                            run();
                        }));
                    }
                };
                if (delay > 0) {
                    clearTimeout(timeout);
                    timeout = setTimeout((() => {
                        proceed();
                    }), delay);
                } else requestAnimationFrame((() => {
                    proceed();
                }));
                return delay;
            };
            const start = () => {
                autoplayStartTime = (new Date).getTime();
                swiper.autoplay.running = true;
                run();
                emit("autoplayStart");
            };
            const stop = () => {
                swiper.autoplay.running = false;
                clearTimeout(timeout);
                cancelAnimationFrame(raf);
                emit("autoplayStop");
            };
            const pause = (internal, reset) => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                clearTimeout(timeout);
                if (!internal) pausedByInteraction = true;
                const proceed = () => {
                    emit("autoplayPause");
                    if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd); else resume();
                };
                swiper.autoplay.paused = true;
                if (reset) {
                    if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;
                    slideChanged = false;
                    proceed();
                    return;
                }
                const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
                autoplayTimeLeft = delay - ((new Date).getTime() - autoplayStartTime);
                if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
                if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
                proceed();
            };
            const resume = () => {
                if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
                autoplayStartTime = (new Date).getTime();
                if (pausedByInteraction) {
                    pausedByInteraction = false;
                    run(autoplayTimeLeft);
                } else run();
                swiper.autoplay.paused = false;
                emit("autoplayResume");
            };
            const onVisibilityChange = () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                const document = ssr_window_esm_getDocument();
                if (document.visibilityState === "hidden") {
                    pausedByInteraction = true;
                    pause(true);
                }
                if (document.visibilityState === "visible") resume();
            };
            const onPointerEnter = e => {
                if (e.pointerType !== "mouse") return;
                pausedByInteraction = true;
                pausedByPointerEnter = true;
                if (swiper.animating || swiper.autoplay.paused) return;
                pause(true);
            };
            const onPointerLeave = e => {
                if (e.pointerType !== "mouse") return;
                pausedByPointerEnter = false;
                if (swiper.autoplay.paused) resume();
            };
            const attachMouseEvents = () => {
                if (swiper.params.autoplay.pauseOnMouseEnter) {
                    swiper.el.addEventListener("pointerenter", onPointerEnter);
                    swiper.el.addEventListener("pointerleave", onPointerLeave);
                }
            };
            const detachMouseEvents = () => {
                if (swiper.el && typeof swiper.el !== "string") {
                    swiper.el.removeEventListener("pointerenter", onPointerEnter);
                    swiper.el.removeEventListener("pointerleave", onPointerLeave);
                }
            };
            const attachDocumentEvents = () => {
                const document = ssr_window_esm_getDocument();
                document.addEventListener("visibilitychange", onVisibilityChange);
            };
            const detachDocumentEvents = () => {
                const document = ssr_window_esm_getDocument();
                document.removeEventListener("visibilitychange", onVisibilityChange);
            };
            on("init", (() => {
                if (swiper.params.autoplay.enabled) {
                    attachMouseEvents();
                    attachDocumentEvents();
                    start();
                }
            }));
            on("destroy", (() => {
                detachMouseEvents();
                detachDocumentEvents();
                if (swiper.autoplay.running) stop();
            }));
            on("_freeModeStaticRelease", (() => {
                if (pausedByTouch || pausedByInteraction) resume();
            }));
            on("_freeModeNoMomentumRelease", (() => {
                if (!swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
            }));
            on("beforeTransitionStart", ((_s, speed, internal) => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
            }));
            on("sliderFirstMove", (() => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.params.autoplay.disableOnInteraction) {
                    stop();
                    return;
                }
                isTouched = true;
                pausedByTouch = false;
                pausedByInteraction = false;
                touchStartTimeout = setTimeout((() => {
                    pausedByInteraction = true;
                    pausedByTouch = true;
                    pause(true);
                }), 200);
            }));
            on("touchEnd", (() => {
                if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
                clearTimeout(touchStartTimeout);
                clearTimeout(timeout);
                if (swiper.params.autoplay.disableOnInteraction) {
                    pausedByTouch = false;
                    isTouched = false;
                    return;
                }
                if (pausedByTouch && swiper.params.cssMode) resume();
                pausedByTouch = false;
                isTouched = false;
            }));
            on("slideChange", (() => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                slideChanged = true;
            }));
            Object.assign(swiper.autoplay, {
                start,
                stop,
                pause,
                resume
            });
        }
        function effect_target_effectTarget(effectParams, slideEl) {
            const transformEl = utils_getSlideTransformEl(slideEl);
            if (transformEl !== slideEl) {
                transformEl.style.backfaceVisibility = "hidden";
                transformEl.style["-webkit-backface-visibility"] = "hidden";
            }
            return transformEl;
        }
        function effect_virtual_transition_end_effectVirtualTransitionEnd(_ref) {
            let {swiper, duration, transformElements, allSlides} = _ref;
            const {activeIndex} = swiper;
            const getSlide = el => {
                if (!el.parentElement) {
                    const slide = swiper.slides.filter((slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode))[0];
                    return slide;
                }
                return el.parentElement;
            };
            if (swiper.params.virtualTranslate && duration !== 0) {
                let eventTriggered = false;
                let transitionEndTarget;
                if (allSlides) transitionEndTarget = transformElements; else transitionEndTarget = transformElements.filter((transformEl => {
                    const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
                    return swiper.getSlideIndex(el) === activeIndex;
                }));
                transitionEndTarget.forEach((el => {
                    utils_elementTransitionEnd(el, (() => {
                        if (eventTriggered) return;
                        if (!swiper || swiper.destroyed) return;
                        eventTriggered = true;
                        swiper.animating = false;
                        const evt = new window.CustomEvent("transitionend", {
                            bubbles: true,
                            cancelable: true
                        });
                        swiper.wrapperEl.dispatchEvent(evt);
                    }));
                }));
            }
        }
        function create_shadow_createShadow(suffix, slideEl, side) {
            const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}${suffix ? ` swiper-slide-shadow-${suffix}` : ""}`;
            const shadowContainer = utils_getSlideTransformEl(slideEl);
            let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(" ").join(".")}`);
            if (!shadowEl) {
                shadowEl = utils_createElement("div", shadowClass.split(" "));
                shadowContainer.append(shadowEl);
            }
            return shadowEl;
        }
        function effect_init_effectInit(params) {
            const {effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective, recreateShadows, getEffectParams} = params;
            on("beforeInit", (() => {
                if (swiper.params.effect !== effect) return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
                if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
                Object.assign(swiper.params, overwriteParamsResult);
                Object.assign(swiper.originalParams, overwriteParamsResult);
            }));
            on("setTranslate", (() => {
                if (swiper.params.effect !== effect) return;
                setTranslate();
            }));
            on("setTransition", ((_s, duration) => {
                if (swiper.params.effect !== effect) return;
                setTransition(duration);
            }));
            on("transitionEnd", (() => {
                if (swiper.params.effect !== effect) return;
                if (recreateShadows) {
                    if (!getEffectParams || !getEffectParams().slideShadows) return;
                    swiper.slides.forEach((slideEl => {
                        slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl => shadowEl.remove()));
                    }));
                    recreateShadows();
                }
            }));
            let requireUpdateOnVirtual;
            on("virtualUpdate", (() => {
                if (swiper.params.effect !== effect) return;
                if (!swiper.slides.length) requireUpdateOnVirtual = true;
                requestAnimationFrame((() => {
                    if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                        setTranslate();
                        requireUpdateOnVirtual = false;
                    }
                }));
            }));
        }
        function EffectCards(_ref) {
            let {swiper, extendParams, on} = _ref;
            extendParams({
                cardsEffect: {
                    slideShadows: true,
                    rotate: true,
                    perSlideRotate: 2,
                    perSlideOffset: 8
                }
            });
            const setTranslate = () => {
                const {slides, activeIndex, rtlTranslate: rtl} = swiper;
                const params = swiper.params.cardsEffect;
                const {startTranslate, isTouched} = swiper.touchEventsData;
                const currentTranslate = rtl ? -swiper.translate : swiper.translate;
                for (let i = 0; i < slides.length; i += 1) {
                    const slideEl = slides[i];
                    const slideProgress = slideEl.progress;
                    const progress = Math.min(Math.max(slideProgress, -4), 4);
                    let offset = slideEl.swiperSlideOffset;
                    if (swiper.params.centeredSlides && !swiper.params.cssMode) swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
                    if (swiper.params.centeredSlides && swiper.params.cssMode) offset -= slides[0].swiperSlideOffset;
                    let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                    let tY = 0;
                    const tZ = -100 * Math.abs(progress);
                    let scale = 1;
                    let rotate = -params.perSlideRotate * progress;
                    let tXAdd = params.perSlideOffset - Math.abs(progress) * .75;
                    const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
                    const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
                    const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
                    if (isSwipeToNext || isSwipeToPrev) {
                        const subProgress = (1 - Math.abs((Math.abs(progress) - .5) / .5)) ** .5;
                        rotate += -28 * progress * subProgress;
                        scale += -.5 * subProgress;
                        tXAdd += 96 * subProgress;
                        tY = `${-25 * subProgress * Math.abs(progress)}%`;
                    }
                    if (progress < 0) tX = `calc(${tX}px ${rtl ? "-" : "+"} (${tXAdd * Math.abs(progress)}%))`; else if (progress > 0) tX = `calc(${tX}px ${rtl ? "-" : "+"} (-${tXAdd * Math.abs(progress)}%))`; else tX = `${tX}px`;
                    if (!swiper.isHorizontal()) {
                        const prevY = tY;
                        tY = tX;
                        tX = prevY;
                    }
                    const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
                    const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;
                    if (params.slideShadows) {
                        let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                        if (!shadowEl) shadowEl = create_shadow_createShadow("cards", slideEl);
                        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - .5) / .5, 0), 1);
                    }
                    slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                    const targetEl = effect_target_effectTarget(params, slideEl);
                    targetEl.style.transform = transform;
                }
            };
            const setTransition = duration => {
                const transformElements = swiper.slides.map((slideEl => utils_getSlideTransformEl(slideEl)));
                transformElements.forEach((el => {
                    el.style.transitionDuration = `${duration}ms`;
                    el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl => {
                        shadowEl.style.transitionDuration = `${duration}ms`;
                    }));
                }));
                effect_virtual_transition_end_effectVirtualTransitionEnd({
                    swiper,
                    duration,
                    transformElements
                });
            };
            effect_init_effectInit({
                effect: "cards",
                swiper,
                on,
                setTranslate,
                setTransition,
                perspective: () => true,
                overwriteParams: () => ({
                    watchSlidesProgress: true,
                    virtualTranslate: !swiper.params.cssMode
                })
            });
        }
        function initSliders() {
            if (document.querySelector(".intro__slider")) new swiper_core_Swiper(".intro__slider", {
                modules: [ Navigation, Autoplay ],
                observer: true,
                observeParents: true,
                slidesPerView: 1.7,
                spaceBetween: 1,
                speed: 800,
                loop: true,
                autoplay: {
                    delay: 1500,
                    disableOnInteraction: false
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1.3
                    },
                    768: {
                        slidesPerView: 1.7
                    }
                },
                on: {}
            });
            if (document.querySelector(".online__slider")) new swiper_core_Swiper(".online__slider", {
                modules: [ Navigation, Pagination, Autoplay ],
                observer: true,
                observeParents: true,
                slidesPerView: 4,
                spaceBetween: 20,
                speed: 800,
                autoplay: {
                    delay: 1500,
                    disableOnInteraction: false
                },
                pagination: {
                    el: ".online__dotts",
                    clickable: true
                },
                navigation: {
                    prevEl: ".arrows__online--prev",
                    nextEl: ".arrows__online--next"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    480: {
                        slidesPerView: 2,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 3,
                        spaceBetween: 15
                    },
                    1268: {
                        slidesPerView: 4,
                        spaceBetween: 20
                    }
                },
                on: {}
            });
            if (document.querySelector(".photos__slider")) new swiper_core_Swiper(".photos__slider", {
                modules: [ Navigation, Pagination, EffectCards ],
                observer: true,
                observeParents: true,
                slidesPerView: 1,
                spaceBetween: 0,
                grabCursor: true,
                speed: 800,
                effect: "cards",
                pagination: {
                    el: ".controls-photos__fraction",
                    clickable: true,
                    type: "fraction"
                },
                navigation: {
                    prevEl: ".arrows__photos--prev",
                    nextEl: ".arrows__photos--next"
                },
                on: {}
            });
        }
        window.addEventListener("load", (function(e) {
            initSliders();
        }));
        var lazyload_min = __webpack_require__(144);
        new lazyload_min({
            elements_selector: "[data-src],[data-srcset]",
            class_loaded: "_lazy-loaded",
            use_native: true
        });
        class ScrollWatcher {
            constructor(props) {
                let defaultConfig = {
                    logging: true
                };
                this.config = Object.assign(defaultConfig, props);
                this.observer;
                !document.documentElement.classList.contains("watcher") ? this.scrollWatcherRun() : null;
            }
            scrollWatcherUpdate() {
                this.scrollWatcherRun();
            }
            scrollWatcherRun() {
                document.documentElement.classList.add("watcher");
                this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]"));
            }
            scrollWatcherConstructor(items) {
                if (items.length) {
                    this.scrollWatcherLogging(`Прокинувся, стежу за об'єктами (${items.length})...`);
                    let uniqParams = uniqArray(Array.from(items).map((function(item) {
                        if (item.dataset.watch === "navigator" && !item.dataset.watchThreshold) {
                            let valueOfThreshold;
                            if (item.clientHeight > 2) {
                                valueOfThreshold = window.innerHeight / 2 / (item.clientHeight - 1);
                                if (valueOfThreshold > 1) valueOfThreshold = 1;
                            } else valueOfThreshold = 1;
                            item.setAttribute("data-watch-threshold", valueOfThreshold.toFixed(2));
                        }
                        return `${item.dataset.watchRoot ? item.dataset.watchRoot : null}|${item.dataset.watchMargin ? item.dataset.watchMargin : "0px"}|${item.dataset.watchThreshold ? item.dataset.watchThreshold : 0}`;
                    })));
                    uniqParams.forEach((uniqParam => {
                        let uniqParamArray = uniqParam.split("|");
                        let paramsWatch = {
                            root: uniqParamArray[0],
                            margin: uniqParamArray[1],
                            threshold: uniqParamArray[2]
                        };
                        let groupItems = Array.from(items).filter((function(item) {
                            let watchRoot = item.dataset.watchRoot ? item.dataset.watchRoot : null;
                            let watchMargin = item.dataset.watchMargin ? item.dataset.watchMargin : "0px";
                            let watchThreshold = item.dataset.watchThreshold ? item.dataset.watchThreshold : 0;
                            if (String(watchRoot) === paramsWatch.root && String(watchMargin) === paramsWatch.margin && String(watchThreshold) === paramsWatch.threshold) return item;
                        }));
                        let configWatcher = this.getScrollWatcherConfig(paramsWatch);
                        this.scrollWatcherInit(groupItems, configWatcher);
                    }));
                } else this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz");
            }
            getScrollWatcherConfig(paramsWatch) {
                let configWatcher = {};
                if (document.querySelector(paramsWatch.root)) configWatcher.root = document.querySelector(paramsWatch.root); else if (paramsWatch.root !== "null") this.scrollWatcherLogging(`Эмм... батьківського об'єкта ${paramsWatch.root} немає на сторінці`);
                configWatcher.rootMargin = paramsWatch.margin;
                if (paramsWatch.margin.indexOf("px") < 0 && paramsWatch.margin.indexOf("%") < 0) {
                    this.scrollWatcherLogging(`йой, налаштування data-watch-margin потрібно задавати в PX або %`);
                    return;
                }
                if (paramsWatch.threshold === "prx") {
                    paramsWatch.threshold = [];
                    for (let i = 0; i <= 1; i += .005) paramsWatch.threshold.push(i);
                } else paramsWatch.threshold = paramsWatch.threshold.split(",");
                configWatcher.threshold = paramsWatch.threshold;
                return configWatcher;
            }
            scrollWatcherCreate(configWatcher) {
                console.log(configWatcher);
                this.observer = new IntersectionObserver(((entries, observer) => {
                    entries.forEach((entry => {
                        this.scrollWatcherCallback(entry, observer);
                    }));
                }), configWatcher);
            }
            scrollWatcherInit(items, configWatcher) {
                this.scrollWatcherCreate(configWatcher);
                items.forEach((item => this.observer.observe(item)));
            }
            scrollWatcherIntersecting(entry, targetElement) {
                if (entry.isIntersecting) {
                    !targetElement.classList.contains("_watcher-view") ? targetElement.classList.add("_watcher-view") : null;
                    this.scrollWatcherLogging(`Я бачу ${targetElement.classList}, додав клас _watcher-view`);
                } else {
                    targetElement.classList.contains("_watcher-view") ? targetElement.classList.remove("_watcher-view") : null;
                    this.scrollWatcherLogging(`Я не бачу ${targetElement.classList}, прибрав клас _watcher-view`);
                }
            }
            scrollWatcherOff(targetElement, observer) {
                observer.unobserve(targetElement);
                this.scrollWatcherLogging(`Я перестав стежити за ${targetElement.classList}`);
            }
            scrollWatcherLogging(message) {
                this.config.logging ? FLS(`[Спостерігач]: ${message}`) : null;
            }
            scrollWatcherCallback(entry, observer) {
                const targetElement = entry.target;
                this.scrollWatcherIntersecting(entry, targetElement);
                targetElement.hasAttribute("data-watch-once") && entry.isIntersecting ? this.scrollWatcherOff(targetElement, observer) : null;
                document.dispatchEvent(new CustomEvent("watcherCallback", {
                    detail: {
                        entry
                    }
                }));
            }
        }
        modules_flsModules.watcher = new ScrollWatcher({});
        let addWindowScrollEvent = false;
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        class DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.оbjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const оbject = {};
                    оbject.element = node;
                    оbject.parent = node.parentNode;
                    оbject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
                    оbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    оbject.index = this.indexInParent(оbject.parent, оbject.element);
                    this.оbjects.push(оbject);
                }));
                this.arraySort(this.оbjects);
                this.mediaQueries = this.оbjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint}px),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const оbjectsFilter = this.оbjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, оbjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, оbjectsFilter);
                }));
            }
            mediaHandler(matchMedia, оbjects) {
                if (matchMedia.matches) оbjects.forEach((оbject => {
                    this.moveTo(оbject.place, оbject.element, оbject.destination);
                })); else оbjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                element.classList.add(this.daClassname);
                if (place === "last" || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if (place === "first") {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (parent.children[index] !== void 0) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if (this.type === "min") arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return -1;
                        if (a.place === "last" || b.place === "first") return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if (a.place === "first" || b.place === "last") return 1;
                            if (a.place === "last" || b.place === "first") return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const da = new DynamicAdapt("max");
        da.init();
        document.addEventListener("DOMContentLoaded", (function() {
            const moreButtons = document.querySelector(".more__buttons");
            if (moreButtons !== null) {
                function updateTitle(propName) {
                    const radioButtons = document.querySelectorAll(`input[name="prop-${propName}"]`);
                    const titleSpan = document.querySelector(`.more__button-title--${propName} span`);
                    radioButtons.forEach((radio => {
                        if (radio.checked) {
                            const label = document.querySelector(`label[for="${radio.id}"] .options__text`);
                            titleSpan.textContent = label ? label.textContent : "";
                        }
                    }));
                }
                const propNames = [ "body", "hair", "eye", "belive", "type", "edu", "prof", "deal", "social", "home", "move", "smoke", "drink" ];
                propNames.forEach((propName => {
                    document.querySelectorAll(`input[name="prop-${propName}"]`).forEach((radio => {
                        radio.addEventListener("change", (() => {
                            updateTitle(propName);
                            const popup = document.querySelector(`#more-${propName}`);
                            if (popup) {
                                const popupInstance = modules_flsModules.popup;
                                popupInstance.close(popup.id);
                            }
                        }));
                    }));
                }));
                propNames.forEach((propName => updateTitle(propName)));
            }
            const langRadio = document.querySelectorAll(".lang__input");
            const messageLang = document.getElementById("lang-chk");
            if (langRadio, messageLang !== null) {
                const checkRadioButtons = () => {
                    const anyChecked = Array.from(langRadio).some((input => input.checked));
                    langRadio.forEach((input => {
                        input.classList.toggle("_form-error-lang", !anyChecked);
                    }));
                    messageLang.style.display = anyChecked ? "none" : "block";
                };
                checkRadioButtons();
                langRadio.forEach((input => {
                    input.addEventListener("change", checkRadioButtons);
                }));
            }
            const genderRadio = document.querySelectorAll(".gender__input");
            const messageGender = document.getElementById("gender-chk");
            if (genderRadio, messageGender !== null) {
                const checkRadioButtons = () => {
                    const anyChecked = Array.from(genderRadio).some((input => input.checked));
                    genderRadio.forEach((input => {
                        input.classList.toggle("_form-error-gender", !anyChecked);
                    }));
                    messageGender.style.display = anyChecked ? "none" : "block";
                };
                checkRadioButtons();
                genderRadio.forEach((input => {
                    input.addEventListener("change", checkRadioButtons);
                }));
            }
            const updateCharCount = (textarea, maxLength) => {
                const charCount = textarea.nextElementSibling;
                textarea.addEventListener("input", (() => {
                    const currentLength = textarea.value.length;
                    charCount.textContent = `${currentLength}/${maxLength} символов`;
                }));
            };
            const textareas = document.querySelectorAll(".request-textarea");
            if (textareas !== null) textareas.forEach((textarea => {
                const maxLength = textarea.getAttribute("maxlength");
                updateCharCount(textarea, maxLength);
            }));
            const checkboxes = document.querySelectorAll(".form-chk");
            const messageCheckbox = document.getElementById("message-chk");
            if (checkboxes, messageCheckbox !== null) {
                function checkCheckboxes() {
                    let anyChecked = false;
                    checkboxes.forEach((function(messageCheckbox) {
                        if (messageCheckbox.checked) anyChecked = true;
                    }));
                    if (!anyChecked) messageCheckbox.style.display = "block"; else messageCheckbox.style.display = "none";
                }
                checkboxes.forEach((function(checkbox) {
                    checkbox.addEventListener("change", checkCheckboxes);
                }));
                checkCheckboxes();
            }
            if (document.documentElement.getAttribute("dir") === "rtl") {
                const items = document.querySelectorAll(".options__item");
                items.forEach((item => {
                    item.classList.add("rtl-reverse");
                }));
            }
            const uploadArea = document.getElementById("uploadArea");
            const fileInput = document.getElementById("fileInput");
            if (uploadArea, fileInput !== null) {
                uploadArea.addEventListener("dragover", (e => {
                    e.preventDefault();
                    uploadArea.classList.add("hover");
                }));
                uploadArea.addEventListener("dragleave", (() => {
                    uploadArea.classList.remove("hover");
                }));
                uploadArea.addEventListener("drop", (e => {
                    e.preventDefault();
                    uploadArea.classList.remove("hover");
                    const files = e.dataTransfer.files;
                    if (files.length > 0) fileInput.files = files;
                }));
                uploadArea.addEventListener("click", (() => {
                    fileInput.click();
                }));
            }
            const footer = document.querySelector(".footer");
            const nav = document.querySelector(".nav");
            if (nav !== null) window.addEventListener("scroll", (() => {
                const footerRect = footer.getBoundingClientRect();
                const windowHeight = window.innerHeight;
                if (footerRect.top <= windowHeight) nav.classList.add("_nav-active"); else nav.classList.remove("_nav-active");
            }));
            const heartButtons = document.querySelectorAll(".btn-heart");
            if (heartButtons !== null) heartButtons.forEach((button => {
                button.addEventListener("click", (function() {
                    this.classList.toggle("btn-heart--active");
                    if (this.classList.contains("btn-heart--active")) this.setAttribute("data-popup", "#done-favorites"); else this.setAttribute("data-popup", "#done-favorites-remove");
                }));
            }));
        }));
        function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
        }
        const _listCacheClear = listCacheClear;
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        const lodash_es_eq = eq;
        function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) if (lodash_es_eq(array[length][0], key)) return length;
            return -1;
        }
        const _assocIndexOf = assocIndexOf;
        var arrayProto = Array.prototype;
        var splice = arrayProto.splice;
        function listCacheDelete(key) {
            var data = this.__data__, index = _assocIndexOf(data, key);
            if (index < 0) return false;
            var lastIndex = data.length - 1;
            if (index == lastIndex) data.pop(); else splice.call(data, index, 1);
            --this.size;
            return true;
        }
        const _listCacheDelete = listCacheDelete;
        function listCacheGet(key) {
            var data = this.__data__, index = _assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
        }
        const _listCacheGet = listCacheGet;
        function listCacheHas(key) {
            return _assocIndexOf(this.__data__, key) > -1;
        }
        const _listCacheHas = listCacheHas;
        function listCacheSet(key, value) {
            var data = this.__data__, index = _assocIndexOf(data, key);
            if (index < 0) {
                ++this.size;
                data.push([ key, value ]);
            } else data[index][1] = value;
            return this;
        }
        const _listCacheSet = listCacheSet;
        function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        ListCache.prototype.clear = _listCacheClear;
        ListCache.prototype["delete"] = _listCacheDelete;
        ListCache.prototype.get = _listCacheGet;
        ListCache.prototype.has = _listCacheHas;
        ListCache.prototype.set = _listCacheSet;
        const _ListCache = ListCache;
        function stackClear() {
            this.__data__ = new _ListCache;
            this.size = 0;
        }
        const _stackClear = stackClear;
        function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            this.size = data.size;
            return result;
        }
        const _stackDelete = stackDelete;
        function stackGet(key) {
            return this.__data__.get(key);
        }
        const _stackGet = stackGet;
        function stackHas(key) {
            return this.__data__.has(key);
        }
        const _stackHas = stackHas;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        const _freeGlobal = freeGlobal;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = _freeGlobal || freeSelf || Function("return this")();
        const _root = root;
        var app_Symbol = _root.Symbol;
        const _Symbol = app_Symbol;
        var objectProto = Object.prototype;
        var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function getRawTag(value) {
            var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = void 0;
                var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) if (isOwn) value[symToStringTag] = tag; else delete value[symToStringTag];
            return result;
        }
        const _getRawTag = getRawTag;
        var _objectToString_objectProto = Object.prototype;
        var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
        function objectToString(value) {
            return _objectToString_nativeObjectToString.call(value);
        }
        const _objectToString = objectToString;
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function baseGetTag(value) {
            if (value == null) return value === void 0 ? undefinedTag : nullTag;
            return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
        }
        const _baseGetTag = baseGetTag;
        function isObject_isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
        }
        const lodash_es_isObject = isObject_isObject;
        var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
        function isFunction(value) {
            if (!lodash_es_isObject(value)) return false;
            var tag = _baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        const lodash_es_isFunction = isFunction;
        var coreJsData = _root["__core-js_shared__"];
        const _coreJsData = coreJsData;
        var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
        }();
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        const _isMasked = isMasked;
        var funcProto = Function.prototype;
        var funcToString = funcProto.toString;
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + "";
                } catch (e) {}
            }
            return "";
        }
        const _toSource = toSource;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var _baseIsNative_funcProto = Function.prototype, _baseIsNative_objectProto = Object.prototype;
        var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;
        var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;
        var reIsNative = RegExp("^" + _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        function baseIsNative(value) {
            if (!lodash_es_isObject(value) || _isMasked(value)) return false;
            var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(_toSource(value));
        }
        const _baseIsNative = baseIsNative;
        function getValue(object, key) {
            return object == null ? void 0 : object[key];
        }
        const _getValue = getValue;
        function getNative(object, key) {
            var value = _getValue(object, key);
            return _baseIsNative(value) ? value : void 0;
        }
        const _getNative = getNative;
        var app_Map = _getNative(_root, "Map");
        const _Map = app_Map;
        var nativeCreate = _getNative(Object, "create");
        const _nativeCreate = nativeCreate;
        function hashClear() {
            this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
            this.size = 0;
        }
        const _hashClear = hashClear;
        function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
        }
        const _hashDelete = hashDelete;
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var _hashGet_objectProto = Object.prototype;
        var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;
        function hashGet(key) {
            var data = this.__data__;
            if (_nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? void 0 : result;
            }
            return _hashGet_hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        const _hashGet = hashGet;
        var _hashHas_objectProto = Object.prototype;
        var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;
        function hashHas(key) {
            var data = this.__data__;
            return _nativeCreate ? data[key] !== void 0 : _hashHas_hasOwnProperty.call(data, key);
        }
        const _hashHas = hashHas;
        var _hashSet_HASH_UNDEFINED = "__lodash_hash_undefined__";
        function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = _nativeCreate && value === void 0 ? _hashSet_HASH_UNDEFINED : value;
            return this;
        }
        const _hashSet = hashSet;
        function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        Hash.prototype.clear = _hashClear;
        Hash.prototype["delete"] = _hashDelete;
        Hash.prototype.get = _hashGet;
        Hash.prototype.has = _hashHas;
        Hash.prototype.set = _hashSet;
        const _Hash = Hash;
        function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
                hash: new _Hash,
                map: new (_Map || _ListCache),
                string: new _Hash
            };
        }
        const _mapCacheClear = mapCacheClear;
        function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        const _isKeyable = isKeyable;
        function getMapData(map, key) {
            var data = map.__data__;
            return _isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        const _getMapData = getMapData;
        function mapCacheDelete(key) {
            var result = _getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
        }
        const _mapCacheDelete = mapCacheDelete;
        function mapCacheGet(key) {
            return _getMapData(this, key).get(key);
        }
        const _mapCacheGet = mapCacheGet;
        function mapCacheHas(key) {
            return _getMapData(this, key).has(key);
        }
        const _mapCacheHas = mapCacheHas;
        function mapCacheSet(key, value) {
            var data = _getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
        }
        const _mapCacheSet = mapCacheSet;
        function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        MapCache.prototype.clear = _mapCacheClear;
        MapCache.prototype["delete"] = _mapCacheDelete;
        MapCache.prototype.get = _mapCacheGet;
        MapCache.prototype.has = _mapCacheHas;
        MapCache.prototype.set = _mapCacheSet;
        const _MapCache = MapCache;
        var LARGE_ARRAY_SIZE = 200;
        function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof _ListCache) {
                var pairs = data.__data__;
                if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([ key, value ]);
                    this.size = ++data.size;
                    return this;
                }
                data = this.__data__ = new _MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
        }
        const _stackSet = stackSet;
        function Stack(entries) {
            var data = this.__data__ = new _ListCache(entries);
            this.size = data.size;
        }
        Stack.prototype.clear = _stackClear;
        Stack.prototype["delete"] = _stackDelete;
        Stack.prototype.get = _stackGet;
        Stack.prototype.has = _stackHas;
        Stack.prototype.set = _stackSet;
        const _Stack = Stack;
        var defineProperty = function() {
            try {
                var func = _getNative(Object, "defineProperty");
                func({}, "", {});
                return func;
            } catch (e) {}
        }();
        const _defineProperty = defineProperty;
        function baseAssignValue(object, key, value) {
            if (key == "__proto__" && _defineProperty) _defineProperty(object, key, {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            }); else object[key] = value;
        }
        const _baseAssignValue = baseAssignValue;
        function assignMergeValue(object, key, value) {
            if (value !== void 0 && !lodash_es_eq(object[key], value) || value === void 0 && !(key in object)) _baseAssignValue(object, key, value);
        }
        const _assignMergeValue = assignMergeValue;
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) break;
                }
                return object;
            };
        }
        const _createBaseFor = createBaseFor;
        var baseFor = _createBaseFor();
        const _baseFor = baseFor;
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer = moduleExports ? _root.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
        }
        const _cloneBuffer = cloneBuffer;
        var Uint8Array = _root.Uint8Array;
        const _Uint8Array = Uint8Array;
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
            return result;
        }
        const _cloneArrayBuffer = cloneArrayBuffer;
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        const _cloneTypedArray = cloneTypedArray;
        function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) array[index] = source[index];
            return array;
        }
        const _copyArray = copyArray;
        var objectCreate = Object.create;
        var baseCreate = function() {
            function object() {}
            return function(proto) {
                if (!lodash_es_isObject(proto)) return {};
                if (objectCreate) return objectCreate(proto);
                object.prototype = proto;
                var result = new object;
                object.prototype = void 0;
                return result;
            };
        }();
        const _baseCreate = baseCreate;
        function overArg(func, transform) {
            return function(arg) {
                return func(transform(arg));
            };
        }
        const _overArg = overArg;
        var getPrototype = _overArg(Object.getPrototypeOf, Object);
        const _getPrototype = getPrototype;
        var _isPrototype_objectProto = Object.prototype;
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || _isPrototype_objectProto;
            return value === proto;
        }
        const _isPrototype = isPrototype;
        function initCloneObject(object) {
            return typeof object.constructor == "function" && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
        }
        const _initCloneObject = initCloneObject;
        function isObjectLike(value) {
            return value != null && typeof value == "object";
        }
        const lodash_es_isObjectLike = isObjectLike;
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
            return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
        }
        const _baseIsArguments = baseIsArguments;
        var isArguments_objectProto = Object.prototype;
        var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;
        var propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;
        var isArguments = _baseIsArguments(function() {
            return arguments;
        }()) ? _baseIsArguments : function(value) {
            return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        const lodash_es_isArguments = isArguments;
        var isArray = Array.isArray;
        const lodash_es_isArray = isArray;
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        const lodash_es_isLength = isLength;
        function isArrayLike(value) {
            return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
        }
        const lodash_es_isArrayLike = isArrayLike;
        function isArrayLikeObject(value) {
            return lodash_es_isObjectLike(value) && lodash_es_isArrayLike(value);
        }
        const lodash_es_isArrayLikeObject = isArrayLikeObject;
        function stubFalse() {
            return false;
        }
        const lodash_es_stubFalse = stubFalse;
        var isBuffer_freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var isBuffer_freeModule = isBuffer_freeExports && typeof module == "object" && module && !module.nodeType && module;
        var isBuffer_moduleExports = isBuffer_freeModule && isBuffer_freeModule.exports === isBuffer_freeExports;
        var isBuffer_Buffer = isBuffer_moduleExports ? _root.Buffer : void 0;
        var nativeIsBuffer = isBuffer_Buffer ? isBuffer_Buffer.isBuffer : void 0;
        var isBuffer = nativeIsBuffer || lodash_es_stubFalse;
        const lodash_es_isBuffer = isBuffer;
        var objectTag = "[object Object]";
        var isPlainObject_funcProto = Function.prototype, isPlainObject_objectProto = Object.prototype;
        var isPlainObject_funcToString = isPlainObject_funcProto.toString;
        var isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;
        var objectCtorString = isPlainObject_funcToString.call(Object);
        function isPlainObject(value) {
            if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) return false;
            var proto = _getPrototype(value);
            if (proto === null) return true;
            var Ctor = isPlainObject_hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && isPlainObject_funcToString.call(Ctor) == objectCtorString;
        }
        const lodash_es_isPlainObject = isPlainObject;
        var _baseIsTypedArray_argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", _baseIsTypedArray_funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", _baseIsTypedArray_objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[_baseIsTypedArray_objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        function baseIsTypedArray(value) {
            return lodash_es_isObjectLike(value) && lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
        }
        const _baseIsTypedArray = baseIsTypedArray;
        function baseUnary(func) {
            return function(value) {
                return func(value);
            };
        }
        const _baseUnary = baseUnary;
        var _nodeUtil_freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var _nodeUtil_freeModule = _nodeUtil_freeExports && typeof module == "object" && module && !module.nodeType && module;
        var _nodeUtil_moduleExports = _nodeUtil_freeModule && _nodeUtil_freeModule.exports === _nodeUtil_freeExports;
        var freeProcess = _nodeUtil_moduleExports && _freeGlobal.process;
        var nodeUtil = function() {
            try {
                var types = _nodeUtil_freeModule && _nodeUtil_freeModule.require && _nodeUtil_freeModule.require("util").types;
                if (types) return types;
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
            } catch (e) {}
        }();
        const _nodeUtil = nodeUtil;
        var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
        var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
        const lodash_es_isTypedArray = isTypedArray;
        function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") return;
            if (key == "__proto__") return;
            return object[key];
        }
        const _safeGet = safeGet;
        var _assignValue_objectProto = Object.prototype;
        var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) || value === void 0 && !(key in object)) _baseAssignValue(object, key, value);
        }
        const _assignValue = assignValue;
        function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                if (newValue === void 0) newValue = source[key];
                if (isNew) _baseAssignValue(object, key, newValue); else _assignValue(object, key, newValue);
            }
            return object;
        }
        const _copyObject = copyObject;
        function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while (++index < n) result[index] = iteratee(index);
            return result;
        }
        const _baseTimes = baseTimes;
        var _isIndex_MAX_SAFE_INTEGER = 9007199254740991;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? _isIndex_MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        const _isIndex = isIndex;
        var _arrayLikeKeys_objectProto = Object.prototype;
        var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
            var isArr = lodash_es_isArray(value), isArg = !isArr && lodash_es_isArguments(value), isBuff = !isArr && !isArg && lodash_es_isBuffer(value), isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || _isIndex(key, length)))) result.push(key);
            return result;
        }
        const _arrayLikeKeys = arrayLikeKeys;
        function nativeKeysIn(object) {
            var result = [];
            if (object != null) for (var key in Object(object)) result.push(key);
            return result;
        }
        const _nativeKeysIn = nativeKeysIn;
        var _baseKeysIn_objectProto = Object.prototype;
        var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;
        function baseKeysIn(object) {
            if (!lodash_es_isObject(object)) return _nativeKeysIn(object);
            var isProto = _isPrototype(object), result = [];
            for (var key in object) if (!(key == "constructor" && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) result.push(key);
            return result;
        }
        const _baseKeysIn = baseKeysIn;
        function keysIn(object) {
            return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
        }
        const lodash_es_keysIn = keysIn;
        function toPlainObject(value) {
            return _copyObject(value, lodash_es_keysIn(value));
        }
        const lodash_es_toPlainObject = toPlainObject;
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = _safeGet(object, key), srcValue = _safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
                _assignMergeValue(object, key, stacked);
                return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
            var isCommon = newValue === void 0;
            if (isCommon) {
                var isArr = lodash_es_isArray(srcValue), isBuff = !isArr && lodash_es_isBuffer(srcValue), isTyped = !isArr && !isBuff && lodash_es_isTypedArray(srcValue);
                newValue = srcValue;
                if (isArr || isBuff || isTyped) if (lodash_es_isArray(objValue)) newValue = objValue; else if (lodash_es_isArrayLikeObject(objValue)) newValue = _copyArray(objValue); else if (isBuff) {
                    isCommon = false;
                    newValue = _cloneBuffer(srcValue, true);
                } else if (isTyped) {
                    isCommon = false;
                    newValue = _cloneTypedArray(srcValue, true);
                } else newValue = []; else if (lodash_es_isPlainObject(srcValue) || lodash_es_isArguments(srcValue)) {
                    newValue = objValue;
                    if (lodash_es_isArguments(objValue)) newValue = lodash_es_toPlainObject(objValue); else if (!lodash_es_isObject(objValue) || lodash_es_isFunction(objValue)) newValue = _initCloneObject(srcValue);
                } else isCommon = false;
            }
            if (isCommon) {
                stack.set(srcValue, newValue);
                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                stack["delete"](srcValue);
            }
            _assignMergeValue(object, key, newValue);
        }
        const _baseMergeDeep = baseMergeDeep;
        function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) return;
            _baseFor(source, (function(srcValue, key) {
                stack || (stack = new _Stack);
                if (lodash_es_isObject(srcValue)) _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                    var newValue = customizer ? customizer(_safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
                    if (newValue === void 0) newValue = srcValue;
                    _assignMergeValue(object, key, newValue);
                }
            }), lodash_es_keysIn);
        }
        const _baseMerge = baseMerge;
        function identity(value) {
            return value;
        }
        const lodash_es_identity = identity;
        function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);

              case 1:
                return func.call(thisArg, args[0]);

              case 2:
                return func.call(thisArg, args[0], args[1]);

              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
        }
        const _apply = apply;
        var nativeMax = Math.max;
        function overRest(func, start, transform) {
            start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
            return function() {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while (++index < length) array[index] = args[start + index];
                index = -1;
                var otherArgs = Array(start + 1);
                while (++index < start) otherArgs[index] = args[index];
                otherArgs[start] = transform(array);
                return _apply(func, this, otherArgs);
            };
        }
        const _overRest = overRest;
        function constant(value) {
            return function() {
                return value;
            };
        }
        const lodash_es_constant = constant;
        var baseSetToString = !_defineProperty ? lodash_es_identity : function(func, string) {
            return _defineProperty(func, "toString", {
                configurable: true,
                enumerable: false,
                value: lodash_es_constant(string),
                writable: true
            });
        };
        const _baseSetToString = baseSetToString;
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var nativeNow = Date.now;
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) return arguments[0];
                } else count = 0;
                return func.apply(void 0, arguments);
            };
        }
        const _shortOut = shortOut;
        var setToString = _shortOut(_baseSetToString);
        const _setToString = setToString;
        function baseRest(func, start) {
            return _setToString(_overRest(func, start, lodash_es_identity), func + "");
        }
        const _baseRest = baseRest;
        function isIterateeCall(value, index, object) {
            if (!lodash_es_isObject(object)) return false;
            var type = typeof index;
            if (type == "number" ? lodash_es_isArrayLike(object) && _isIndex(index, object.length) : type == "string" && index in object) return lodash_es_eq(object[index], value);
            return false;
        }
        const _isIterateeCall = isIterateeCall;
        function createAssigner(assigner) {
            return _baseRest((function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
                customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, 
                customizer) : void 0;
                if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? void 0 : customizer;
                    length = 1;
                }
                object = Object(object);
                while (++index < length) {
                    var source = sources[index];
                    if (source) assigner(object, source, index, customizer);
                }
                return object;
            }));
        }
        const _createAssigner = createAssigner;
        var merge = _createAssigner((function(object, source, srcIndex) {
            _baseMerge(object, source, srcIndex);
        }));
        const lodash_es_merge = merge;
        var Scope = (Scope2 => (Scope2[Scope2.TYPE = 3] = "TYPE", Scope2[Scope2.LEVEL = 12] = "LEVEL", 
        Scope2[Scope2.ATTRIBUTE = 13] = "ATTRIBUTE", Scope2[Scope2.BLOT = 14] = "BLOT", 
        Scope2[Scope2.INLINE = 7] = "INLINE", Scope2[Scope2.BLOCK = 11] = "BLOCK", Scope2[Scope2.BLOCK_BLOT = 10] = "BLOCK_BLOT", 
        Scope2[Scope2.INLINE_BLOT = 6] = "INLINE_BLOT", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", 
        Scope2[Scope2.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", Scope2[Scope2.ANY = 15] = "ANY", 
        Scope2))(Scope || {});
        class Attributor {
            constructor(attrName, keyName, options = {}) {
                this.attrName = attrName, this.keyName = keyName;
                const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;
                this.scope = options.scope != null ? options.scope & Scope.LEVEL | attributeBit : Scope.ATTRIBUTE, 
                options.whitelist != null && (this.whitelist = options.whitelist);
            }
            static keys(node) {
                return Array.from(node.attributes).map((item => item.name));
            }
            add(node, value) {
                return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;
            }
            canAdd(_node, value) {
                return this.whitelist == null ? !0 : typeof value == "string" ? this.whitelist.indexOf(value.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(value) > -1;
            }
            remove(node) {
                node.removeAttribute(this.keyName);
            }
            value(node) {
                const value = node.getAttribute(this.keyName);
                return this.canAdd(node, value) && value ? value : "";
            }
        }
        class ParchmentError extends Error {
            constructor(message) {
                message = "[Parchment] " + message, super(message), this.message = message, this.name = this.constructor.name;
            }
        }
        const _Registry = class _Registry {
            constructor() {
                this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
            }
            static find(node, bubble = !1) {
                if (node == null) return null;
                if (this.blots.has(node)) return this.blots.get(node) || null;
                if (bubble) {
                    let parentNode = null;
                    try {
                        parentNode = node.parentNode;
                    } catch {
                        return null;
                    }
                    return this.find(parentNode, bubble);
                }
                return null;
            }
            create(scroll, input, value) {
                const match2 = this.query(input);
                if (match2 == null) throw new ParchmentError(`Unable to create ${input} blot`);
                const blotClass = match2, node = input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value), blot = new blotClass(scroll, node, value);
                return _Registry.blots.set(blot.domNode, blot), blot;
            }
            find(node, bubble = !1) {
                return _Registry.find(node, bubble);
            }
            query(query, scope = Scope.ANY) {
                let match2;
                return typeof query == "string" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == "number" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute("class") || "").split(/\s+/).some((name => (match2 = this.classes[name], 
                !!match2))), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : "scope" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;
            }
            register(...definitions) {
                return definitions.map((definition => {
                    const isBlot = "blotName" in definition, isAttr = "attrName" in definition;
                    if (!isBlot && !isAttr) throw new ParchmentError("Invalid definition");
                    if (isBlot && definition.blotName === "abstract") throw new ParchmentError("Cannot register abstract class");
                    const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;
                    return this.types[key] = definition, isAttr ? typeof definition.keyName == "string" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), 
                    definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map((tagName => tagName.toUpperCase())) : definition.tagName = definition.tagName.toUpperCase(), 
                    (Array.isArray(definition.tagName) ? definition.tagName : [ definition.tagName ]).forEach((tag => {
                        (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);
                    })))), definition;
                }));
            }
        };
        _Registry.blots = new WeakMap;
        let Registry = _Registry;
        function match(node, prefix) {
            return (node.getAttribute("class") || "").split(/\s+/).filter((name => name.indexOf(`${prefix}-`) === 0));
        }
        class ClassAttributor extends Attributor {
            static keys(node) {
                return (node.getAttribute("class") || "").split(/\s+/).map((name => name.split("-").slice(0, -1).join("-")));
            }
            add(node, value) {
                return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), 
                !0) : !1;
            }
            remove(node) {
                match(node, this.keyName).forEach((name => {
                    node.classList.remove(name);
                })), node.classList.length === 0 && node.removeAttribute("class");
            }
            value(node) {
                const value = (match(node, this.keyName)[0] || "").slice(this.keyName.length + 1);
                return this.canAdd(node, value) ? value : "";
            }
        }
        const ClassAttributor$1 = ClassAttributor;
        function camelize(name) {
            const parts = name.split("-"), rest = parts.slice(1).map((part => part[0].toUpperCase() + part.slice(1))).join("");
            return parts[0] + rest;
        }
        class StyleAttributor extends Attributor {
            static keys(node) {
                return (node.getAttribute("style") || "").split(";").map((value => value.split(":")[0].trim()));
            }
            add(node, value) {
                return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;
            }
            remove(node) {
                node.style[camelize(this.keyName)] = "", node.getAttribute("style") || node.removeAttribute("style");
            }
            value(node) {
                const value = node.style[camelize(this.keyName)];
                return this.canAdd(node, value) ? value : "";
            }
        }
        const StyleAttributor$1 = StyleAttributor;
        class AttributorStore {
            constructor(domNode) {
                this.attributes = {}, this.domNode = domNode, this.build();
            }
            attribute(attribute, value) {
                value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), 
                delete this.attributes[attribute.attrName]);
            }
            build() {
                this.attributes = {};
                const blot = Registry.find(this.domNode);
                if (blot == null) return;
                const attributes = Attributor.keys(this.domNode), classes = ClassAttributor$1.keys(this.domNode), styles = StyleAttributor$1.keys(this.domNode);
                attributes.concat(classes).concat(styles).forEach((name => {
                    const attr = blot.scroll.query(name, Scope.ATTRIBUTE);
                    attr instanceof Attributor && (this.attributes[attr.attrName] = attr);
                }));
            }
            copy(target) {
                Object.keys(this.attributes).forEach((key => {
                    const value = this.attributes[key].value(this.domNode);
                    target.format(key, value);
                }));
            }
            move(target) {
                this.copy(target), Object.keys(this.attributes).forEach((key => {
                    this.attributes[key].remove(this.domNode);
                })), this.attributes = {};
            }
            values() {
                return Object.keys(this.attributes).reduce(((attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), 
                attributes)), {});
            }
        }
        const AttributorStore$1 = AttributorStore, _ShadowBlot = class _ShadowBlot {
            constructor(scroll, domNode) {
                this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), 
                this.prev = null, this.next = null;
            }
            static create(rawValue) {
                if (this.tagName == null) throw new ParchmentError("Blot definition missing tagName");
                let node, value;
                return Array.isArray(this.tagName) ? (typeof rawValue == "string" ? (value = rawValue.toUpperCase(), 
                parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == "number" && (value = rawValue), 
                typeof value == "number" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), 
                this.className && node.classList.add(this.className), node;
            }
            get statics() {
                return this.constructor;
            }
            attach() {}
            clone() {
                const domNode = this.domNode.cloneNode(!1);
                return this.scroll.create(domNode);
            }
            detach() {
                this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);
            }
            deleteAt(index, length) {
                this.isolate(index, length).remove();
            }
            formatAt(index, length, name, value) {
                const blot = this.isolate(index, length);
                if (this.scroll.query(name, Scope.BLOT) != null && value) blot.wrap(name, value); else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {
                    const parent = this.scroll.create(this.statics.scope);
                    blot.wrap(parent), parent.format(name, value);
                }
            }
            insertAt(index, value, def) {
                const blot = def == null ? this.scroll.create("text", value) : this.scroll.create(value, def), ref = this.split(index);
                this.parent.insertBefore(blot, ref || void 0);
            }
            isolate(index, length) {
                const target = this.split(index);
                if (target == null) throw new Error("Attempt to isolate at end");
                return target.split(length), target;
            }
            length() {
                return 1;
            }
            offset(root = this.parent) {
                return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);
            }
            optimize(_context) {
                this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
            }
            remove() {
                this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), 
                this.detach();
            }
            replaceWith(name, value) {
                const replacement = typeof name == "string" ? this.scroll.create(name, value) : name;
                return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), 
                this.remove()), replacement;
            }
            split(index, _force) {
                return index === 0 ? this : this.next;
            }
            update(_mutations, _context) {}
            wrap(name, value) {
                const wrapper = typeof name == "string" ? this.scroll.create(name, value) : name;
                if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), 
                typeof wrapper.appendChild != "function") throw new ParchmentError(`Cannot wrap ${name}`);
                return wrapper.appendChild(this), wrapper;
            }
        };
        _ShadowBlot.blotName = "abstract";
        let ShadowBlot = _ShadowBlot;
        const _LeafBlot = class _LeafBlot extends ShadowBlot {
            static value(_domNode) {
                return !0;
            }
            index(node, offset) {
                return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;
            }
            position(index, _inclusive) {
                let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
                return index > 0 && (offset += 1), [ this.parent.domNode, offset ];
            }
            value() {
                return {
                    [this.statics.blotName]: this.statics.value(this.domNode) || !0
                };
            }
        };
        _LeafBlot.scope = Scope.INLINE_BLOT;
        let LeafBlot = _LeafBlot;
        const LeafBlot$1 = LeafBlot;
        class LinkedList {
            constructor() {
                this.head = null, this.tail = null, this.length = 0;
            }
            append(...nodes) {
                if (this.insertBefore(nodes[0], null), nodes.length > 1) {
                    const rest = nodes.slice(1);
                    this.append(...rest);
                }
            }
            at(index) {
                const next = this.iterator();
                let cur = next();
                for (;cur && index > 0; ) index -= 1, cur = next();
                return cur;
            }
            contains(node) {
                const next = this.iterator();
                let cur = next();
                for (;cur; ) {
                    if (cur === node) return !0;
                    cur = next();
                }
                return !1;
            }
            indexOf(node) {
                const next = this.iterator();
                let cur = next(), index = 0;
                for (;cur; ) {
                    if (cur === node) return index;
                    index += 1, cur = next();
                }
                return -1;
            }
            insertBefore(node, refNode) {
                node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, 
                refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, 
                node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), 
                this.length += 1);
            }
            offset(target) {
                let index = 0, cur = this.head;
                for (;cur != null; ) {
                    if (cur === target) return index;
                    index += cur.length(), cur = cur.next;
                }
                return -1;
            }
            remove(node) {
                this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), 
                node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), 
                this.length -= 1);
            }
            iterator(curNode = this.head) {
                return () => {
                    const ret = curNode;
                    return curNode != null && (curNode = curNode.next), ret;
                };
            }
            find(index, inclusive = !1) {
                const next = this.iterator();
                let cur = next();
                for (;cur; ) {
                    const length = cur.length();
                    if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) return [ cur, index ];
                    index -= length, cur = next();
                }
                return [ null, 0 ];
            }
            forEach(callback) {
                const next = this.iterator();
                let cur = next();
                for (;cur; ) callback(cur), cur = next();
            }
            forEachAt(index, length, callback) {
                if (length <= 0) return;
                const [startNode, offset] = this.find(index);
                let curIndex = index - offset;
                const next = this.iterator(startNode);
                let cur = next();
                for (;cur && curIndex < index + length; ) {
                    const curLength = cur.length();
                    index > curIndex ? callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index)) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), 
                    curIndex += curLength, cur = next();
                }
            }
            map(callback) {
                return this.reduce(((memo, cur) => (memo.push(callback(cur)), memo)), []);
            }
            reduce(callback, memo) {
                const next = this.iterator();
                let cur = next();
                for (;cur; ) memo = callback(memo, cur), cur = next();
                return memo;
            }
        }
        function makeAttachedBlot(node, scroll) {
            const found = scroll.find(node);
            if (found) return found;
            try {
                return scroll.create(node);
            } catch {
                const blot = scroll.create(Scope.INLINE);
                return Array.from(node.childNodes).forEach((child => {
                    blot.domNode.appendChild(child);
                })), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), 
                blot;
            }
        }
        const _ParentBlot = class _ParentBlot extends ShadowBlot {
            constructor(scroll, domNode) {
                super(scroll, domNode), this.uiNode = null, this.build();
            }
            appendChild(other) {
                this.insertBefore(other);
            }
            attach() {
                super.attach(), this.children.forEach((child => {
                    child.attach();
                }));
            }
            attachUI(node) {
                this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), 
                this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
            }
            build() {
                this.children = new LinkedList, Array.from(this.domNode.childNodes).filter((node => node !== this.uiNode)).reverse().forEach((node => {
                    try {
                        const child = makeAttachedBlot(node, this.scroll);
                        this.insertBefore(child, this.children.head || void 0);
                    } catch (err) {
                        if (err instanceof ParchmentError) return;
                        throw err;
                    }
                }));
            }
            deleteAt(index, length) {
                if (index === 0 && length === this.length()) return this.remove();
                this.children.forEachAt(index, length, ((child, offset, childLength) => {
                    child.deleteAt(offset, childLength);
                }));
            }
            descendant(criteria, index = 0) {
                const [child, offset] = this.children.find(index);
                return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [ child, offset ] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [ null, -1 ];
            }
            descendants(criteria, index = 0, length = Number.MAX_VALUE) {
                let descendants = [], lengthLeft = length;
                return this.children.forEachAt(index, length, ((child, childIndex, childLength) => {
                    (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), 
                    child instanceof _ParentBlot && (descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft))), 
                    lengthLeft -= childLength;
                })), descendants;
            }
            detach() {
                this.children.forEach((child => {
                    child.detach();
                })), super.detach();
            }
            enforceAllowedChildren() {
                let done = !1;
                this.children.forEach((child => {
                    done || this.statics.allowedChildren.some((def => child instanceof def)) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), 
                    child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());
                }));
            }
            formatAt(index, length, name, value) {
                this.children.forEachAt(index, length, ((child, offset, childLength) => {
                    child.formatAt(offset, childLength, name, value);
                }));
            }
            insertAt(index, value, def) {
                const [child, offset] = this.children.find(index);
                if (child) child.insertAt(offset, value, def); else {
                    const blot = def == null ? this.scroll.create("text", value) : this.scroll.create(value, def);
                    this.appendChild(blot);
                }
            }
            insertBefore(childBlot, refBlot) {
                childBlot.parent != null && childBlot.parent.children.remove(childBlot);
                let refDomNode = null;
                this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, 
                refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), 
                childBlot.attach();
            }
            length() {
                return this.children.reduce(((memo, child) => memo + child.length()), 0);
            }
            moveChildren(targetParent, refNode) {
                this.children.forEach((child => {
                    targetParent.insertBefore(child, refNode);
                }));
            }
            optimize(context) {
                if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), 
                this.children.length === 0) if (this.statics.defaultChild != null) {
                    const child = this.scroll.create(this.statics.defaultChild.blotName);
                    this.appendChild(child);
                } else this.remove();
            }
            path(index, inclusive = !1) {
                const [child, offset] = this.children.find(index, inclusive), position = [ [ this, index ] ];
                return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([ child, offset ]), 
                position);
            }
            removeChild(child) {
                this.children.remove(child);
            }
            replaceWith(name, value) {
                const replacement = typeof name == "string" ? this.scroll.create(name, value) : name;
                return replacement instanceof _ParentBlot && this.moveChildren(replacement), super.replaceWith(replacement);
            }
            split(index, force = !1) {
                if (!force) {
                    if (index === 0) return this;
                    if (index === this.length()) return this.next;
                }
                const after = this.clone();
                return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), ((child, offset, _length) => {
                    const split = child.split(offset, force);
                    split != null && after.appendChild(split);
                })), after;
            }
            splitAfter(child) {
                const after = this.clone();
                for (;child.next != null; ) after.appendChild(child.next);
                return this.parent && this.parent.insertBefore(after, this.next || void 0), after;
            }
            unwrap() {
                this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
            }
            update(mutations, _context) {
                const addedNodes = [], removedNodes = [];
                mutations.forEach((mutation => {
                    mutation.target === this.domNode && mutation.type === "childList" && (addedNodes.push(...mutation.addedNodes), 
                    removedNodes.push(...mutation.removedNodes));
                })), removedNodes.forEach((node => {
                    if (node.parentNode != null && node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;
                    const blot = this.scroll.find(node);
                    blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();
                })), addedNodes.filter((node => node.parentNode === this.domNode && node !== this.uiNode)).sort(((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1)).forEach((node => {
                    let refBlot = null;
                    node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));
                    const blot = makeAttachedBlot(node, this.scroll);
                    (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), 
                    this.insertBefore(blot, refBlot || void 0));
                })), this.enforceAllowedChildren();
            }
        };
        _ParentBlot.uiClass = "";
        let ParentBlot = _ParentBlot;
        const ParentBlot$1 = ParentBlot;
        function isEqual(obj1, obj2) {
            if (Object.keys(obj1).length !== Object.keys(obj2).length) return !1;
            for (const prop in obj1) if (obj1[prop] !== obj2[prop]) return !1;
            return !0;
        }
        const _InlineBlot = class _InlineBlot extends ParentBlot$1 {
            static create(value) {
                return super.create(value);
            }
            static formats(domNode, scroll) {
                const match2 = scroll.query(_InlineBlot.blotName);
                if (!(match2 != null && domNode.tagName === match2.tagName)) {
                    if (typeof this.tagName == "string") return !0;
                    if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();
                }
            }
            constructor(scroll, domNode) {
                super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
            }
            format(name, value) {
                if (name === this.statics.blotName && !value) this.children.forEach((child => {
                    child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), 
                    this.attributes.copy(child);
                })), this.unwrap(); else {
                    const format = this.scroll.query(name, Scope.INLINE);
                    if (format == null) return;
                    format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);
                }
            }
            formats() {
                const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
                return format != null && (formats[this.statics.blotName] = format), formats;
            }
            formatAt(index, length, name, value) {
                this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);
            }
            optimize(context) {
                super.optimize(context);
                const formats = this.formats();
                if (Object.keys(formats).length === 0) return this.unwrap();
                const next = this.next;
                next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), 
                next.remove());
            }
            replaceWith(name, value) {
                const replacement = super.replaceWith(name, value);
                return this.attributes.copy(replacement), replacement;
            }
            update(mutations, context) {
                super.update(mutations, context), mutations.some((mutation => mutation.target === this.domNode && mutation.type === "attributes")) && this.attributes.build();
            }
            wrap(name, value) {
                const wrapper = super.wrap(name, value);
                return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;
            }
        };
        _InlineBlot.allowedChildren = [ _InlineBlot, LeafBlot$1 ], _InlineBlot.blotName = "inline", 
        _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = "SPAN";
        let InlineBlot = _InlineBlot;
        const InlineBlot$1 = InlineBlot, _BlockBlot = class _BlockBlot extends ParentBlot$1 {
            static create(value) {
                return super.create(value);
            }
            static formats(domNode, scroll) {
                const match2 = scroll.query(_BlockBlot.blotName);
                if (!(match2 != null && domNode.tagName === match2.tagName)) {
                    if (typeof this.tagName == "string") return !0;
                    if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();
                }
            }
            constructor(scroll, domNode) {
                super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
            }
            format(name, value) {
                const format = this.scroll.query(name, Scope.BLOCK);
                format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));
            }
            formats() {
                const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
                return format != null && (formats[this.statics.blotName] = format), formats;
            }
            formatAt(index, length, name, value) {
                this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);
            }
            insertAt(index, value, def) {
                if (def == null || this.scroll.query(value, Scope.INLINE) != null) super.insertAt(index, value, def); else {
                    const after = this.split(index);
                    if (after != null) {
                        const blot = this.scroll.create(value, def);
                        after.parent.insertBefore(blot, after);
                    } else throw new Error("Attempt to insertAt after block boundaries");
                }
            }
            replaceWith(name, value) {
                const replacement = super.replaceWith(name, value);
                return this.attributes.copy(replacement), replacement;
            }
            update(mutations, context) {
                super.update(mutations, context), mutations.some((mutation => mutation.target === this.domNode && mutation.type === "attributes")) && this.attributes.build();
            }
        };
        _BlockBlot.blotName = "block", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = "P", 
        _BlockBlot.allowedChildren = [ InlineBlot$1, _BlockBlot, LeafBlot$1 ];
        let BlockBlot = _BlockBlot;
        const BlockBlot$1 = BlockBlot, _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {
            checkMerge() {
                return this.next !== null && this.next.statics.blotName === this.statics.blotName;
            }
            deleteAt(index, length) {
                super.deleteAt(index, length), this.enforceAllowedChildren();
            }
            formatAt(index, length, name, value) {
                super.formatAt(index, length, name, value), this.enforceAllowedChildren();
            }
            insertAt(index, value, def) {
                super.insertAt(index, value, def), this.enforceAllowedChildren();
            }
            optimize(context) {
                super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), 
                this.next.remove());
            }
        };
        _ContainerBlot.blotName = "container", _ContainerBlot.scope = Scope.BLOCK_BLOT;
        let ContainerBlot = _ContainerBlot;
        const ContainerBlot$1 = ContainerBlot;
        class EmbedBlot extends LeafBlot$1 {
            static formats(_domNode, _scroll) {}
            format(name, value) {
                super.formatAt(0, this.length(), name, value);
            }
            formatAt(index, length, name, value) {
                index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);
            }
            formats() {
                return this.statics.formats(this.domNode, this.scroll);
            }
        }
        const EmbedBlot$1 = EmbedBlot, OBSERVER_CONFIG = {
            attributes: !0,
            characterData: !0,
            characterDataOldValue: !0,
            childList: !0,
            subtree: !0
        }, MAX_OPTIMIZE_ITERATIONS = 100, _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {
            constructor(registry, node) {
                super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver((mutations => {
                    this.update(mutations);
                })), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();
            }
            create(input, value) {
                return this.registry.create(this, input, value);
            }
            find(node, bubble = !1) {
                const blot = this.registry.find(node, bubble);
                return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;
            }
            query(query, scope = Scope.ANY) {
                return this.registry.query(query, scope);
            }
            register(...definitions) {
                return this.registry.register(...definitions);
            }
            build() {
                this.scroll != null && super.build();
            }
            detach() {
                super.detach(), this.observer.disconnect();
            }
            deleteAt(index, length) {
                this.update(), index === 0 && length === this.length() ? this.children.forEach((child => {
                    child.remove();
                })) : super.deleteAt(index, length);
            }
            formatAt(index, length, name, value) {
                this.update(), super.formatAt(index, length, name, value);
            }
            insertAt(index, value, def) {
                this.update(), super.insertAt(index, value, def);
            }
            optimize(mutations = [], context = {}) {
                super.optimize(context);
                const mutationsMap = context.mutationsMap || new WeakMap;
                let records = Array.from(this.observer.takeRecords());
                for (;records.length > 0; ) mutations.push(records.pop());
                const mark = (blot, markParent = !0) => {
                    blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), 
                    markParent && mark(blot.parent));
                }, optimize = blot => {
                    mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), 
                    mutationsMap.delete(blot.domNode), blot.optimize(context));
                };
                let remaining = mutations;
                for (let i = 0; remaining.length > 0; i += 1) {
                    if (i >= MAX_OPTIMIZE_ITERATIONS) throw new Error("[Parchment] Maximum optimize iterations reached");
                    for (remaining.forEach((mutation => {
                        const blot = this.find(mutation.target, !0);
                        blot != null && (blot.domNode === mutation.target && (mutation.type === "childList" ? (mark(this.find(mutation.previousSibling, !1)), 
                        Array.from(mutation.addedNodes).forEach((node => {
                            const child = this.find(node, !1);
                            mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach((grandChild => {
                                mark(grandChild, !1);
                            }));
                        }))) : mutation.type === "attributes" && mark(blot.prev)), mark(blot));
                    })), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), 
                    records = remaining.slice(); records.length > 0; ) mutations.push(records.pop());
                }
            }
            update(mutations, context = {}) {
                mutations = mutations || this.observer.takeRecords();
                const mutationsMap = new WeakMap;
                mutations.map((mutation => {
                    const blot = this.find(mutation.target, !0);
                    return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), 
                    null) : (mutationsMap.set(blot.domNode, [ mutation ]), blot);
                })).forEach((blot => {
                    blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);
                })), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), 
                this.optimize(mutations, context);
            }
        };
        _ScrollBlot.blotName = "scroll", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [ BlockBlot$1, ContainerBlot$1 ], 
        _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = "DIV";
        let ScrollBlot = _ScrollBlot;
        const ScrollBlot$1 = ScrollBlot, _TextBlot = class _TextBlot extends LeafBlot$1 {
            static create(value) {
                return document.createTextNode(value);
            }
            static value(domNode) {
                return domNode.data;
            }
            constructor(scroll, node) {
                super(scroll, node), this.text = this.statics.value(this.domNode);
            }
            deleteAt(index, length) {
                this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
            }
            index(node, offset) {
                return this.domNode === node ? offset : -1;
            }
            insertAt(index, value, def) {
                def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), 
                this.domNode.data = this.text) : super.insertAt(index, value, def);
            }
            length() {
                return this.text.length;
            }
            optimize(context) {
                super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), 
                this.next.remove());
            }
            position(index, _inclusive = !1) {
                return [ this.domNode, index ];
            }
            split(index, force = !1) {
                if (!force) {
                    if (index === 0) return this;
                    if (index === this.length()) return this.next;
                }
                const after = this.scroll.create(this.domNode.splitText(index));
                return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), 
                after;
            }
            update(mutations, _context) {
                mutations.some((mutation => mutation.type === "characterData" && mutation.target === this.domNode)) && (this.text = this.statics.value(this.domNode));
            }
            value() {
                return this.text;
            }
        };
        _TextBlot.blotName = "text", _TextBlot.scope = Scope.INLINE_BLOT;
        let TextBlot = _TextBlot;
        const TextBlot$1 = TextBlot;
        var Delta = __webpack_require__(660);
        function arrayEach(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) if (iteratee(array[index], index, array) === false) break;
            return array;
        }
        const _arrayEach = arrayEach;
        var nativeKeys = _overArg(Object.keys, Object);
        const _nativeKeys = nativeKeys;
        var _baseKeys_objectProto = Object.prototype;
        var _baseKeys_hasOwnProperty = _baseKeys_objectProto.hasOwnProperty;
        function baseKeys(object) {
            if (!_isPrototype(object)) return _nativeKeys(object);
            var result = [];
            for (var key in Object(object)) if (_baseKeys_hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
            return result;
        }
        const _baseKeys = baseKeys;
        function keys(object) {
            return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object) : _baseKeys(object);
        }
        const lodash_es_keys = keys;
        function baseAssign(object, source) {
            return object && _copyObject(source, lodash_es_keys(source), object);
        }
        const _baseAssign = baseAssign;
        function baseAssignIn(object, source) {
            return object && _copyObject(source, lodash_es_keysIn(source), object);
        }
        const _baseAssignIn = baseAssignIn;
        function arrayFilter(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) result[resIndex++] = value;
            }
            return result;
        }
        const _arrayFilter = arrayFilter;
        function stubArray() {
            return [];
        }
        const lodash_es_stubArray = stubArray;
        var _getSymbols_objectProto = Object.prototype;
        var _getSymbols_propertyIsEnumerable = _getSymbols_objectProto.propertyIsEnumerable;
        var nativeGetSymbols = Object.getOwnPropertySymbols;
        var getSymbols = !nativeGetSymbols ? lodash_es_stubArray : function(object) {
            if (object == null) return [];
            object = Object(object);
            return _arrayFilter(nativeGetSymbols(object), (function(symbol) {
                return _getSymbols_propertyIsEnumerable.call(object, symbol);
            }));
        };
        const _getSymbols = getSymbols;
        function copySymbols(source, object) {
            return _copyObject(source, _getSymbols(source), object);
        }
        const _copySymbols = copySymbols;
        function arrayPush(array, values) {
            var index = -1, length = values.length, offset = array.length;
            while (++index < length) array[offset + index] = values[index];
            return array;
        }
        const _arrayPush = arrayPush;
        var _getSymbolsIn_nativeGetSymbols = Object.getOwnPropertySymbols;
        var getSymbolsIn = !_getSymbolsIn_nativeGetSymbols ? lodash_es_stubArray : function(object) {
            var result = [];
            while (object) {
                _arrayPush(result, _getSymbols(object));
                object = _getPrototype(object);
            }
            return result;
        };
        const _getSymbolsIn = getSymbolsIn;
        function copySymbolsIn(source, object) {
            return _copyObject(source, _getSymbolsIn(source), object);
        }
        const _copySymbolsIn = copySymbolsIn;
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return lodash_es_isArray(object) ? result : _arrayPush(result, symbolsFunc(object));
        }
        const _baseGetAllKeys = baseGetAllKeys;
        function getAllKeys(object) {
            return _baseGetAllKeys(object, lodash_es_keys, _getSymbols);
        }
        const _getAllKeys = getAllKeys;
        function getAllKeysIn(object) {
            return _baseGetAllKeys(object, lodash_es_keysIn, _getSymbolsIn);
        }
        const _getAllKeysIn = getAllKeysIn;
        var DataView = _getNative(_root, "DataView");
        const _DataView = DataView;
        var _Promise_Promise = _getNative(_root, "Promise");
        const _Promise = _Promise_Promise;
        var Set = _getNative(_root, "Set");
        const _Set = Set;
        var _WeakMap_WeakMap = _getNative(_root, "WeakMap");
        const _WeakMap = _WeakMap_WeakMap;
        var _getTag_mapTag = "[object Map]", _getTag_objectTag = "[object Object]", promiseTag = "[object Promise]", _getTag_setTag = "[object Set]", _getTag_weakMapTag = "[object WeakMap]";
        var _getTag_dataViewTag = "[object DataView]";
        var dataViewCtorString = _toSource(_DataView), mapCtorString = _toSource(_Map), promiseCtorString = _toSource(_Promise), setCtorString = _toSource(_Set), weakMapCtorString = _toSource(_WeakMap);
        var getTag = _baseGetTag;
        if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != _getTag_dataViewTag || _Map && getTag(new _Map) != _getTag_mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set) != _getTag_setTag || _WeakMap && getTag(new _WeakMap) != _getTag_weakMapTag) getTag = function(value) {
            var result = _baseGetTag(value), Ctor = result == _getTag_objectTag ? value.constructor : void 0, ctorString = Ctor ? _toSource(Ctor) : "";
            if (ctorString) switch (ctorString) {
              case dataViewCtorString:
                return _getTag_dataViewTag;

              case mapCtorString:
                return _getTag_mapTag;

              case promiseCtorString:
                return promiseTag;

              case setCtorString:
                return _getTag_setTag;

              case weakMapCtorString:
                return _getTag_weakMapTag;
            }
            return result;
        };
        const _getTag = getTag;
        var _initCloneArray_objectProto = Object.prototype;
        var _initCloneArray_hasOwnProperty = _initCloneArray_objectProto.hasOwnProperty;
        function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == "string" && _initCloneArray_hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        const _initCloneArray = initCloneArray;
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        const _cloneDataView = cloneDataView;
        var reFlags = /\w*$/;
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        const _cloneRegExp = cloneRegExp;
        var symbolProto = _Symbol ? _Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        const _cloneSymbol = cloneSymbol;
        var _initCloneByTag_boolTag = "[object Boolean]", _initCloneByTag_dateTag = "[object Date]", _initCloneByTag_mapTag = "[object Map]", _initCloneByTag_numberTag = "[object Number]", _initCloneByTag_regexpTag = "[object RegExp]", _initCloneByTag_setTag = "[object Set]", _initCloneByTag_stringTag = "[object String]", symbolTag = "[object Symbol]";
        var _initCloneByTag_arrayBufferTag = "[object ArrayBuffer]", _initCloneByTag_dataViewTag = "[object DataView]", _initCloneByTag_float32Tag = "[object Float32Array]", _initCloneByTag_float64Tag = "[object Float64Array]", _initCloneByTag_int8Tag = "[object Int8Array]", _initCloneByTag_int16Tag = "[object Int16Array]", _initCloneByTag_int32Tag = "[object Int32Array]", _initCloneByTag_uint8Tag = "[object Uint8Array]", _initCloneByTag_uint8ClampedTag = "[object Uint8ClampedArray]", _initCloneByTag_uint16Tag = "[object Uint16Array]", _initCloneByTag_uint32Tag = "[object Uint32Array]";
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case _initCloneByTag_arrayBufferTag:
                return _cloneArrayBuffer(object);

              case _initCloneByTag_boolTag:
              case _initCloneByTag_dateTag:
                return new Ctor(+object);

              case _initCloneByTag_dataViewTag:
                return _cloneDataView(object, isDeep);

              case _initCloneByTag_float32Tag:
              case _initCloneByTag_float64Tag:
              case _initCloneByTag_int8Tag:
              case _initCloneByTag_int16Tag:
              case _initCloneByTag_int32Tag:
              case _initCloneByTag_uint8Tag:
              case _initCloneByTag_uint8ClampedTag:
              case _initCloneByTag_uint16Tag:
              case _initCloneByTag_uint32Tag:
                return _cloneTypedArray(object, isDeep);

              case _initCloneByTag_mapTag:
                return new Ctor;

              case _initCloneByTag_numberTag:
              case _initCloneByTag_stringTag:
                return new Ctor(object);

              case _initCloneByTag_regexpTag:
                return _cloneRegExp(object);

              case _initCloneByTag_setTag:
                return new Ctor;

              case symbolTag:
                return _cloneSymbol(object);
            }
        }
        const _initCloneByTag = initCloneByTag;
        var _baseIsMap_mapTag = "[object Map]";
        function baseIsMap(value) {
            return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsMap_mapTag;
        }
        const _baseIsMap = baseIsMap;
        var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
        var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
        const lodash_es_isMap = isMap;
        var _baseIsSet_setTag = "[object Set]";
        function baseIsSet(value) {
            return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsSet_setTag;
        }
        const _baseIsSet = baseIsSet;
        var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
        var isSet_isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
        const lodash_es_isSet = isSet_isSet;
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var _baseClone_argsTag = "[object Arguments]", _baseClone_arrayTag = "[object Array]", _baseClone_boolTag = "[object Boolean]", _baseClone_dateTag = "[object Date]", _baseClone_errorTag = "[object Error]", _baseClone_funcTag = "[object Function]", _baseClone_genTag = "[object GeneratorFunction]", _baseClone_mapTag = "[object Map]", _baseClone_numberTag = "[object Number]", _baseClone_objectTag = "[object Object]", _baseClone_regexpTag = "[object RegExp]", _baseClone_setTag = "[object Set]", _baseClone_stringTag = "[object String]", _baseClone_symbolTag = "[object Symbol]", _baseClone_weakMapTag = "[object WeakMap]";
        var _baseClone_arrayBufferTag = "[object ArrayBuffer]", _baseClone_dataViewTag = "[object DataView]", _baseClone_float32Tag = "[object Float32Array]", _baseClone_float64Tag = "[object Float64Array]", _baseClone_int8Tag = "[object Int8Array]", _baseClone_int16Tag = "[object Int16Array]", _baseClone_int32Tag = "[object Int32Array]", _baseClone_uint8Tag = "[object Uint8Array]", _baseClone_uint8ClampedTag = "[object Uint8ClampedArray]", _baseClone_uint16Tag = "[object Uint16Array]", _baseClone_uint32Tag = "[object Uint32Array]";
        var cloneableTags = {};
        cloneableTags[_baseClone_argsTag] = cloneableTags[_baseClone_arrayTag] = cloneableTags[_baseClone_arrayBufferTag] = cloneableTags[_baseClone_dataViewTag] = cloneableTags[_baseClone_boolTag] = cloneableTags[_baseClone_dateTag] = cloneableTags[_baseClone_float32Tag] = cloneableTags[_baseClone_float64Tag] = cloneableTags[_baseClone_int8Tag] = cloneableTags[_baseClone_int16Tag] = cloneableTags[_baseClone_int32Tag] = cloneableTags[_baseClone_mapTag] = cloneableTags[_baseClone_numberTag] = cloneableTags[_baseClone_objectTag] = cloneableTags[_baseClone_regexpTag] = cloneableTags[_baseClone_setTag] = cloneableTags[_baseClone_stringTag] = cloneableTags[_baseClone_symbolTag] = cloneableTags[_baseClone_uint8Tag] = cloneableTags[_baseClone_uint8ClampedTag] = cloneableTags[_baseClone_uint16Tag] = cloneableTags[_baseClone_uint32Tag] = true;
        cloneableTags[_baseClone_errorTag] = cloneableTags[_baseClone_funcTag] = cloneableTags[_baseClone_weakMapTag] = false;
        function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
            if (result !== void 0) return result;
            if (!lodash_es_isObject(value)) return value;
            var isArr = lodash_es_isArray(value);
            if (isArr) {
                result = _initCloneArray(value);
                if (!isDeep) return _copyArray(value, result);
            } else {
                var tag = _getTag(value), isFunc = tag == _baseClone_funcTag || tag == _baseClone_genTag;
                if (lodash_es_isBuffer(value)) return _cloneBuffer(value, isDeep);
                if (tag == _baseClone_objectTag || tag == _baseClone_argsTag || isFunc && !object) {
                    result = isFlat || isFunc ? {} : _initCloneObject(value);
                    if (!isDeep) return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
                } else {
                    if (!cloneableTags[tag]) return object ? value : {};
                    result = _initCloneByTag(value, tag, isDeep);
                }
            }
            stack || (stack = new _Stack);
            var stacked = stack.get(value);
            if (stacked) return stacked;
            stack.set(value, result);
            if (lodash_es_isSet(value)) value.forEach((function(subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            })); else if (lodash_es_isMap(value)) value.forEach((function(subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            }));
            var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? lodash_es_keysIn : lodash_es_keys;
            var props = isArr ? void 0 : keysFunc(value);
            _arrayEach(props || value, (function(subValue, key) {
                if (props) {
                    key = subValue;
                    subValue = value[key];
                }
                _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            }));
            return result;
        }
        const _baseClone = baseClone;
        var cloneDeep_CLONE_DEEP_FLAG = 1, cloneDeep_CLONE_SYMBOLS_FLAG = 4;
        function cloneDeep(value) {
            return _baseClone(value, cloneDeep_CLONE_DEEP_FLAG | cloneDeep_CLONE_SYMBOLS_FLAG);
        }
        const lodash_es_cloneDeep = cloneDeep;
        var _setCacheAdd_HASH_UNDEFINED = "__lodash_hash_undefined__";
        function setCacheAdd(value) {
            this.__data__.set(value, _setCacheAdd_HASH_UNDEFINED);
            return this;
        }
        const _setCacheAdd = setCacheAdd;
        function setCacheHas(value) {
            return this.__data__.has(value);
        }
        const _setCacheHas = setCacheHas;
        function SetCache(values) {
            var index = -1, length = values == null ? 0 : values.length;
            this.__data__ = new _MapCache;
            while (++index < length) this.add(values[index]);
        }
        SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
        SetCache.prototype.has = _setCacheHas;
        const _SetCache = SetCache;
        function arraySome(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) if (predicate(array[index], index, array)) return true;
            return false;
        }
        const _arraySome = arraySome;
        function cacheHas(cache, key) {
            return cache.has(key);
        }
        const _cacheHas = cacheHas;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
            var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache : void 0;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
                var arrValue = array[index], othValue = other[index];
                if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                if (compared !== void 0) {
                    if (compared) continue;
                    result = false;
                    break;
                }
                if (seen) {
                    if (!_arraySome(other, (function(othValue, othIndex) {
                        if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                    }))) {
                        result = false;
                        break;
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result = false;
                    break;
                }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result;
        }
        const _equalArrays = equalArrays;
        function mapToArray(map) {
            var index = -1, result = Array(map.size);
            map.forEach((function(value, key) {
                result[++index] = [ key, value ];
            }));
            return result;
        }
        const _mapToArray = mapToArray;
        function setToArray(set) {
            var index = -1, result = Array(set.size);
            set.forEach((function(value) {
                result[++index] = value;
            }));
            return result;
        }
        const _setToArray = setToArray;
        var _equalByTag_COMPARE_PARTIAL_FLAG = 1, _equalByTag_COMPARE_UNORDERED_FLAG = 2;
        var _equalByTag_boolTag = "[object Boolean]", _equalByTag_dateTag = "[object Date]", _equalByTag_errorTag = "[object Error]", _equalByTag_mapTag = "[object Map]", _equalByTag_numberTag = "[object Number]", _equalByTag_regexpTag = "[object RegExp]", _equalByTag_setTag = "[object Set]", _equalByTag_stringTag = "[object String]", _equalByTag_symbolTag = "[object Symbol]";
        var _equalByTag_arrayBufferTag = "[object ArrayBuffer]", _equalByTag_dataViewTag = "[object DataView]";
        var _equalByTag_symbolProto = _Symbol ? _Symbol.prototype : void 0, _equalByTag_symbolValueOf = _equalByTag_symbolProto ? _equalByTag_symbolProto.valueOf : void 0;
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case _equalByTag_dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
                object = object.buffer;
                other = other.buffer;

              case _equalByTag_arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) return false;
                return true;

              case _equalByTag_boolTag:
              case _equalByTag_dateTag:
              case _equalByTag_numberTag:
                return lodash_es_eq(+object, +other);

              case _equalByTag_errorTag:
                return object.name == other.name && object.message == other.message;

              case _equalByTag_regexpTag:
              case _equalByTag_stringTag:
                return object == other + "";

              case _equalByTag_mapTag:
                var convert = _mapToArray;

              case _equalByTag_setTag:
                var isPartial = bitmask & _equalByTag_COMPARE_PARTIAL_FLAG;
                convert || (convert = _setToArray);
                if (object.size != other.size && !isPartial) return false;
                var stacked = stack.get(object);
                if (stacked) return stacked == other;
                bitmask |= _equalByTag_COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result;

              case _equalByTag_symbolTag:
                if (_equalByTag_symbolValueOf) return _equalByTag_symbolValueOf.call(object) == _equalByTag_symbolValueOf.call(other);
            }
            return false;
        }
        const _equalByTag = equalByTag;
        var _equalObjects_COMPARE_PARTIAL_FLAG = 1;
        var _equalObjects_objectProto = Object.prototype;
        var _equalObjects_hasOwnProperty = _equalObjects_objectProto.hasOwnProperty;
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & _equalObjects_COMPARE_PARTIAL_FLAG, objProps = _getAllKeys(object), objLength = objProps.length, othProps = _getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) return false;
            var index = objLength;
            while (index--) {
                var key = objProps[index];
                if (!(isPartial ? key in other : _equalObjects_hasOwnProperty.call(other, key))) return false;
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) return objStacked == other && othStacked == object;
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = false;
                    break;
                }
                skipCtor || (skipCtor = key == "constructor");
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
            }
            stack["delete"](object);
            stack["delete"](other);
            return result;
        }
        const _equalObjects = equalObjects;
        var _baseIsEqualDeep_COMPARE_PARTIAL_FLAG = 1;
        var _baseIsEqualDeep_argsTag = "[object Arguments]", _baseIsEqualDeep_arrayTag = "[object Array]", _baseIsEqualDeep_objectTag = "[object Object]";
        var _baseIsEqualDeep_objectProto = Object.prototype;
        var _baseIsEqualDeep_hasOwnProperty = _baseIsEqualDeep_objectProto.hasOwnProperty;
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = lodash_es_isArray(object), othIsArr = lodash_es_isArray(other), objTag = objIsArr ? _baseIsEqualDeep_arrayTag : _getTag(object), othTag = othIsArr ? _baseIsEqualDeep_arrayTag : _getTag(other);
            objTag = objTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : objTag;
            othTag = othTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : othTag;
            var objIsObj = objTag == _baseIsEqualDeep_objectTag, othIsObj = othTag == _baseIsEqualDeep_objectTag, isSameTag = objTag == othTag;
            if (isSameTag && lodash_es_isBuffer(object)) {
                if (!lodash_es_isBuffer(other)) return false;
                objIsArr = true;
                objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
                stack || (stack = new _Stack);
                return objIsArr || lodash_es_isTypedArray(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & _baseIsEqualDeep_COMPARE_PARTIAL_FLAG)) {
                var objIsWrapped = objIsObj && _baseIsEqualDeep_hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && _baseIsEqualDeep_hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new _Stack);
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                }
            }
            if (!isSameTag) return false;
            stack || (stack = new _Stack);
            return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        const _baseIsEqualDeep = baseIsEqualDeep;
        function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) return true;
            if (value == null || other == null || !lodash_es_isObjectLike(value) && !lodash_es_isObjectLike(other)) return value !== value && other !== other;
            return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        const _baseIsEqual = baseIsEqual;
        function isEqual_isEqual(value, other) {
            return _baseIsEqual(value, other);
        }
        const lodash_es_isEqual = isEqual_isEqual;
        class Break extends EmbedBlot$1 {
            static value() {
                return;
            }
            optimize() {
                if (this.prev || this.next) this.remove();
            }
            length() {
                return 0;
            }
            value() {
                return "";
            }
        }
        Break.blotName = "break";
        Break.tagName = "BR";
        const blots_break = Break;
        class text_Text extends TextBlot$1 {}
        function escapeText(text) {
            return text.replace(/[&<>"']/g, (s => {
                const entityMap = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                };
                return entityMap[s];
            }));
        }
        class Inline extends InlineBlot$1 {
            static allowedChildren=[ Inline, blots_break, EmbedBlot$1, text_Text ];
            static order=[ "cursor", "inline", "link", "underline", "strike", "italic", "bold", "script", "code" ];
            static compare(self, other) {
                const selfIndex = Inline.order.indexOf(self);
                const otherIndex = Inline.order.indexOf(other);
                if (selfIndex >= 0 || otherIndex >= 0) return selfIndex - otherIndex;
                if (self === other) return 0;
                if (self < other) return -1;
                return 1;
            }
            formatAt(index, length, name, value) {
                if (Inline.compare(this.statics.blotName, name) < 0 && this.scroll.query(name, Scope.BLOT)) {
                    const blot = this.isolate(index, length);
                    if (value) blot.wrap(name, value);
                } else super.formatAt(index, length, name, value);
            }
            optimize(context) {
                super.optimize(context);
                if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                    const parent = this.parent.isolate(this.offset(), this.length());
                    this.moveChildren(parent);
                    parent.wrap(this);
                }
            }
        }
        const inline = Inline;
        const NEWLINE_LENGTH = 1;
        class Block extends BlockBlot$1 {
            cache={};
            delta() {
                if (this.cache.delta == null) this.cache.delta = blockDelta(this);
                return this.cache.delta;
            }
            deleteAt(index, length) {
                super.deleteAt(index, length);
                this.cache = {};
            }
            formatAt(index, length, name, value) {
                if (length <= 0) return;
                if (this.scroll.query(name, Scope.BLOCK)) {
                    if (index + length === this.length()) this.format(name, value);
                } else super.formatAt(index, Math.min(length, this.length() - index - 1), name, value);
                this.cache = {};
            }
            insertAt(index, value, def) {
                if (def != null) {
                    super.insertAt(index, value, def);
                    this.cache = {};
                    return;
                }
                if (value.length === 0) return;
                const lines = value.split("\n");
                const text = lines.shift();
                if (text.length > 0) {
                    if (index < this.length() - 1 || this.children.tail == null) super.insertAt(Math.min(index, this.length() - 1), text); else this.children.tail.insertAt(this.children.tail.length(), text);
                    this.cache = {};
                }
                let block = this;
                lines.reduce(((lineIndex, line) => {
                    block = block.split(lineIndex, true);
                    block.insertAt(0, line);
                    return line.length;
                }), index + text.length);
            }
            insertBefore(blot, ref) {
                const {head} = this.children;
                super.insertBefore(blot, ref);
                if (head instanceof blots_break) head.remove();
                this.cache = {};
            }
            length() {
                if (this.cache.length == null) this.cache.length = super.length() + NEWLINE_LENGTH;
                return this.cache.length;
            }
            moveChildren(target, ref) {
                super.moveChildren(target, ref);
                this.cache = {};
            }
            optimize(context) {
                super.optimize(context);
                this.cache = {};
            }
            path(index) {
                return super.path(index, true);
            }
            removeChild(child) {
                super.removeChild(child);
                this.cache = {};
            }
            split(index) {
                let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
                    const clone = this.clone();
                    if (index === 0) {
                        this.parent.insertBefore(clone, this);
                        return this;
                    }
                    this.parent.insertBefore(clone, this.next);
                    return clone;
                }
                const next = super.split(index, force);
                this.cache = {};
                return next;
            }
        }
        Block.blotName = "block";
        Block.tagName = "P";
        Block.defaultChild = blots_break;
        Block.allowedChildren = [ blots_break, inline, EmbedBlot$1, text_Text ];
        class BlockEmbed extends EmbedBlot$1 {
            attach() {
                super.attach();
                this.attributes = new AttributorStore$1(this.domNode);
            }
            delta() {
                return (new Delta).insert(this.value(), {
                    ...this.formats(),
                    ...this.attributes.values()
                });
            }
            format(name, value) {
                const attribute = this.scroll.query(name, Scope.BLOCK_ATTRIBUTE);
                if (attribute != null) this.attributes.attribute(attribute, value);
            }
            formatAt(index, length, name, value) {
                this.format(name, value);
            }
            insertAt(index, value, def) {
                if (def != null) {
                    super.insertAt(index, value, def);
                    return;
                }
                const lines = value.split("\n");
                const text = lines.pop();
                const blocks = lines.map((line => {
                    const block = this.scroll.create(Block.blotName);
                    block.insertAt(0, line);
                    return block;
                }));
                const ref = this.split(index);
                blocks.forEach((block => {
                    this.parent.insertBefore(block, ref);
                }));
                if (text) this.parent.insertBefore(this.scroll.create("text", text), ref);
            }
        }
        BlockEmbed.scope = Scope.BLOCK_BLOT;
        function blockDelta(blot) {
            let filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            return blot.descendants(LeafBlot$1).reduce(((delta, leaf) => {
                if (leaf.length() === 0) return delta;
                return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));
            }), new Delta).insert("\n", bubbleFormats(blot));
        }
        function bubbleFormats(blot) {
            let formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            let filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (blot == null) return formats;
            if ("formats" in blot && typeof blot.formats === "function") {
                formats = {
                    ...formats,
                    ...blot.formats()
                };
                if (filter) delete formats["code-token"];
            }
            if (blot.parent == null || blot.parent.statics.blotName === "scroll" || blot.parent.statics.scope !== blot.statics.scope) return formats;
            return bubbleFormats(blot.parent, formats, filter);
        }
        class Cursor extends EmbedBlot$1 {
            static blotName="cursor";
            static className="ql-cursor";
            static tagName="span";
            static CONTENTS="\ufeff";
            static value() {
                return;
            }
            constructor(scroll, domNode, selection) {
                super(scroll, domNode);
                this.selection = selection;
                this.textNode = document.createTextNode(Cursor.CONTENTS);
                this.domNode.appendChild(this.textNode);
                this.savedLength = 0;
            }
            detach() {
                if (this.parent != null) this.parent.removeChild(this);
            }
            format(name, value) {
                if (this.savedLength !== 0) {
                    super.format(name, value);
                    return;
                }
                let target = this;
                let index = 0;
                while (target != null && target.statics.scope !== Scope.BLOCK_BLOT) {
                    index += target.offset(target.parent);
                    target = target.parent;
                }
                if (target != null) {
                    this.savedLength = Cursor.CONTENTS.length;
                    target.optimize();
                    target.formatAt(index, Cursor.CONTENTS.length, name, value);
                    this.savedLength = 0;
                }
            }
            index(node, offset) {
                if (node === this.textNode) return 0;
                return super.index(node, offset);
            }
            length() {
                return this.savedLength;
            }
            position() {
                return [ this.textNode, this.textNode.data.length ];
            }
            remove() {
                super.remove();
                this.parent = null;
            }
            restore() {
                if (this.selection.composing || this.parent == null) return null;
                const range = this.selection.getNativeRange();
                while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                const prevTextBlot = this.prev instanceof text_Text ? this.prev : null;
                const prevTextLength = prevTextBlot ? prevTextBlot.length() : 0;
                const nextTextBlot = this.next instanceof text_Text ? this.next : null;
                const nextText = nextTextBlot ? nextTextBlot.text : "";
                const {textNode} = this;
                const newText = textNode.data.split(Cursor.CONTENTS).join("");
                textNode.data = Cursor.CONTENTS;
                let mergedTextBlot;
                if (prevTextBlot) {
                    mergedTextBlot = prevTextBlot;
                    if (newText || nextTextBlot) {
                        prevTextBlot.insertAt(prevTextBlot.length(), newText + nextText);
                        if (nextTextBlot) nextTextBlot.remove();
                    }
                } else if (nextTextBlot) {
                    mergedTextBlot = nextTextBlot;
                    nextTextBlot.insertAt(0, newText);
                } else {
                    const newTextNode = document.createTextNode(newText);
                    mergedTextBlot = this.scroll.create(newTextNode);
                    this.parent.insertBefore(mergedTextBlot, this);
                }
                this.remove();
                if (range) {
                    const remapOffset = (node, offset) => {
                        if (prevTextBlot && node === prevTextBlot.domNode) return offset;
                        if (node === textNode) return prevTextLength + offset - 1;
                        if (nextTextBlot && node === nextTextBlot.domNode) return prevTextLength + newText.length + offset;
                        return null;
                    };
                    const start = remapOffset(range.start.node, range.start.offset);
                    const end = remapOffset(range.end.node, range.end.offset);
                    if (start !== null && end !== null) return {
                        startNode: mergedTextBlot.domNode,
                        startOffset: start,
                        endNode: mergedTextBlot.domNode,
                        endOffset: end
                    };
                }
                return null;
            }
            update(mutations, context) {
                if (mutations.some((mutation => mutation.type === "characterData" && mutation.target === this.textNode))) {
                    const range = this.restore();
                    if (range) context.range = range;
                }
            }
            optimize(context) {
                super.optimize(context);
                let {parent} = this;
                while (parent) {
                    if (parent.domNode.tagName === "A") {
                        this.savedLength = Cursor.CONTENTS.length;
                        parent.isolate(this.offset(parent), this.length()).unwrap();
                        this.savedLength = 0;
                        break;
                    }
                    parent = parent.parent;
                }
            }
            value() {
                return "";
            }
        }
        const cursor = Cursor;
        var eventemitter3 = __webpack_require__(697);
        null && EventEmitter;
        const instances = new WeakMap;
        const levels = [ "error", "warn", "log", "info" ];
        let level = "warn";
        function debug(method) {
            if (level) if (levels.indexOf(method) <= levels.indexOf(level)) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                console[method](...args);
            }
        }
        function namespace(ns) {
            return levels.reduce(((logger, method) => {
                logger[method] = debug.bind(console, method, ns);
                return logger;
            }), {});
        }
        namespace.level = newLevel => {
            level = newLevel;
        };
        debug.level = namespace.level;
        const logger = namespace;
        const emitter_debug = logger("quill:events");
        const EVENTS = [ "selectionchange", "mousedown", "mouseup", "click" ];
        EVENTS.forEach((eventName => {
            document.addEventListener(eventName, (function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                Array.from(document.querySelectorAll(".ql-container")).forEach((node => {
                    const quill = instances.get(node);
                    if (quill && quill.emitter) quill.emitter.handleDOM(...args);
                }));
            }));
        }));
        class Emitter extends eventemitter3 {
            static events={
                EDITOR_CHANGE: "editor-change",
                SCROLL_BEFORE_UPDATE: "scroll-before-update",
                SCROLL_BLOT_MOUNT: "scroll-blot-mount",
                SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
                SCROLL_OPTIMIZE: "scroll-optimize",
                SCROLL_UPDATE: "scroll-update",
                SCROLL_EMBED_UPDATE: "scroll-embed-update",
                SELECTION_CHANGE: "selection-change",
                TEXT_CHANGE: "text-change",
                COMPOSITION_BEFORE_START: "composition-before-start",
                COMPOSITION_START: "composition-start",
                COMPOSITION_BEFORE_END: "composition-before-end",
                COMPOSITION_END: "composition-end"
            };
            static sources={
                API: "api",
                SILENT: "silent",
                USER: "user"
            };
            constructor() {
                super();
                this.domListeners = {};
                this.on("error", emitter_debug.error);
            }
            emit() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                emitter_debug.log.call(emitter_debug, ...args);
                return super.emit(...args);
            }
            handleDOM(event) {
                for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
                (this.domListeners[event.type] || []).forEach((_ref => {
                    let {node, handler} = _ref;
                    if (event.target === node || node.contains(event.target)) handler(event, ...args);
                }));
            }
            listenDOM(eventName, node, handler) {
                if (!this.domListeners[eventName]) this.domListeners[eventName] = [];
                this.domListeners[eventName].push({
                    node,
                    handler
                });
            }
        }
        const core_emitter = Emitter;
        const selection_debug = logger("quill:selection");
        class Range {
            constructor(index) {
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                this.index = index;
                this.length = length;
            }
        }
        class Selection {
            constructor(scroll, emitter) {
                this.emitter = emitter;
                this.scroll = scroll;
                this.composing = false;
                this.mouseDown = false;
                this.root = this.scroll.domNode;
                this.cursor = this.scroll.create("cursor", this);
                this.savedRange = new Range(0, 0);
                this.lastRange = this.savedRange;
                this.lastNative = null;
                this.handleComposition();
                this.handleDragging();
                this.emitter.listenDOM("selectionchange", document, (() => {
                    if (!this.mouseDown && !this.composing) setTimeout(this.update.bind(this, core_emitter.sources.USER), 1);
                }));
                this.emitter.on(core_emitter.events.SCROLL_BEFORE_UPDATE, (() => {
                    if (!this.hasFocus()) return;
                    const native = this.getNativeRange();
                    if (native == null) return;
                    if (native.start.node === this.cursor.textNode) return;
                    this.emitter.once(core_emitter.events.SCROLL_UPDATE, ((source, mutations) => {
                        try {
                            if (this.root.contains(native.start.node) && this.root.contains(native.end.node)) this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                            const triggeredByTyping = mutations.some((mutation => mutation.type === "characterData" || mutation.type === "childList" || mutation.type === "attributes" && mutation.target === this.root));
                            this.update(triggeredByTyping ? core_emitter.sources.SILENT : source);
                        } catch (ignored) {}
                    }));
                }));
                this.emitter.on(core_emitter.events.SCROLL_OPTIMIZE, ((mutations, context) => {
                    if (context.range) {
                        const {startNode, startOffset, endNode, endOffset} = context.range;
                        this.setNativeRange(startNode, startOffset, endNode, endOffset);
                        this.update(core_emitter.sources.SILENT);
                    }
                }));
                this.update(core_emitter.sources.SILENT);
            }
            handleComposition() {
                this.emitter.on(core_emitter.events.COMPOSITION_BEFORE_START, (() => {
                    this.composing = true;
                }));
                this.emitter.on(core_emitter.events.COMPOSITION_END, (() => {
                    this.composing = false;
                    if (this.cursor.parent) {
                        const range = this.cursor.restore();
                        if (!range) return;
                        setTimeout((() => {
                            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                        }), 1);
                    }
                }));
            }
            handleDragging() {
                this.emitter.listenDOM("mousedown", document.body, (() => {
                    this.mouseDown = true;
                }));
                this.emitter.listenDOM("mouseup", document.body, (() => {
                    this.mouseDown = false;
                    this.update(core_emitter.sources.USER);
                }));
            }
            focus() {
                if (this.hasFocus()) return;
                this.root.focus({
                    preventScroll: true
                });
                this.setRange(this.savedRange);
            }
            format(format, value) {
                this.scroll.update();
                const nativeRange = this.getNativeRange();
                if (nativeRange == null || !nativeRange.native.collapsed || this.scroll.query(format, Scope.BLOCK)) return;
                if (nativeRange.start.node !== this.cursor.textNode) {
                    const blot = this.scroll.find(nativeRange.start.node, false);
                    if (blot == null) return;
                    if (blot instanceof LeafBlot$1) {
                        const after = blot.split(nativeRange.start.offset);
                        blot.parent.insertBefore(this.cursor, after);
                    } else blot.insertBefore(this.cursor, nativeRange.start.node);
                    this.cursor.attach();
                }
                this.cursor.format(format, value);
                this.scroll.optimize();
                this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                this.update();
            }
            getBounds(index) {
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                const scrollLength = this.scroll.length();
                index = Math.min(index, scrollLength - 1);
                length = Math.min(index + length, scrollLength - 1) - index;
                let node;
                let [leaf, offset] = this.scroll.leaf(index);
                if (leaf == null) return null;
                if (length > 0 && offset === leaf.length()) {
                    const [next] = this.scroll.leaf(index + 1);
                    if (next) {
                        const [line] = this.scroll.line(index);
                        const [nextLine] = this.scroll.line(index + 1);
                        if (line === nextLine) {
                            leaf = next;
                            offset = 0;
                        }
                    }
                }
                [node, offset] = leaf.position(offset, true);
                const range = document.createRange();
                if (length > 0) {
                    range.setStart(node, offset);
                    [leaf, offset] = this.scroll.leaf(index + length);
                    if (leaf == null) return null;
                    [node, offset] = leaf.position(offset, true);
                    range.setEnd(node, offset);
                    return range.getBoundingClientRect();
                }
                let side = "left";
                let rect;
                if (node instanceof Text) {
                    if (!node.data.length) return null;
                    if (offset < node.data.length) {
                        range.setStart(node, offset);
                        range.setEnd(node, offset + 1);
                    } else {
                        range.setStart(node, offset - 1);
                        range.setEnd(node, offset);
                        side = "right";
                    }
                    rect = range.getBoundingClientRect();
                } else {
                    if (!(leaf.domNode instanceof Element)) return null;
                    rect = leaf.domNode.getBoundingClientRect();
                    if (offset > 0) side = "right";
                }
                return {
                    bottom: rect.top + rect.height,
                    height: rect.height,
                    left: rect[side],
                    right: rect[side],
                    top: rect.top,
                    width: 0
                };
            }
            getNativeRange() {
                const selection = document.getSelection();
                if (selection == null || selection.rangeCount <= 0) return null;
                const nativeRange = selection.getRangeAt(0);
                if (nativeRange == null) return null;
                const range = this.normalizeNative(nativeRange);
                selection_debug.info("getNativeRange", range);
                return range;
            }
            getRange() {
                const root = this.scroll.domNode;
                if ("isConnected" in root && !root.isConnected) return [ null, null ];
                const normalized = this.getNativeRange();
                if (normalized == null) return [ null, null ];
                const range = this.normalizedToRange(normalized);
                return [ range, normalized ];
            }
            hasFocus() {
                return document.activeElement === this.root || document.activeElement != null && contains(this.root, document.activeElement);
            }
            normalizedToRange(range) {
                const positions = [ [ range.start.node, range.start.offset ] ];
                if (!range.native.collapsed) positions.push([ range.end.node, range.end.offset ]);
                const indexes = positions.map((position => {
                    const [node, offset] = position;
                    const blot = this.scroll.find(node, true);
                    const index = blot.offset(this.scroll);
                    if (offset === 0) return index;
                    if (blot instanceof LeafBlot$1) return index + blot.index(node, offset);
                    return index + blot.length();
                }));
                const end = Math.min(Math.max(...indexes), this.scroll.length() - 1);
                const start = Math.min(end, ...indexes);
                return new Range(start, end - start);
            }
            normalizeNative(nativeRange) {
                if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) return null;
                const range = {
                    start: {
                        node: nativeRange.startContainer,
                        offset: nativeRange.startOffset
                    },
                    end: {
                        node: nativeRange.endContainer,
                        offset: nativeRange.endOffset
                    },
                    native: nativeRange
                };
                [ range.start, range.end ].forEach((position => {
                    let {node, offset} = position;
                    while (!(node instanceof Text) && node.childNodes.length > 0) if (node.childNodes.length > offset) {
                        node = node.childNodes[offset];
                        offset = 0;
                    } else if (node.childNodes.length === offset) {
                        node = node.lastChild;
                        if (node instanceof Text) offset = node.data.length; else if (node.childNodes.length > 0) offset = node.childNodes.length; else offset = node.childNodes.length + 1;
                    } else break;
                    position.node = node;
                    position.offset = offset;
                }));
                return range;
            }
            rangeToNative(range) {
                const scrollLength = this.scroll.length();
                const getPosition = (index, inclusive) => {
                    index = Math.min(scrollLength - 1, index);
                    const [leaf, leafOffset] = this.scroll.leaf(index);
                    return leaf ? leaf.position(leafOffset, inclusive) : [ null, -1 ];
                };
                return [ ...getPosition(range.index, false), ...getPosition(range.index + range.length, true) ];
            }
            setNativeRange(startNode, startOffset) {
                let endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
                let endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
                let force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                selection_debug.info("setNativeRange", startNode, startOffset, endNode, endOffset);
                if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) return;
                const selection = document.getSelection();
                if (selection == null) return;
                if (startNode != null) {
                    if (!this.hasFocus()) this.root.focus({
                        preventScroll: true
                    });
                    const {native} = this.getNativeRange() || {};
                    if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                        if (startNode instanceof Element && startNode.tagName === "BR") {
                            startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);
                            startNode = startNode.parentNode;
                        }
                        if (endNode instanceof Element && endNode.tagName === "BR") {
                            endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);
                            endNode = endNode.parentNode;
                        }
                        const range = document.createRange();
                        range.setStart(startNode, startOffset);
                        range.setEnd(endNode, endOffset);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                } else {
                    selection.removeAllRanges();
                    this.root.blur();
                }
            }
            setRange(range) {
                let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : core_emitter.sources.API;
                if (typeof force === "string") {
                    source = force;
                    force = false;
                }
                selection_debug.info("setRange", range);
                if (range != null) {
                    const args = this.rangeToNative(range);
                    this.setNativeRange(...args, force);
                } else this.setNativeRange(null);
                this.update(source);
            }
            update() {
                let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : core_emitter.sources.USER;
                const oldRange = this.lastRange;
                const [lastRange, nativeRange] = this.getRange();
                this.lastRange = lastRange;
                this.lastNative = nativeRange;
                if (this.lastRange != null) this.savedRange = this.lastRange;
                if (!lodash_es_isEqual(oldRange, this.lastRange)) {
                    if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                        const range = this.cursor.restore();
                        if (range) this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                    }
                    const args = [ core_emitter.events.SELECTION_CHANGE, lodash_es_cloneDeep(this.lastRange), lodash_es_cloneDeep(oldRange), source ];
                    this.emitter.emit(core_emitter.events.EDITOR_CHANGE, ...args);
                    if (source !== core_emitter.sources.SILENT) this.emitter.emit(...args);
                }
            }
        }
        function contains(parent, descendant) {
            try {
                descendant.parentNode;
            } catch (e) {
                return false;
            }
            return parent.contains(descendant);
        }
        const selection = Selection;
        const ASCII = /^[ -~]*$/;
        class Editor {
            constructor(scroll) {
                this.scroll = scroll;
                this.delta = this.getDelta();
            }
            applyDelta(delta) {
                this.scroll.update();
                let scrollLength = this.scroll.length();
                this.scroll.batchStart();
                const normalizedDelta = normalizeDelta(delta);
                const deleteDelta = new Delta;
                const normalizedOps = splitOpLines(normalizedDelta.ops.slice());
                normalizedOps.reduce(((index, op) => {
                    const length = Delta.Op.length(op);
                    let attributes = op.attributes || {};
                    let isImplicitNewlinePrepended = false;
                    let isImplicitNewlineAppended = false;
                    if (op.insert != null) {
                        deleteDelta.retain(length);
                        if (typeof op.insert === "string") {
                            const text = op.insert;
                            isImplicitNewlineAppended = !text.endsWith("\n") && (scrollLength <= index || !!this.scroll.descendant(BlockEmbed, index)[0]);
                            this.scroll.insertAt(index, text);
                            const [line, offset] = this.scroll.line(index);
                            let formats = lodash_es_merge({}, bubbleFormats(line));
                            if (line instanceof Block) {
                                const [leaf] = line.descendant(LeafBlot$1, offset);
                                if (leaf) formats = lodash_es_merge(formats, bubbleFormats(leaf));
                            }
                            attributes = Delta.AttributeMap.diff(formats, attributes) || {};
                        } else if (typeof op.insert === "object") {
                            const key = Object.keys(op.insert)[0];
                            if (key == null) return index;
                            const isInlineEmbed = this.scroll.query(key, Scope.INLINE) != null;
                            if (isInlineEmbed) {
                                if (scrollLength <= index || !!this.scroll.descendant(BlockEmbed, index)[0]) isImplicitNewlineAppended = true;
                            } else if (index > 0) {
                                const [leaf, offset] = this.scroll.descendant(LeafBlot$1, index - 1);
                                if (leaf instanceof text_Text) {
                                    const text = leaf.value();
                                    if (text[offset] !== "\n") isImplicitNewlinePrepended = true;
                                } else if (leaf instanceof EmbedBlot$1 && leaf.statics.scope === Scope.INLINE_BLOT) isImplicitNewlinePrepended = true;
                            }
                            this.scroll.insertAt(index, key, op.insert[key]);
                            if (isInlineEmbed) {
                                const [leaf] = this.scroll.descendant(LeafBlot$1, index);
                                if (leaf) {
                                    const formats = lodash_es_merge({}, bubbleFormats(leaf));
                                    attributes = Delta.AttributeMap.diff(formats, attributes) || {};
                                }
                            }
                        }
                        scrollLength += length;
                    } else {
                        deleteDelta.push(op);
                        if (op.retain !== null && typeof op.retain === "object") {
                            const key = Object.keys(op.retain)[0];
                            if (key == null) return index;
                            this.scroll.updateEmbedAt(index, key, op.retain[key]);
                        }
                    }
                    Object.keys(attributes).forEach((name => {
                        this.scroll.formatAt(index, length, name, attributes[name]);
                    }));
                    const prependedLength = isImplicitNewlinePrepended ? 1 : 0;
                    const addedLength = isImplicitNewlineAppended ? 1 : 0;
                    scrollLength += prependedLength + addedLength;
                    deleteDelta.retain(prependedLength);
                    deleteDelta.delete(addedLength);
                    return index + length + prependedLength + addedLength;
                }), 0);
                deleteDelta.reduce(((index, op) => {
                    if (typeof op.delete === "number") {
                        this.scroll.deleteAt(index, op.delete);
                        return index;
                    }
                    return index + Delta.Op.length(op);
                }), 0);
                this.scroll.batchEnd();
                this.scroll.optimize();
                return this.update(normalizedDelta);
            }
            deleteText(index, length) {
                this.scroll.deleteAt(index, length);
                return this.update((new Delta).retain(index).delete(length));
            }
            formatLine(index, length) {
                let formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                this.scroll.update();
                Object.keys(formats).forEach((format => {
                    this.scroll.lines(index, Math.max(length, 1)).forEach((line => {
                        line.format(format, formats[format]);
                    }));
                }));
                this.scroll.optimize();
                const delta = (new Delta).retain(index).retain(length, lodash_es_cloneDeep(formats));
                return this.update(delta);
            }
            formatText(index, length) {
                let formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                Object.keys(formats).forEach((format => {
                    this.scroll.formatAt(index, length, format, formats[format]);
                }));
                const delta = (new Delta).retain(index).retain(length, lodash_es_cloneDeep(formats));
                return this.update(delta);
            }
            getContents(index, length) {
                return this.delta.slice(index, index + length);
            }
            getDelta() {
                return this.scroll.lines().reduce(((delta, line) => delta.concat(line.delta())), new Delta);
            }
            getFormat(index) {
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                let lines = [];
                let leaves = [];
                if (length === 0) this.scroll.path(index).forEach((path => {
                    const [blot] = path;
                    if (blot instanceof Block) lines.push(blot); else if (blot instanceof LeafBlot$1) leaves.push(blot);
                })); else {
                    lines = this.scroll.lines(index, length);
                    leaves = this.scroll.descendants(LeafBlot$1, index, length);
                }
                const [lineFormats, leafFormats] = [ lines, leaves ].map((blots => {
                    const blot = blots.shift();
                    if (blot == null) return {};
                    let formats = bubbleFormats(blot);
                    while (Object.keys(formats).length > 0) {
                        const blot = blots.shift();
                        if (blot == null) return formats;
                        formats = combineFormats(bubbleFormats(blot), formats);
                    }
                    return formats;
                }));
                return {
                    ...lineFormats,
                    ...leafFormats
                };
            }
            getHTML(index, length) {
                const [line, lineOffset] = this.scroll.line(index);
                if (line) {
                    const lineLength = line.length();
                    const isWithinLine = line.length() >= lineOffset + length;
                    if (isWithinLine && !(lineOffset === 0 && length === lineLength)) return convertHTML(line, lineOffset, length, true);
                    return convertHTML(this.scroll, index, length, true);
                }
                return "";
            }
            getText(index, length) {
                return this.getContents(index, length).filter((op => typeof op.insert === "string")).map((op => op.insert)).join("");
            }
            insertContents(index, contents) {
                const normalizedDelta = normalizeDelta(contents);
                const change = (new Delta).retain(index).concat(normalizedDelta);
                this.scroll.insertContents(index, normalizedDelta);
                return this.update(change);
            }
            insertEmbed(index, embed, value) {
                this.scroll.insertAt(index, embed, value);
                return this.update((new Delta).retain(index).insert({
                    [embed]: value
                }));
            }
            insertText(index, text) {
                let formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                this.scroll.insertAt(index, text);
                Object.keys(formats).forEach((format => {
                    this.scroll.formatAt(index, text.length, format, formats[format]);
                }));
                return this.update((new Delta).retain(index).insert(text, lodash_es_cloneDeep(formats)));
            }
            isBlank() {
                if (this.scroll.children.length === 0) return true;
                if (this.scroll.children.length > 1) return false;
                const blot = this.scroll.children.head;
                if (blot?.statics.blotName !== Block.blotName) return false;
                const block = blot;
                if (block.children.length > 1) return false;
                return block.children.head instanceof blots_break;
            }
            removeFormat(index, length) {
                const text = this.getText(index, length);
                const [line, offset] = this.scroll.line(index + length);
                let suffixLength = 0;
                let suffix = new Delta;
                if (line != null) {
                    suffixLength = line.length() - offset;
                    suffix = line.delta().slice(offset, offset + suffixLength - 1).insert("\n");
                }
                const contents = this.getContents(index, length + suffixLength);
                const diff = contents.diff((new Delta).insert(text).concat(suffix));
                const delta = (new Delta).retain(index).concat(diff);
                return this.applyDelta(delta);
            }
            update(change) {
                let mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                let selectionInfo = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                const oldDelta = this.delta;
                if (mutations.length === 1 && mutations[0].type === "characterData" && mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {
                    const textBlot = this.scroll.find(mutations[0].target);
                    const formats = bubbleFormats(textBlot);
                    const index = textBlot.offset(this.scroll);
                    const oldValue = mutations[0].oldValue.replace(cursor.CONTENTS, "");
                    const oldText = (new Delta).insert(oldValue);
                    const newText = (new Delta).insert(textBlot.value());
                    const relativeSelectionInfo = selectionInfo && {
                        oldRange: shiftRange(selectionInfo.oldRange, -index),
                        newRange: shiftRange(selectionInfo.newRange, -index)
                    };
                    const diffDelta = (new Delta).retain(index).concat(oldText.diff(newText, relativeSelectionInfo));
                    change = diffDelta.reduce(((delta, op) => {
                        if (op.insert) return delta.insert(op.insert, formats);
                        return delta.push(op);
                    }), new Delta);
                    this.delta = oldDelta.compose(change);
                } else {
                    this.delta = this.getDelta();
                    if (!change || !lodash_es_isEqual(oldDelta.compose(change), this.delta)) change = oldDelta.diff(this.delta, selectionInfo);
                }
                return change;
            }
        }
        function convertListHTML(items, lastIndent, types) {
            if (items.length === 0) {
                const [endTag] = getListType(types.pop());
                if (lastIndent <= 0) return `</li></${endTag}>`;
                return `</li></${endTag}>${convertListHTML([], lastIndent - 1, types)}`;
            }
            const [{child, offset, length, indent, type}, ...rest] = items;
            const [tag, attribute] = getListType(type);
            if (indent > lastIndent) {
                types.push(type);
                if (indent === lastIndent + 1) return `<${tag}><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
                return `<${tag}><li>${convertListHTML(items, lastIndent + 1, types)}`;
            }
            const previousType = types[types.length - 1];
            if (indent === lastIndent && type === previousType) return `</li><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
            const [endTag] = getListType(types.pop());
            return `</li></${endTag}>${convertListHTML(items, lastIndent - 1, types)}`;
        }
        function convertHTML(blot, index, length) {
            let isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            if ("html" in blot && typeof blot.html === "function") return blot.html(index, length);
            if (blot instanceof text_Text) return escapeText(blot.value().slice(index, index + length));
            if (blot instanceof ParentBlot$1) {
                if (blot.statics.blotName === "list-container") {
                    const items = [];
                    blot.children.forEachAt(index, length, ((child, offset, childLength) => {
                        const formats = "formats" in child && typeof child.formats === "function" ? child.formats() : {};
                        items.push({
                            child,
                            offset,
                            length: childLength,
                            indent: formats.indent || 0,
                            type: formats.list
                        });
                    }));
                    return convertListHTML(items, -1, []);
                }
                const parts = [];
                blot.children.forEachAt(index, length, ((child, offset, childLength) => {
                    parts.push(convertHTML(child, offset, childLength));
                }));
                if (isRoot || blot.statics.blotName === "list") return parts.join("");
                const {outerHTML, innerHTML} = blot.domNode;
                const [start, end] = outerHTML.split(`>${innerHTML}<`);
                if (start === "<table") return `<table style="border: 1px solid #000;">${parts.join("")}<${end}`;
                return `${start}>${parts.join("")}<${end}`;
            }
            return blot.domNode instanceof Element ? blot.domNode.outerHTML : "";
        }
        function combineFormats(formats, combined) {
            return Object.keys(combined).reduce(((merged, name) => {
                if (formats[name] == null) return merged;
                const combinedValue = combined[name];
                if (combinedValue === formats[name]) merged[name] = combinedValue; else if (Array.isArray(combinedValue)) if (combinedValue.indexOf(formats[name]) < 0) merged[name] = combinedValue.concat([ formats[name] ]); else merged[name] = combinedValue; else merged[name] = [ combinedValue, formats[name] ];
                return merged;
            }), {});
        }
        function getListType(type) {
            const tag = type === "ordered" ? "ol" : "ul";
            switch (type) {
              case "checked":
                return [ tag, ' data-list="checked"' ];

              case "unchecked":
                return [ tag, ' data-list="unchecked"' ];

              default:
                return [ tag, "" ];
            }
        }
        function normalizeDelta(delta) {
            return delta.reduce(((normalizedDelta, op) => {
                if (typeof op.insert === "string") {
                    const text = op.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                    return normalizedDelta.insert(text, op.attributes);
                }
                return normalizedDelta.push(op);
            }), new Delta);
        }
        function shiftRange(_ref, amount) {
            let {index, length} = _ref;
            return new Range(index + amount, length);
        }
        function splitOpLines(ops) {
            const split = [];
            ops.forEach((op => {
                if (typeof op.insert === "string") {
                    const lines = op.insert.split("\n");
                    lines.forEach(((line, index) => {
                        if (index) split.push({
                            insert: "\n",
                            attributes: op.attributes
                        });
                        if (line) split.push({
                            insert: line,
                            attributes: op.attributes
                        });
                    }));
                } else split.push(op);
            }));
            return split;
        }
        const editor = Editor;
        class Module {
            static DEFAULTS={};
            constructor(quill) {
                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                this.quill = quill;
                this.options = options;
            }
        }
        const core_module = Module;
        const GUARD_TEXT = "\ufeff";
        class Embed extends EmbedBlot$1 {
            constructor(scroll, node) {
                super(scroll, node);
                this.contentNode = document.createElement("span");
                this.contentNode.setAttribute("contenteditable", "false");
                Array.from(this.domNode.childNodes).forEach((childNode => {
                    this.contentNode.appendChild(childNode);
                }));
                this.leftGuard = document.createTextNode(GUARD_TEXT);
                this.rightGuard = document.createTextNode(GUARD_TEXT);
                this.domNode.appendChild(this.leftGuard);
                this.domNode.appendChild(this.contentNode);
                this.domNode.appendChild(this.rightGuard);
            }
            index(node, offset) {
                if (node === this.leftGuard) return 0;
                if (node === this.rightGuard) return 1;
                return super.index(node, offset);
            }
            restore(node) {
                let range = null;
                let textNode;
                const text = node.data.split(GUARD_TEXT).join("");
                if (node === this.leftGuard) if (this.prev instanceof text_Text) {
                    const prevLength = this.prev.length();
                    this.prev.insertAt(prevLength, text);
                    range = {
                        startNode: this.prev.domNode,
                        startOffset: prevLength + text.length
                    };
                } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(this.scroll.create(textNode), this);
                    range = {
                        startNode: textNode,
                        startOffset: text.length
                    };
                } else if (node === this.rightGuard) if (this.next instanceof text_Text) {
                    this.next.insertAt(0, text);
                    range = {
                        startNode: this.next.domNode,
                        startOffset: text.length
                    };
                } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(this.scroll.create(textNode), this.next);
                    range = {
                        startNode: textNode,
                        startOffset: text.length
                    };
                }
                node.data = GUARD_TEXT;
                return range;
            }
            update(mutations, context) {
                mutations.forEach((mutation => {
                    if (mutation.type === "characterData" && (mutation.target === this.leftGuard || mutation.target === this.rightGuard)) {
                        const range = this.restore(mutation.target);
                        if (range) context.range = range;
                    }
                }));
            }
        }
        const blots_embed = Embed;
        class Composition {
            isComposing=false;
            constructor(scroll, emitter) {
                this.scroll = scroll;
                this.emitter = emitter;
                this.setupListeners();
            }
            setupListeners() {
                this.scroll.domNode.addEventListener("compositionstart", (event => {
                    if (!this.isComposing) this.handleCompositionStart(event);
                }));
                this.scroll.domNode.addEventListener("compositionend", (event => {
                    if (this.isComposing) queueMicrotask((() => {
                        this.handleCompositionEnd(event);
                    }));
                }));
            }
            handleCompositionStart(event) {
                const blot = event.target instanceof Node ? this.scroll.find(event.target, true) : null;
                if (blot && !(blot instanceof blots_embed)) {
                    this.emitter.emit(core_emitter.events.COMPOSITION_BEFORE_START, event);
                    this.scroll.batchStart();
                    this.emitter.emit(core_emitter.events.COMPOSITION_START, event);
                    this.isComposing = true;
                }
            }
            handleCompositionEnd(event) {
                this.emitter.emit(core_emitter.events.COMPOSITION_BEFORE_END, event);
                this.scroll.batchEnd();
                this.emitter.emit(core_emitter.events.COMPOSITION_END, event);
                this.isComposing = false;
            }
        }
        const composition = Composition;
        class Theme {
            static DEFAULTS={
                modules: {}
            };
            static themes={
                default: Theme
            };
            modules={};
            constructor(quill, options) {
                this.quill = quill;
                this.options = options;
            }
            init() {
                Object.keys(this.options.modules).forEach((name => {
                    if (this.modules[name] == null) this.addModule(name);
                }));
            }
            addModule(name) {
                const ModuleClass = this.quill.constructor.import(`modules/${name}`);
                this.modules[name] = new ModuleClass(this.quill, this.options.modules[name] || {});
                return this.modules[name];
            }
        }
        const core_theme = Theme;
        const getParentElement = element => element.parentElement || element.getRootNode().host || null;
        const getElementRect = element => {
            const rect = element.getBoundingClientRect();
            const scaleX = "offsetWidth" in element && Math.abs(rect.width) / element.offsetWidth || 1;
            const scaleY = "offsetHeight" in element && Math.abs(rect.height) / element.offsetHeight || 1;
            return {
                top: rect.top,
                right: rect.left + element.clientWidth * scaleX,
                bottom: rect.top + element.clientHeight * scaleY,
                left: rect.left
            };
        };
        const paddingValueToInt = value => {
            const number = parseInt(value, 10);
            return Number.isNaN(number) ? 0 : number;
        };
        const getScrollDistance = (targetStart, targetEnd, scrollStart, scrollEnd, scrollPaddingStart, scrollPaddingEnd) => {
            if (targetStart < scrollStart && targetEnd > scrollEnd) return 0;
            if (targetStart < scrollStart) return -(scrollStart - targetStart + scrollPaddingStart);
            if (targetEnd > scrollEnd) return targetEnd - targetStart > scrollEnd - scrollStart ? targetStart + scrollPaddingStart - scrollStart : targetEnd - scrollEnd + scrollPaddingEnd;
            return 0;
        };
        const scrollRectIntoView = (root, targetRect) => {
            const document = root.ownerDocument;
            let rect = targetRect;
            let current = root;
            while (current) {
                const isDocumentBody = current === document.body;
                const bounding = isDocumentBody ? {
                    top: 0,
                    right: window.visualViewport?.width ?? document.documentElement.clientWidth,
                    bottom: window.visualViewport?.height ?? document.documentElement.clientHeight,
                    left: 0
                } : getElementRect(current);
                const style = getComputedStyle(current);
                const scrollDistanceX = getScrollDistance(rect.left, rect.right, bounding.left, bounding.right, paddingValueToInt(style.scrollPaddingLeft), paddingValueToInt(style.scrollPaddingRight));
                const scrollDistanceY = getScrollDistance(rect.top, rect.bottom, bounding.top, bounding.bottom, paddingValueToInt(style.scrollPaddingTop), paddingValueToInt(style.scrollPaddingBottom));
                if (scrollDistanceX || scrollDistanceY) if (isDocumentBody) document.defaultView?.scrollBy(scrollDistanceX, scrollDistanceY); else {
                    const {scrollLeft, scrollTop} = current;
                    if (scrollDistanceY) current.scrollTop += scrollDistanceY;
                    if (scrollDistanceX) current.scrollLeft += scrollDistanceX;
                    const scrolledLeft = current.scrollLeft - scrollLeft;
                    const scrolledTop = current.scrollTop - scrollTop;
                    rect = {
                        left: rect.left - scrolledLeft,
                        top: rect.top - scrolledTop,
                        right: rect.right - scrolledLeft,
                        bottom: rect.bottom - scrolledTop
                    };
                }
                current = isDocumentBody || style.position === "fixed" ? null : getParentElement(current);
            }
        };
        const utils_scrollRectIntoView = scrollRectIntoView;
        const MAX_REGISTER_ITERATIONS = 100;
        const CORE_FORMATS = [ "block", "break", "cursor", "inline", "scroll", "text" ];
        const createRegistryWithFormats = (formats, sourceRegistry, debug) => {
            const registry = new Registry;
            CORE_FORMATS.forEach((name => {
                const coreBlot = sourceRegistry.query(name);
                if (coreBlot) registry.register(coreBlot);
            }));
            formats.forEach((name => {
                let format = sourceRegistry.query(name);
                if (!format) debug.error(`Cannot register "${name}" specified in "formats" config. Are you sure it was registered?`);
                let iterations = 0;
                while (format) {
                    registry.register(format);
                    format = "blotName" in format ? format.requiredContainer ?? null : null;
                    iterations += 1;
                    if (iterations > MAX_REGISTER_ITERATIONS) {
                        debug.error(`Cycle detected in registering blot requiredContainer: "${name}"`);
                        break;
                    }
                }
            }));
            return registry;
        };
        const utils_createRegistryWithFormats = createRegistryWithFormats;
        const quill_debug = logger("quill");
        const globalRegistry = new Registry;
        ParentBlot$1.uiClass = "ql-ui";
        class Quill {
            static DEFAULTS={
                bounds: null,
                modules: {
                    clipboard: true,
                    keyboard: true,
                    history: true,
                    uploader: true
                },
                placeholder: "",
                readOnly: false,
                registry: globalRegistry,
                theme: "default"
            };
            static events=core_emitter.events;
            static sources=core_emitter.sources;
            static version=false ? 0 : "2.0.2";
            static imports={
                delta: Delta,
                parchment: parchment_namespaceObject,
                "core/module": core_module,
                "core/theme": core_theme
            };
            static debug(limit) {
                if (limit === true) limit = "log";
                logger.level(limit);
            }
            static find(node) {
                let bubble = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                return instances.get(node) || globalRegistry.find(node, bubble);
            }
            static import(name) {
                if (this.imports[name] == null) quill_debug.error(`Cannot import ${name}. Are you sure it was registered?`);
                return this.imports[name];
            }
            static register() {
                if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) !== "string") {
                    const target = arguments.length <= 0 ? void 0 : arguments[0];
                    const overwrite = !!(arguments.length <= 1 ? void 0 : arguments[1]);
                    const name = "attrName" in target ? target.attrName : target.blotName;
                    if (typeof name === "string") this.register(`formats/${name}`, target, overwrite); else Object.keys(target).forEach((key => {
                        this.register(key, target[key], overwrite);
                    }));
                } else {
                    const path = arguments.length <= 0 ? void 0 : arguments[0];
                    const target = arguments.length <= 1 ? void 0 : arguments[1];
                    const overwrite = !!(arguments.length <= 2 ? void 0 : arguments[2]);
                    if (this.imports[path] != null && !overwrite) quill_debug.warn(`Overwriting ${path} with`, target);
                    this.imports[path] = target;
                    if ((path.startsWith("blots/") || path.startsWith("formats/")) && target && typeof target !== "boolean" && target.blotName !== "abstract") globalRegistry.register(target);
                    if (typeof target.register === "function") target.register(globalRegistry);
                }
            }
            constructor(container) {
                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                this.options = expandConfig(container, options);
                this.container = this.options.container;
                if (this.container == null) {
                    quill_debug.error("Invalid Quill container", container);
                    return;
                }
                if (this.options.debug) Quill.debug(this.options.debug);
                const html = this.container.innerHTML.trim();
                this.container.classList.add("ql-container");
                this.container.innerHTML = "";
                instances.set(this.container, this);
                this.root = this.addContainer("ql-editor");
                this.root.classList.add("ql-blank");
                this.emitter = new core_emitter;
                const scrollBlotName = ScrollBlot$1.blotName;
                const ScrollBlot = this.options.registry.query(scrollBlotName);
                if (!ScrollBlot || !("blotName" in ScrollBlot)) throw new Error(`Cannot initialize Quill without "${scrollBlotName}" blot`);
                this.scroll = new ScrollBlot(this.options.registry, this.root, {
                    emitter: this.emitter
                });
                this.editor = new editor(this.scroll);
                this.selection = new selection(this.scroll, this.emitter);
                this.composition = new composition(this.scroll, this.emitter);
                this.theme = new this.options.theme(this, this.options);
                this.keyboard = this.theme.addModule("keyboard");
                this.clipboard = this.theme.addModule("clipboard");
                this.history = this.theme.addModule("history");
                this.uploader = this.theme.addModule("uploader");
                this.theme.addModule("input");
                this.theme.addModule("uiNode");
                this.theme.init();
                this.emitter.on(core_emitter.events.EDITOR_CHANGE, (type => {
                    if (type === core_emitter.events.TEXT_CHANGE) this.root.classList.toggle("ql-blank", this.editor.isBlank());
                }));
                this.emitter.on(core_emitter.events.SCROLL_UPDATE, ((source, mutations) => {
                    const oldRange = this.selection.lastRange;
                    const [newRange] = this.selection.getRange();
                    const selectionInfo = oldRange && newRange ? {
                        oldRange,
                        newRange
                    } : void 0;
                    modify.call(this, (() => this.editor.update(null, mutations, selectionInfo)), source);
                }));
                this.emitter.on(core_emitter.events.SCROLL_EMBED_UPDATE, ((blot, delta) => {
                    const oldRange = this.selection.lastRange;
                    const [newRange] = this.selection.getRange();
                    const selectionInfo = oldRange && newRange ? {
                        oldRange,
                        newRange
                    } : void 0;
                    modify.call(this, (() => {
                        const change = (new Delta).retain(blot.offset(this)).retain({
                            [blot.statics.blotName]: delta
                        });
                        return this.editor.update(change, [], selectionInfo);
                    }), Quill.sources.USER);
                }));
                if (html) {
                    const contents = this.clipboard.convert({
                        html: `${html}<p><br></p>`,
                        text: "\n"
                    });
                    this.setContents(contents);
                }
                this.history.clear();
                if (this.options.placeholder) this.root.setAttribute("data-placeholder", this.options.placeholder);
                if (this.options.readOnly) this.disable();
                this.allowReadOnlyEdits = false;
            }
            addContainer(container) {
                let refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                if (typeof container === "string") {
                    const className = container;
                    container = document.createElement("div");
                    container.classList.add(className);
                }
                this.container.insertBefore(container, refNode);
                return container;
            }
            blur() {
                this.selection.setRange(null);
            }
            deleteText(index, length, source) {
                [index, length, , source] = overload(index, length, source);
                return modify.call(this, (() => this.editor.deleteText(index, length)), source, index, -1 * length);
            }
            disable() {
                this.enable(false);
            }
            editReadOnly(modifier) {
                this.allowReadOnlyEdits = true;
                const value = modifier();
                this.allowReadOnlyEdits = false;
                return value;
            }
            enable() {
                let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.scroll.enable(enabled);
                this.container.classList.toggle("ql-disabled", !enabled);
            }
            focus() {
                let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.selection.focus();
                if (!options.preventScroll) this.scrollSelectionIntoView();
            }
            format(name, value) {
                let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : core_emitter.sources.API;
                return modify.call(this, (() => {
                    const range = this.getSelection(true);
                    let change = new Delta;
                    if (range == null) return change;
                    if (this.scroll.query(name, Scope.BLOCK)) change = this.editor.formatLine(range.index, range.length, {
                        [name]: value
                    }); else if (range.length === 0) {
                        this.selection.format(name, value);
                        return change;
                    } else change = this.editor.formatText(range.index, range.length, {
                        [name]: value
                    });
                    this.setSelection(range, core_emitter.sources.SILENT);
                    return change;
                }), source);
            }
            formatLine(index, length, name, value, source) {
                let formats;
                [index, length, formats, source] = overload(index, length, name, value, source);
                return modify.call(this, (() => this.editor.formatLine(index, length, formats)), source, index, 0);
            }
            formatText(index, length, name, value, source) {
                let formats;
                [index, length, formats, source] = overload(index, length, name, value, source);
                return modify.call(this, (() => this.editor.formatText(index, length, formats)), source, index, 0);
            }
            getBounds(index) {
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                let bounds = null;
                if (typeof index === "number") bounds = this.selection.getBounds(index, length); else bounds = this.selection.getBounds(index.index, index.length);
                if (!bounds) return null;
                const containerBounds = this.container.getBoundingClientRect();
                return {
                    bottom: bounds.bottom - containerBounds.top,
                    height: bounds.height,
                    left: bounds.left - containerBounds.left,
                    right: bounds.right - containerBounds.left,
                    top: bounds.top - containerBounds.top,
                    width: bounds.width
                };
            }
            getContents() {
                let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index;
                [index, length] = overload(index, length);
                return this.editor.getContents(index, length);
            }
            getFormat() {
                let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                if (typeof index === "number") return this.editor.getFormat(index, length);
                return this.editor.getFormat(index.index, index.length);
            }
            getIndex(blot) {
                return blot.offset(this.scroll);
            }
            getLength() {
                return this.scroll.length();
            }
            getLeaf(index) {
                return this.scroll.leaf(index);
            }
            getLine(index) {
                return this.scroll.line(index);
            }
            getLines() {
                let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                if (typeof index !== "number") return this.scroll.lines(index.index, index.length);
                return this.scroll.lines(index, length);
            }
            getModule(name) {
                return this.theme.modules[name];
            }
            getSelection() {
                let focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                if (focus) this.focus();
                this.update();
                return this.selection.getRange()[0];
            }
            getSemanticHTML() {
                let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                let length = arguments.length > 1 ? arguments[1] : void 0;
                if (typeof index === "number") length = length ?? this.getLength() - index;
                [index, length] = overload(index, length);
                return this.editor.getHTML(index, length);
            }
            getText() {
                let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                let length = arguments.length > 1 ? arguments[1] : void 0;
                if (typeof index === "number") length = length ?? this.getLength() - index;
                [index, length] = overload(index, length);
                return this.editor.getText(index, length);
            }
            hasFocus() {
                return this.selection.hasFocus();
            }
            insertEmbed(index, embed, value) {
                let source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Quill.sources.API;
                return modify.call(this, (() => this.editor.insertEmbed(index, embed, value)), source, index);
            }
            insertText(index, text, name, value, source) {
                let formats;
                [index, , formats, source] = overload(index, 0, name, value, source);
                return modify.call(this, (() => this.editor.insertText(index, text, formats)), source, index, text.length);
            }
            isEnabled() {
                return this.scroll.isEnabled();
            }
            off() {
                return this.emitter.off(...arguments);
            }
            on() {
                return this.emitter.on(...arguments);
            }
            once() {
                return this.emitter.once(...arguments);
            }
            removeFormat(index, length, source) {
                [index, length, , source] = overload(index, length, source);
                return modify.call(this, (() => this.editor.removeFormat(index, length)), source, index);
            }
            scrollRectIntoView(rect) {
                utils_scrollRectIntoView(this.root, rect);
            }
            scrollIntoView() {
                console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead.");
                this.scrollSelectionIntoView();
            }
            scrollSelectionIntoView() {
                const range = this.selection.lastRange;
                const bounds = range && this.selection.getBounds(range.index, range.length);
                if (bounds) this.scrollRectIntoView(bounds);
            }
            setContents(delta) {
                let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : core_emitter.sources.API;
                return modify.call(this, (() => {
                    delta = new Delta(delta);
                    const length = this.getLength();
                    const delete1 = this.editor.deleteText(0, length);
                    const applied = this.editor.insertContents(0, delta);
                    const delete2 = this.editor.deleteText(this.getLength() - 1, 1);
                    return delete1.compose(applied).compose(delete2);
                }), source);
            }
            setSelection(index, length, source) {
                if (index == null) this.selection.setRange(null, length || Quill.sources.API); else {
                    [index, length, , source] = overload(index, length, source);
                    this.selection.setRange(new Range(Math.max(0, index), length), source);
                    if (source !== core_emitter.sources.SILENT) this.scrollSelectionIntoView();
                }
            }
            setText(text) {
                let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : core_emitter.sources.API;
                const delta = (new Delta).insert(text);
                return this.setContents(delta, source);
            }
            update() {
                let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : core_emitter.sources.USER;
                const change = this.scroll.update(source);
                this.selection.update(source);
                return change;
            }
            updateContents(delta) {
                let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : core_emitter.sources.API;
                return modify.call(this, (() => {
                    delta = new Delta(delta);
                    return this.editor.applyDelta(delta);
                }), source, true);
            }
        }
        function resolveSelector(selector) {
            return typeof selector === "string" ? document.querySelector(selector) : selector;
        }
        function expandModuleConfig(config) {
            return Object.entries(config ?? {}).reduce(((expanded, _ref) => {
                let [key, value] = _ref;
                return {
                    ...expanded,
                    [key]: value === true ? {} : value
                };
            }), {});
        }
        function omitUndefinedValuesFromOptions(obj) {
            return Object.fromEntries(Object.entries(obj).filter((entry => entry[1] !== void 0)));
        }
        function expandConfig(containerOrSelector, options) {
            const container = resolveSelector(containerOrSelector);
            if (!container) throw new Error("Invalid Quill container");
            const shouldUseDefaultTheme = !options.theme || options.theme === Quill.DEFAULTS.theme;
            const theme = shouldUseDefaultTheme ? core_theme : Quill.import(`themes/${options.theme}`);
            if (!theme) throw new Error(`Invalid theme ${options.theme}. Did you register it?`);
            const {modules: quillModuleDefaults, ...quillDefaults} = Quill.DEFAULTS;
            const {modules: themeModuleDefaults, ...themeDefaults} = theme.DEFAULTS;
            let userModuleOptions = expandModuleConfig(options.modules);
            if (userModuleOptions != null && userModuleOptions.toolbar && userModuleOptions.toolbar.constructor !== Object) userModuleOptions = {
                ...userModuleOptions,
                toolbar: {
                    container: userModuleOptions.toolbar
                }
            };
            const modules = lodash_es_merge({}, expandModuleConfig(quillModuleDefaults), expandModuleConfig(themeModuleDefaults), userModuleOptions);
            const config = {
                ...quillDefaults,
                ...omitUndefinedValuesFromOptions(themeDefaults),
                ...omitUndefinedValuesFromOptions(options)
            };
            let registry = options.registry;
            if (registry) {
                if (options.formats) quill_debug.warn('Ignoring "formats" option because "registry" is specified');
            } else registry = options.formats ? utils_createRegistryWithFormats(options.formats, config.registry, quill_debug) : config.registry;
            return {
                ...config,
                registry,
                container,
                theme,
                modules: Object.entries(modules).reduce(((modulesWithDefaults, _ref2) => {
                    let [name, value] = _ref2;
                    if (!value) return modulesWithDefaults;
                    const moduleClass = Quill.import(`modules/${name}`);
                    if (moduleClass == null) {
                        quill_debug.error(`Cannot load ${name} module. Are you sure you registered it?`);
                        return modulesWithDefaults;
                    }
                    return {
                        ...modulesWithDefaults,
                        [name]: lodash_es_merge({}, moduleClass.DEFAULTS || {}, value)
                    };
                }), {}),
                bounds: resolveSelector(config.bounds)
            };
        }
        function modify(modifier, source, index, shift) {
            if (!this.isEnabled() && source === core_emitter.sources.USER && !this.allowReadOnlyEdits) return new Delta;
            let range = index == null ? null : this.getSelection();
            const oldDelta = this.editor.delta;
            const change = modifier();
            if (range != null) {
                if (index === true) index = range.index;
                if (shift == null) range = quill_shiftRange(range, change, source); else if (shift !== 0) range = quill_shiftRange(range, index, shift, source);
                this.setSelection(range, core_emitter.sources.SILENT);
            }
            if (change.length() > 0) {
                const args = [ core_emitter.events.TEXT_CHANGE, change, oldDelta, source ];
                this.emitter.emit(core_emitter.events.EDITOR_CHANGE, ...args);
                if (source !== core_emitter.sources.SILENT) this.emitter.emit(...args);
            }
            return change;
        }
        function overload(index, length, name, value, source) {
            let formats = {};
            if (typeof index.index === "number" && typeof index.length === "number") if (typeof length !== "number") {
                source = value;
                value = name;
                name = length;
                length = index.length;
                index = index.index;
            } else {
                length = index.length;
                index = index.index;
            } else if (typeof length !== "number") {
                source = value;
                value = name;
                name = length;
                length = 0;
            }
            if (typeof name === "object") {
                formats = name;
                source = value;
            } else if (typeof name === "string") if (value != null) formats[name] = value; else source = name;
            source = source || core_emitter.sources.API;
            return [ index, length, formats, source ];
        }
        function quill_shiftRange(range, index, lengthOrSource, source) {
            const length = typeof lengthOrSource === "number" ? lengthOrSource : 0;
            if (range == null) return null;
            let start;
            let end;
            if (index && typeof index.transformPosition === "function") [start, end] = [ range.index, range.index + range.length ].map((pos => index.transformPosition(pos, source !== core_emitter.sources.USER))); else [start, end] = [ range.index, range.index + range.length ].map((pos => {
                if (pos < index || pos === index && source === core_emitter.sources.USER) return pos;
                if (length >= 0) return pos + length;
                return Math.max(index, pos + length);
            }));
            return new Range(start, end - start);
        }
        class Container extends ContainerBlot$1 {}
        const container = Container;
        function isLine(blot) {
            return blot instanceof Block || blot instanceof BlockEmbed;
        }
        function isUpdatable(blot) {
            return typeof blot.updateContent === "function";
        }
        class Scroll extends ScrollBlot$1 {
            static blotName="scroll";
            static className="ql-editor";
            static tagName="DIV";
            static defaultChild=Block;
            static allowedChildren=[ Block, BlockEmbed, container ];
            constructor(registry, domNode, _ref) {
                let {emitter} = _ref;
                super(registry, domNode);
                this.emitter = emitter;
                this.batch = false;
                this.optimize();
                this.enable();
                this.domNode.addEventListener("dragstart", (e => this.handleDragStart(e)));
            }
            batchStart() {
                if (!Array.isArray(this.batch)) this.batch = [];
            }
            batchEnd() {
                if (!this.batch) return;
                const mutations = this.batch;
                this.batch = false;
                this.update(mutations);
            }
            emitMount(blot) {
                this.emitter.emit(core_emitter.events.SCROLL_BLOT_MOUNT, blot);
            }
            emitUnmount(blot) {
                this.emitter.emit(core_emitter.events.SCROLL_BLOT_UNMOUNT, blot);
            }
            emitEmbedUpdate(blot, change) {
                this.emitter.emit(core_emitter.events.SCROLL_EMBED_UPDATE, blot, change);
            }
            deleteAt(index, length) {
                const [first, offset] = this.line(index);
                const [last] = this.line(index + length);
                super.deleteAt(index, length);
                if (last != null && first !== last && offset > 0) {
                    if (first instanceof BlockEmbed || last instanceof BlockEmbed) {
                        this.optimize();
                        return;
                    }
                    const ref = last.children.head instanceof blots_break ? null : last.children.head;
                    first.moveChildren(last, ref);
                    first.remove();
                }
                this.optimize();
            }
            enable() {
                let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.domNode.setAttribute("contenteditable", enabled ? "true" : "false");
            }
            formatAt(index, length, format, value) {
                super.formatAt(index, length, format, value);
                this.optimize();
            }
            insertAt(index, value, def) {
                if (index >= this.length()) if (def == null || this.scroll.query(value, Scope.BLOCK) == null) {
                    const blot = this.scroll.create(this.statics.defaultChild.blotName);
                    this.appendChild(blot);
                    if (def == null && value.endsWith("\n")) blot.insertAt(0, value.slice(0, -1), def); else blot.insertAt(0, value, def);
                } else {
                    const embed = this.scroll.create(value, def);
                    this.appendChild(embed);
                } else super.insertAt(index, value, def);
                this.optimize();
            }
            insertBefore(blot, ref) {
                if (blot.statics.scope === Scope.INLINE_BLOT) {
                    const wrapper = this.scroll.create(this.statics.defaultChild.blotName);
                    wrapper.appendChild(blot);
                    super.insertBefore(wrapper, ref);
                } else super.insertBefore(blot, ref);
            }
            insertContents(index, delta) {
                const renderBlocks = this.deltaToRenderBlocks(delta.concat((new Delta).insert("\n")));
                const last = renderBlocks.pop();
                if (last == null) return;
                this.batchStart();
                const first = renderBlocks.shift();
                if (first) {
                    const shouldInsertNewlineChar = first.type === "block" && (first.delta.length() === 0 || !this.descendant(BlockEmbed, index)[0] && index < this.length());
                    const delta = first.type === "block" ? first.delta : (new Delta).insert({
                        [first.key]: first.value
                    });
                    insertInlineContents(this, index, delta);
                    const newlineCharLength = first.type === "block" ? 1 : 0;
                    const lineEndIndex = index + delta.length() + newlineCharLength;
                    if (shouldInsertNewlineChar) this.insertAt(lineEndIndex - 1, "\n");
                    const formats = bubbleFormats(this.line(index)[0]);
                    const attributes = Delta.AttributeMap.diff(formats, first.attributes) || {};
                    Object.keys(attributes).forEach((name => {
                        this.formatAt(lineEndIndex - 1, 1, name, attributes[name]);
                    }));
                    index = lineEndIndex;
                }
                let [refBlot, refBlotOffset] = this.children.find(index);
                if (renderBlocks.length) {
                    if (refBlot) {
                        refBlot = refBlot.split(refBlotOffset);
                        refBlotOffset = 0;
                    }
                    renderBlocks.forEach((renderBlock => {
                        if (renderBlock.type === "block") {
                            const block = this.createBlock(renderBlock.attributes, refBlot || void 0);
                            insertInlineContents(block, 0, renderBlock.delta);
                        } else {
                            const blockEmbed = this.create(renderBlock.key, renderBlock.value);
                            this.insertBefore(blockEmbed, refBlot || void 0);
                            Object.keys(renderBlock.attributes).forEach((name => {
                                blockEmbed.format(name, renderBlock.attributes[name]);
                            }));
                        }
                    }));
                }
                if (last.type === "block" && last.delta.length()) {
                    const offset = refBlot ? refBlot.offset(refBlot.scroll) + refBlotOffset : this.length();
                    insertInlineContents(this, offset, last.delta);
                }
                this.batchEnd();
                this.optimize();
            }
            isEnabled() {
                return this.domNode.getAttribute("contenteditable") === "true";
            }
            leaf(index) {
                const last = this.path(index).pop();
                if (!last) return [ null, -1 ];
                const [blot, offset] = last;
                return blot instanceof LeafBlot$1 ? [ blot, offset ] : [ null, -1 ];
            }
            line(index) {
                if (index === this.length()) return this.line(index - 1);
                return this.descendant(isLine, index);
            }
            lines() {
                let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                const getLines = (blot, blotIndex, blotLength) => {
                    let lines = [];
                    let lengthLeft = blotLength;
                    blot.children.forEachAt(blotIndex, blotLength, ((child, childIndex, childLength) => {
                        if (isLine(child)) lines.push(child); else if (child instanceof ContainerBlot$1) lines = lines.concat(getLines(child, childIndex, lengthLeft));
                        lengthLeft -= childLength;
                    }));
                    return lines;
                };
                return getLines(this, index, length);
            }
            optimize() {
                let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (this.batch) return;
                super.optimize(mutations, context);
                if (mutations.length > 0) this.emitter.emit(core_emitter.events.SCROLL_OPTIMIZE, mutations, context);
            }
            path(index) {
                return super.path(index).slice(1);
            }
            remove() {}
            update(mutations) {
                if (this.batch) {
                    if (Array.isArray(mutations)) this.batch = this.batch.concat(mutations);
                    return;
                }
                let source = core_emitter.sources.USER;
                if (typeof mutations === "string") source = mutations;
                if (!Array.isArray(mutations)) mutations = this.observer.takeRecords();
                mutations = mutations.filter((_ref2 => {
                    let {target} = _ref2;
                    const blot = this.find(target, true);
                    return blot && !isUpdatable(blot);
                }));
                if (mutations.length > 0) this.emitter.emit(core_emitter.events.SCROLL_BEFORE_UPDATE, source, mutations);
                super.update(mutations.concat([]));
                if (mutations.length > 0) this.emitter.emit(core_emitter.events.SCROLL_UPDATE, source, mutations);
            }
            updateEmbedAt(index, key, change) {
                const [blot] = this.descendant((b => b instanceof BlockEmbed), index);
                if (blot && blot.statics.blotName === key && isUpdatable(blot)) blot.updateContent(change);
            }
            handleDragStart(event) {
                event.preventDefault();
            }
            deltaToRenderBlocks(delta) {
                const renderBlocks = [];
                let currentBlockDelta = new Delta;
                delta.forEach((op => {
                    const insert = op?.insert;
                    if (!insert) return;
                    if (typeof insert === "string") {
                        const splitted = insert.split("\n");
                        splitted.slice(0, -1).forEach((text => {
                            currentBlockDelta.insert(text, op.attributes);
                            renderBlocks.push({
                                type: "block",
                                delta: currentBlockDelta,
                                attributes: op.attributes ?? {}
                            });
                            currentBlockDelta = new Delta;
                        }));
                        const last = splitted[splitted.length - 1];
                        if (last) currentBlockDelta.insert(last, op.attributes);
                    } else {
                        const key = Object.keys(insert)[0];
                        if (!key) return;
                        if (this.query(key, Scope.INLINE)) currentBlockDelta.push(op); else {
                            if (currentBlockDelta.length()) renderBlocks.push({
                                type: "block",
                                delta: currentBlockDelta,
                                attributes: {}
                            });
                            currentBlockDelta = new Delta;
                            renderBlocks.push({
                                type: "blockEmbed",
                                key,
                                value: insert[key],
                                attributes: op.attributes ?? {}
                            });
                        }
                    }
                }));
                if (currentBlockDelta.length()) renderBlocks.push({
                    type: "block",
                    delta: currentBlockDelta,
                    attributes: {}
                });
                return renderBlocks;
            }
            createBlock(attributes, refBlot) {
                let blotName;
                const formats = {};
                Object.entries(attributes).forEach((_ref3 => {
                    let [key, value] = _ref3;
                    const isBlockBlot = this.query(key, Scope.BLOCK & Scope.BLOT) != null;
                    if (isBlockBlot) blotName = key; else formats[key] = value;
                }));
                const block = this.create(blotName || this.statics.defaultChild.blotName, blotName ? attributes[blotName] : void 0);
                this.insertBefore(block, refBlot || void 0);
                const length = block.length();
                Object.entries(formats).forEach((_ref4 => {
                    let [key, value] = _ref4;
                    block.formatAt(0, length, key, value);
                }));
                return block;
            }
        }
        function insertInlineContents(parent, index, inlineContents) {
            inlineContents.reduce(((index, op) => {
                const length = Delta.Op.length(op);
                let attributes = op.attributes || {};
                if (op.insert != null) if (typeof op.insert === "string") {
                    const text = op.insert;
                    parent.insertAt(index, text);
                    const [leaf] = parent.descendant(LeafBlot$1, index);
                    const formats = bubbleFormats(leaf);
                    attributes = Delta.AttributeMap.diff(formats, attributes) || {};
                } else if (typeof op.insert === "object") {
                    const key = Object.keys(op.insert)[0];
                    if (key == null) return index;
                    parent.insertAt(index, key, op.insert[key]);
                    const isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;
                    if (isInlineEmbed) {
                        const [leaf] = parent.descendant(LeafBlot$1, index);
                        const formats = bubbleFormats(leaf);
                        attributes = Delta.AttributeMap.diff(formats, attributes) || {};
                    }
                }
                Object.keys(attributes).forEach((key => {
                    parent.formatAt(index, length, key, attributes[key]);
                }));
                return index + length;
            }), index);
        }
        const blots_scroll = Scroll;
        const config = {
            scope: Scope.BLOCK,
            whitelist: [ "right", "center", "justify" ]
        };
        const AlignAttribute = new Attributor("align", "align", config);
        const AlignClass = new ClassAttributor$1("align", "ql-align", config);
        const AlignStyle = new StyleAttributor$1("align", "text-align", config);
        class ColorAttributor extends StyleAttributor$1 {
            value(domNode) {
                let value = super.value(domNode);
                if (!value.startsWith("rgb(")) return value;
                value = value.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
                const hex = value.split(",").map((component => `00${parseInt(component, 10).toString(16)}`.slice(-2))).join("");
                return `#${hex}`;
            }
        }
        const ColorClass = new ClassAttributor$1("color", "ql-color", {
            scope: Scope.INLINE
        });
        const ColorStyle = new ColorAttributor("color", "color", {
            scope: Scope.INLINE
        });
        const BackgroundClass = new ClassAttributor$1("background", "ql-bg", {
            scope: Scope.INLINE
        });
        const BackgroundStyle = new ColorAttributor("background", "background-color", {
            scope: Scope.INLINE
        });
        class CodeBlockContainer extends container {
            static create(value) {
                const domNode = super.create(value);
                domNode.setAttribute("spellcheck", "false");
                return domNode;
            }
            code(index, length) {
                return this.children.map((child => child.length() <= 1 ? "" : child.domNode.innerText)).join("\n").slice(index, index + length);
            }
            html(index, length) {
                return `<pre>\n${escapeText(this.code(index, length))}\n</pre>`;
            }
        }
        class CodeBlock extends Block {
            static TAB="  ";
            static register() {
                Quill.register(CodeBlockContainer);
            }
        }
        class Code extends inline {}
        Code.blotName = "code";
        Code.tagName = "CODE";
        CodeBlock.blotName = "code-block";
        CodeBlock.className = "ql-code-block";
        CodeBlock.tagName = "DIV";
        CodeBlockContainer.blotName = "code-block-container";
        CodeBlockContainer.className = "ql-code-block-container";
        CodeBlockContainer.tagName = "DIV";
        CodeBlockContainer.allowedChildren = [ CodeBlock ];
        CodeBlock.allowedChildren = [ text_Text, blots_break, cursor ];
        CodeBlock.requiredContainer = CodeBlockContainer;
        const direction_config = {
            scope: Scope.BLOCK,
            whitelist: [ "rtl" ]
        };
        const DirectionAttribute = new Attributor("direction", "dir", direction_config);
        const DirectionClass = new ClassAttributor$1("direction", "ql-direction", direction_config);
        const DirectionStyle = new StyleAttributor$1("direction", "direction", direction_config);
        const font_config = {
            scope: Scope.INLINE,
            whitelist: [ "serif", "monospace" ]
        };
        const FontClass = new ClassAttributor$1("font", "ql-font", font_config);
        class FontStyleAttributor extends StyleAttributor$1 {
            value(node) {
                return super.value(node).replace(/["']/g, "");
            }
        }
        const FontStyle = new FontStyleAttributor("font", "font-family", font_config);
        const SizeClass = new ClassAttributor$1("size", "ql-size", {
            scope: Scope.INLINE,
            whitelist: [ "small", "large", "huge" ]
        });
        const SizeStyle = new StyleAttributor$1("size", "font-size", {
            scope: Scope.INLINE,
            whitelist: [ "10px", "18px", "32px" ]
        });
        const keyboard_debug = logger("quill:keyboard");
        const SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
        class keyboard_Keyboard extends core_module {
            static match(evt, binding) {
                if ([ "altKey", "ctrlKey", "metaKey", "shiftKey" ].some((key => !!binding[key] !== evt[key] && binding[key] !== null))) return false;
                return binding.key === evt.key || binding.key === evt.which;
            }
            constructor(quill, options) {
                super(quill, options);
                this.bindings = {};
                Object.keys(this.options.bindings).forEach((name => {
                    if (this.options.bindings[name]) this.addBinding(this.options.bindings[name]);
                }));
                this.addBinding({
                    key: "Enter",
                    shiftKey: null
                }, this.handleEnter);
                this.addBinding({
                    key: "Enter",
                    metaKey: null,
                    ctrlKey: null,
                    altKey: null
                }, (() => {}));
                if (/Firefox/i.test(navigator.userAgent)) {
                    this.addBinding({
                        key: "Backspace"
                    }, {
                        collapsed: true
                    }, this.handleBackspace);
                    this.addBinding({
                        key: "Delete"
                    }, {
                        collapsed: true
                    }, this.handleDelete);
                } else {
                    this.addBinding({
                        key: "Backspace"
                    }, {
                        collapsed: true,
                        prefix: /^.?$/
                    }, this.handleBackspace);
                    this.addBinding({
                        key: "Delete"
                    }, {
                        collapsed: true,
                        suffix: /^.?$/
                    }, this.handleDelete);
                }
                this.addBinding({
                    key: "Backspace"
                }, {
                    collapsed: false
                }, this.handleDeleteRange);
                this.addBinding({
                    key: "Delete"
                }, {
                    collapsed: false
                }, this.handleDeleteRange);
                this.addBinding({
                    key: "Backspace",
                    altKey: null,
                    ctrlKey: null,
                    metaKey: null,
                    shiftKey: null
                }, {
                    collapsed: true,
                    offset: 0
                }, this.handleBackspace);
                this.listen();
            }
            addBinding(keyBinding) {
                let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                const binding = normalize(keyBinding);
                if (binding == null) {
                    keyboard_debug.warn("Attempted to add invalid keyboard binding", binding);
                    return;
                }
                if (typeof context === "function") context = {
                    handler: context
                };
                if (typeof handler === "function") handler = {
                    handler
                };
                const keys = Array.isArray(binding.key) ? binding.key : [ binding.key ];
                keys.forEach((key => {
                    const singleBinding = {
                        ...binding,
                        key,
                        ...context,
                        ...handler
                    };
                    this.bindings[singleBinding.key] = this.bindings[singleBinding.key] || [];
                    this.bindings[singleBinding.key].push(singleBinding);
                }));
            }
            listen() {
                this.quill.root.addEventListener("keydown", (evt => {
                    if (evt.defaultPrevented || evt.isComposing) return;
                    const isComposing = evt.keyCode === 229 && (evt.key === "Enter" || evt.key === "Backspace");
                    if (isComposing) return;
                    const bindings = (this.bindings[evt.key] || []).concat(this.bindings[evt.which] || []);
                    const matches = bindings.filter((binding => keyboard_Keyboard.match(evt, binding)));
                    if (matches.length === 0) return;
                    const blot = Quill.find(evt.target, true);
                    if (blot && blot.scroll !== this.quill.scroll) return;
                    const range = this.quill.getSelection();
                    if (range == null || !this.quill.hasFocus()) return;
                    const [line, offset] = this.quill.getLine(range.index);
                    const [leafStart, offsetStart] = this.quill.getLeaf(range.index);
                    const [leafEnd, offsetEnd] = range.length === 0 ? [ leafStart, offsetStart ] : this.quill.getLeaf(range.index + range.length);
                    const prefixText = leafStart instanceof TextBlot$1 ? leafStart.value().slice(0, offsetStart) : "";
                    const suffixText = leafEnd instanceof TextBlot$1 ? leafEnd.value().slice(offsetEnd) : "";
                    const curContext = {
                        collapsed: range.length === 0,
                        empty: range.length === 0 && line.length() <= 1,
                        format: this.quill.getFormat(range),
                        line,
                        offset,
                        prefix: prefixText,
                        suffix: suffixText,
                        event: evt
                    };
                    const prevented = matches.some((binding => {
                        if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
                        if (binding.empty != null && binding.empty !== curContext.empty) return false;
                        if (binding.offset != null && binding.offset !== curContext.offset) return false;
                        if (Array.isArray(binding.format)) {
                            if (binding.format.every((name => curContext.format[name] == null))) return false;
                        } else if (typeof binding.format === "object") if (!Object.keys(binding.format).every((name => {
                            if (binding.format[name] === true) return curContext.format[name] != null;
                            if (binding.format[name] === false) return curContext.format[name] == null;
                            return lodash_es_isEqual(binding.format[name], curContext.format[name]);
                        }))) return false;
                        if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
                        if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
                        return binding.handler.call(this, range, curContext, binding) !== true;
                    }));
                    if (prevented) evt.preventDefault();
                }));
            }
            handleBackspace(range, context) {
                const length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
                if (range.index === 0 || this.quill.getLength() <= 1) return;
                let formats = {};
                const [line] = this.quill.getLine(range.index);
                let delta = (new Delta).retain(range.index - length).delete(length);
                if (context.offset === 0) {
                    const [prev] = this.quill.getLine(range.index - 1);
                    if (prev) {
                        const isPrevLineEmpty = prev.statics.blotName === "block" && prev.length() <= 1;
                        if (!isPrevLineEmpty) {
                            const curFormats = line.formats();
                            const prevFormats = this.quill.getFormat(range.index - 1, 1);
                            formats = Delta.AttributeMap.diff(curFormats, prevFormats) || {};
                            if (Object.keys(formats).length > 0) {
                                const formatDelta = (new Delta).retain(range.index + line.length() - 2).retain(1, formats);
                                delta = delta.compose(formatDelta);
                            }
                        }
                    }
                }
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.focus();
            }
            handleDelete(range, context) {
                const length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
                if (range.index >= this.quill.getLength() - length) return;
                let formats = {};
                const [line] = this.quill.getLine(range.index);
                let delta = (new Delta).retain(range.index).delete(length);
                if (context.offset >= line.length() - 1) {
                    const [next] = this.quill.getLine(range.index + 1);
                    if (next) {
                        const curFormats = line.formats();
                        const nextFormats = this.quill.getFormat(range.index, 1);
                        formats = Delta.AttributeMap.diff(curFormats, nextFormats) || {};
                        if (Object.keys(formats).length > 0) delta = delta.retain(next.length() - 1).retain(1, formats);
                    }
                }
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.focus();
            }
            handleDeleteRange(range) {
                deleteRange({
                    range,
                    quill: this.quill
                });
                this.quill.focus();
            }
            handleEnter(range, context) {
                const lineFormats = Object.keys(context.format).reduce(((formats, format) => {
                    if (this.quill.scroll.query(format, Scope.BLOCK) && !Array.isArray(context.format[format])) formats[format] = context.format[format];
                    return formats;
                }), {});
                const delta = (new Delta).retain(range.index).delete(range.length).insert("\n", lineFormats);
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
                this.quill.focus();
            }
        }
        const defaultOptions = {
            bindings: {
                bold: makeFormatHandler("bold"),
                italic: makeFormatHandler("italic"),
                underline: makeFormatHandler("underline"),
                indent: {
                    key: "Tab",
                    format: [ "blockquote", "indent", "list" ],
                    handler(range, context) {
                        if (context.collapsed && context.offset !== 0) return true;
                        this.quill.format("indent", "+1", Quill.sources.USER);
                        return false;
                    }
                },
                outdent: {
                    key: "Tab",
                    shiftKey: true,
                    format: [ "blockquote", "indent", "list" ],
                    handler(range, context) {
                        if (context.collapsed && context.offset !== 0) return true;
                        this.quill.format("indent", "-1", Quill.sources.USER);
                        return false;
                    }
                },
                "outdent backspace": {
                    key: "Backspace",
                    collapsed: true,
                    shiftKey: null,
                    metaKey: null,
                    ctrlKey: null,
                    altKey: null,
                    format: [ "indent", "list" ],
                    offset: 0,
                    handler(range, context) {
                        if (context.format.indent != null) this.quill.format("indent", "-1", Quill.sources.USER); else if (context.format.list != null) this.quill.format("list", false, Quill.sources.USER);
                    }
                },
                "indent code-block": makeCodeBlockHandler(true),
                "outdent code-block": makeCodeBlockHandler(false),
                "remove tab": {
                    key: "Tab",
                    shiftKey: true,
                    collapsed: true,
                    prefix: /\t$/,
                    handler(range) {
                        this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);
                    }
                },
                tab: {
                    key: "Tab",
                    handler(range, context) {
                        if (context.format.table) return true;
                        this.quill.history.cutoff();
                        const delta = (new Delta).retain(range.index).delete(range.length).insert("\t");
                        this.quill.updateContents(delta, Quill.sources.USER);
                        this.quill.history.cutoff();
                        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
                        return false;
                    }
                },
                "blockquote empty enter": {
                    key: "Enter",
                    collapsed: true,
                    format: [ "blockquote" ],
                    empty: true,
                    handler() {
                        this.quill.format("blockquote", false, Quill.sources.USER);
                    }
                },
                "list empty enter": {
                    key: "Enter",
                    collapsed: true,
                    format: [ "list" ],
                    empty: true,
                    handler(range, context) {
                        const formats = {
                            list: false
                        };
                        if (context.format.indent) formats.indent = false;
                        this.quill.formatLine(range.index, range.length, formats, Quill.sources.USER);
                    }
                },
                "checklist enter": {
                    key: "Enter",
                    collapsed: true,
                    format: {
                        list: "checked"
                    },
                    handler(range) {
                        const [line, offset] = this.quill.getLine(range.index);
                        const formats = {
                            ...line.formats(),
                            list: "checked"
                        };
                        const delta = (new Delta).retain(range.index).insert("\n", formats).retain(line.length() - offset - 1).retain(1, {
                            list: "unchecked"
                        });
                        this.quill.updateContents(delta, Quill.sources.USER);
                        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
                        this.quill.scrollSelectionIntoView();
                    }
                },
                "header enter": {
                    key: "Enter",
                    collapsed: true,
                    format: [ "header" ],
                    suffix: /^$/,
                    handler(range, context) {
                        const [line, offset] = this.quill.getLine(range.index);
                        const delta = (new Delta).retain(range.index).insert("\n", context.format).retain(line.length() - offset - 1).retain(1, {
                            header: null
                        });
                        this.quill.updateContents(delta, Quill.sources.USER);
                        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
                        this.quill.scrollSelectionIntoView();
                    }
                },
                "table backspace": {
                    key: "Backspace",
                    format: [ "table" ],
                    collapsed: true,
                    offset: 0,
                    handler() {}
                },
                "table delete": {
                    key: "Delete",
                    format: [ "table" ],
                    collapsed: true,
                    suffix: /^$/,
                    handler() {}
                },
                "table enter": {
                    key: "Enter",
                    shiftKey: null,
                    format: [ "table" ],
                    handler(range) {
                        const module = this.quill.getModule("table");
                        if (module) {
                            const [table, row, cell, offset] = module.getTable(range);
                            const shift = tableSide(table, row, cell, offset);
                            if (shift == null) return;
                            let index = table.offset();
                            if (shift < 0) {
                                const delta = (new Delta).retain(index).insert("\n");
                                this.quill.updateContents(delta, Quill.sources.USER);
                                this.quill.setSelection(range.index + 1, range.length, Quill.sources.SILENT);
                            } else if (shift > 0) {
                                index += table.length();
                                const delta = (new Delta).retain(index).insert("\n");
                                this.quill.updateContents(delta, Quill.sources.USER);
                                this.quill.setSelection(index, Quill.sources.USER);
                            }
                        }
                    }
                },
                "table tab": {
                    key: "Tab",
                    shiftKey: null,
                    format: [ "table" ],
                    handler(range, context) {
                        const {event, line: cell} = context;
                        const offset = cell.offset(this.quill.scroll);
                        if (event.shiftKey) this.quill.setSelection(offset - 1, Quill.sources.USER); else this.quill.setSelection(offset + cell.length(), Quill.sources.USER);
                    }
                },
                "list autofill": {
                    key: " ",
                    shiftKey: null,
                    collapsed: true,
                    format: {
                        "code-block": false,
                        blockquote: false,
                        table: false
                    },
                    prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                    handler(range, context) {
                        if (this.quill.scroll.query("list") == null) return true;
                        const {length} = context.prefix;
                        const [line, offset] = this.quill.getLine(range.index);
                        if (offset > length) return true;
                        let value;
                        switch (context.prefix.trim()) {
                          case "[]":
                          case "[ ]":
                            value = "unchecked";
                            break;

                          case "[x]":
                            value = "checked";
                            break;

                          case "-":
                          case "*":
                            value = "bullet";
                            break;

                          default:
                            value = "ordered";
                        }
                        this.quill.insertText(range.index, " ", Quill.sources.USER);
                        this.quill.history.cutoff();
                        const delta = (new Delta).retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
                            list: value
                        });
                        this.quill.updateContents(delta, Quill.sources.USER);
                        this.quill.history.cutoff();
                        this.quill.setSelection(range.index - length, Quill.sources.SILENT);
                        return false;
                    }
                },
                "code exit": {
                    key: "Enter",
                    collapsed: true,
                    format: [ "code-block" ],
                    prefix: /^$/,
                    suffix: /^\s*$/,
                    handler(range) {
                        const [line, offset] = this.quill.getLine(range.index);
                        let numLines = 2;
                        let cur = line;
                        while (cur != null && cur.length() <= 1 && cur.formats()["code-block"]) {
                            cur = cur.prev;
                            numLines -= 1;
                            if (numLines <= 0) {
                                const delta = (new Delta).retain(range.index + line.length() - offset - 2).retain(1, {
                                    "code-block": null
                                }).delete(1);
                                this.quill.updateContents(delta, Quill.sources.USER);
                                this.quill.setSelection(range.index - 1, Quill.sources.SILENT);
                                return false;
                            }
                        }
                        return true;
                    }
                },
                "embed left": makeEmbedArrowHandler("ArrowLeft", false),
                "embed left shift": makeEmbedArrowHandler("ArrowLeft", true),
                "embed right": makeEmbedArrowHandler("ArrowRight", false),
                "embed right shift": makeEmbedArrowHandler("ArrowRight", true),
                "table down": makeTableArrowHandler(false),
                "table up": makeTableArrowHandler(true)
            }
        };
        keyboard_Keyboard.DEFAULTS = defaultOptions;
        function makeCodeBlockHandler(indent) {
            return {
                key: "Tab",
                shiftKey: !indent,
                format: {
                    "code-block": true
                },
                handler(range, _ref) {
                    let {event} = _ref;
                    const CodeBlock = this.quill.scroll.query("code-block");
                    const {TAB} = CodeBlock;
                    if (range.length === 0 && !event.shiftKey) {
                        this.quill.insertText(range.index, TAB, Quill.sources.USER);
                        this.quill.setSelection(range.index + TAB.length, Quill.sources.SILENT);
                        return;
                    }
                    const lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);
                    let {index, length} = range;
                    lines.forEach(((line, i) => {
                        if (indent) {
                            line.insertAt(0, TAB);
                            if (i === 0) index += TAB.length; else length += TAB.length;
                        } else if (line.domNode.textContent.startsWith(TAB)) {
                            line.deleteAt(0, TAB.length);
                            if (i === 0) index -= TAB.length; else length -= TAB.length;
                        }
                    }));
                    this.quill.update(Quill.sources.USER);
                    this.quill.setSelection(index, length, Quill.sources.SILENT);
                }
            };
        }
        function makeEmbedArrowHandler(key, shiftKey) {
            const where = key === "ArrowLeft" ? "prefix" : "suffix";
            return {
                key,
                shiftKey,
                altKey: null,
                [where]: /^$/,
                handler(range) {
                    let {index} = range;
                    if (key === "ArrowRight") index += range.length + 1;
                    const [leaf] = this.quill.getLeaf(index);
                    if (!(leaf instanceof EmbedBlot$1)) return true;
                    if (key === "ArrowLeft") if (shiftKey) this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER); else this.quill.setSelection(range.index - 1, Quill.sources.USER); else if (shiftKey) this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER); else this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);
                    return false;
                }
            };
        }
        function makeFormatHandler(format) {
            return {
                key: format[0],
                shortKey: true,
                handler(range, context) {
                    this.quill.format(format, !context.format[format], Quill.sources.USER);
                }
            };
        }
        function makeTableArrowHandler(up) {
            return {
                key: up ? "ArrowUp" : "ArrowDown",
                collapsed: true,
                format: [ "table" ],
                handler(range, context) {
                    const key = up ? "prev" : "next";
                    const cell = context.line;
                    const targetRow = cell.parent[key];
                    if (targetRow != null) {
                        if (targetRow.statics.blotName === "table-row") {
                            let targetCell = targetRow.children.head;
                            let cur = cell;
                            while (cur.prev != null) {
                                cur = cur.prev;
                                targetCell = targetCell.next;
                            }
                            const index = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);
                            this.quill.setSelection(index, 0, Quill.sources.USER);
                        }
                    } else {
                        const targetLine = cell.table()[key];
                        if (targetLine != null) if (up) this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, Quill.sources.USER); else this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, Quill.sources.USER);
                    }
                    return false;
                }
            };
        }
        function normalize(binding) {
            if (typeof binding === "string" || typeof binding === "number") binding = {
                key: binding
            }; else if (typeof binding === "object") binding = lodash_es_cloneDeep(binding); else return null;
            if (binding.shortKey) {
                binding[SHORTKEY] = binding.shortKey;
                delete binding.shortKey;
            }
            return binding;
        }
        function deleteRange(_ref2) {
            let {quill, range} = _ref2;
            const lines = quill.getLines(range);
            let formats = {};
            if (lines.length > 1) {
                const firstFormats = lines[0].formats();
                const lastFormats = lines[lines.length - 1].formats();
                formats = Delta.AttributeMap.diff(lastFormats, firstFormats) || {};
            }
            quill.deleteText(range, Quill.sources.USER);
            if (Object.keys(formats).length > 0) quill.formatLine(range.index, 1, formats, Quill.sources.USER);
            quill.setSelection(range.index, Quill.sources.SILENT);
        }
        function tableSide(_table, row, cell, offset) {
            if (row.prev == null && row.next == null) {
                if (cell.prev == null && cell.next == null) return offset === 0 ? -1 : 1;
                return cell.prev == null ? -1 : 1;
            }
            if (row.prev == null) return -1;
            if (row.next == null) return 1;
            return null;
        }
        const normalWeightRegexp = /font-weight:\s*normal/;
        const blockTagNames = [ "P", "OL", "UL" ];
        const isBlockElement = element => element && blockTagNames.includes(element.tagName);
        const normalizeEmptyLines = doc => {
            Array.from(doc.querySelectorAll("br")).filter((br => isBlockElement(br.previousElementSibling) && isBlockElement(br.nextElementSibling))).forEach((br => {
                br.parentNode?.removeChild(br);
            }));
        };
        const normalizeFontWeight = doc => {
            Array.from(doc.querySelectorAll('b[style*="font-weight"]')).filter((node => node.getAttribute("style")?.match(normalWeightRegexp))).forEach((node => {
                const fragment = doc.createDocumentFragment();
                fragment.append(...node.childNodes);
                node.parentNode?.replaceChild(fragment, node);
            }));
        };
        function googleDocs_normalize(doc) {
            if (doc.querySelector('[id^="docs-internal-guid-"]')) {
                normalizeFontWeight(doc);
                normalizeEmptyLines(doc);
            }
        }
        const ignoreRegexp = /\bmso-list:[^;]*ignore/i;
        const idRegexp = /\bmso-list:[^;]*\bl(\d+)/i;
        const indentRegexp = /\bmso-list:[^;]*\blevel(\d+)/i;
        const parseListItem = (element, html) => {
            const style = element.getAttribute("style");
            const idMatch = style?.match(idRegexp);
            if (!idMatch) return null;
            const id = Number(idMatch[1]);
            const indentMatch = style?.match(indentRegexp);
            const indent = indentMatch ? Number(indentMatch[1]) : 1;
            const typeRegexp = new RegExp(`@list l${id}:level${indent}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i");
            const typeMatch = html.match(typeRegexp);
            const type = typeMatch && typeMatch[1] === "bullet" ? "bullet" : "ordered";
            return {
                id,
                indent,
                type,
                element
            };
        };
        const normalizeListItem = doc => {
            const msoList = Array.from(doc.querySelectorAll("[style*=mso-list]"));
            const ignored = [];
            const others = [];
            msoList.forEach((node => {
                const shouldIgnore = (node.getAttribute("style") || "").match(ignoreRegexp);
                if (shouldIgnore) ignored.push(node); else others.push(node);
            }));
            ignored.forEach((node => node.parentNode?.removeChild(node)));
            const html = doc.documentElement.innerHTML;
            const listItems = others.map((element => parseListItem(element, html))).filter((parsed => parsed));
            while (listItems.length) {
                const childListItems = [];
                let current = listItems.shift();
                while (current) {
                    childListItems.push(current);
                    current = listItems.length && listItems[0]?.element === current.element.nextElementSibling && listItems[0].id === current.id ? listItems.shift() : null;
                }
                const ul = document.createElement("ul");
                childListItems.forEach((listItem => {
                    const li = document.createElement("li");
                    li.setAttribute("data-list", listItem.type);
                    if (listItem.indent > 1) li.setAttribute("class", `ql-indent-${listItem.indent - 1}`);
                    li.innerHTML = listItem.element.innerHTML;
                    ul.appendChild(li);
                }));
                const element = childListItems[0]?.element;
                const {parentNode} = element ?? {};
                if (element) parentNode?.replaceChild(ul, element);
                childListItems.slice(1).forEach((_ref => {
                    let {element: e} = _ref;
                    parentNode?.removeChild(e);
                }));
            }
        };
        function msWord_normalize(doc) {
            if (doc.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word") normalizeListItem(doc);
        }
        const NORMALIZERS = [ msWord_normalize, googleDocs_normalize ];
        const normalizeExternalHTML = doc => {
            if (doc.documentElement) NORMALIZERS.forEach((normalize => {
                normalize(doc);
            }));
        };
        const modules_normalizeExternalHTML = normalizeExternalHTML;
        const clipboard_debug = logger("quill:clipboard");
        const CLIPBOARD_CONFIG = [ [ Node.TEXT_NODE, matchText ], [ Node.TEXT_NODE, matchNewline ], [ "br", matchBreak ], [ Node.ELEMENT_NODE, matchNewline ], [ Node.ELEMENT_NODE, matchBlot ], [ Node.ELEMENT_NODE, matchAttributor ], [ Node.ELEMENT_NODE, matchStyles ], [ "li", matchIndent ], [ "ol, ul", matchList ], [ "pre", matchCodeBlock ], [ "tr", matchTable ], [ "b", createMatchAlias("bold") ], [ "i", createMatchAlias("italic") ], [ "strike", createMatchAlias("strike") ], [ "style", matchIgnore ] ];
        const ATTRIBUTE_ATTRIBUTORS = [ AlignAttribute, DirectionAttribute ].reduce(((memo, attr) => {
            memo[attr.keyName] = attr;
            return memo;
        }), {});
        const STYLE_ATTRIBUTORS = [ AlignStyle, BackgroundStyle, ColorStyle, DirectionStyle, FontStyle, SizeStyle ].reduce(((memo, attr) => {
            memo[attr.keyName] = attr;
            return memo;
        }), {});
        class Clipboard extends core_module {
            static DEFAULTS={
                matchers: []
            };
            constructor(quill, options) {
                super(quill, options);
                this.quill.root.addEventListener("copy", (e => this.onCaptureCopy(e, false)));
                this.quill.root.addEventListener("cut", (e => this.onCaptureCopy(e, true)));
                this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this));
                this.matchers = [];
                CLIPBOARD_CONFIG.concat(this.options.matchers ?? []).forEach((_ref => {
                    let [selector, matcher] = _ref;
                    this.addMatcher(selector, matcher);
                }));
            }
            addMatcher(selector, matcher) {
                this.matchers.push([ selector, matcher ]);
            }
            convert(_ref2) {
                let {html, text} = _ref2;
                let formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (formats[CodeBlock.blotName]) return (new Delta).insert(text || "", {
                    [CodeBlock.blotName]: formats[CodeBlock.blotName]
                });
                if (!html) return (new Delta).insert(text || "", formats);
                const delta = this.convertHTML(html);
                if (deltaEndsWith(delta, "\n") && (delta.ops[delta.ops.length - 1].attributes == null || formats.table)) return delta.compose((new Delta).retain(delta.length() - 1).delete(1));
                return delta;
            }
            normalizeHTML(doc) {
                modules_normalizeExternalHTML(doc);
            }
            convertHTML(html) {
                const doc = (new DOMParser).parseFromString(html, "text/html");
                this.normalizeHTML(doc);
                const container = doc.body;
                const nodeMatches = new WeakMap;
                const [elementMatchers, textMatchers] = this.prepareMatching(container, nodeMatches);
                return traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches);
            }
            dangerouslyPasteHTML(index, html) {
                let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Quill.sources.API;
                if (typeof index === "string") {
                    const delta = this.convert({
                        html: index,
                        text: ""
                    });
                    this.quill.setContents(delta, html);
                    this.quill.setSelection(0, Quill.sources.SILENT);
                } else {
                    const paste = this.convert({
                        html,
                        text: ""
                    });
                    this.quill.updateContents((new Delta).retain(index).concat(paste), source);
                    this.quill.setSelection(index + paste.length(), Quill.sources.SILENT);
                }
            }
            onCaptureCopy(e) {
                let isCut = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (e.defaultPrevented) return;
                e.preventDefault();
                const [range] = this.quill.selection.getRange();
                if (range == null) return;
                const {html, text} = this.onCopy(range, isCut);
                e.clipboardData?.setData("text/plain", text);
                e.clipboardData?.setData("text/html", html);
                if (isCut) deleteRange({
                    range,
                    quill: this.quill
                });
            }
            normalizeURIList(urlList) {
                return urlList.split(/\r?\n/).filter((url => url[0] !== "#")).join("\n");
            }
            onCapturePaste(e) {
                if (e.defaultPrevented || !this.quill.isEnabled()) return;
                e.preventDefault();
                const range = this.quill.getSelection(true);
                if (range == null) return;
                const html = e.clipboardData?.getData("text/html");
                let text = e.clipboardData?.getData("text/plain");
                if (!html && !text) {
                    const urlList = e.clipboardData?.getData("text/uri-list");
                    if (urlList) text = this.normalizeURIList(urlList);
                }
                const files = Array.from(e.clipboardData?.files || []);
                if (!html && files.length > 0) {
                    this.quill.uploader.upload(range, files);
                    return;
                }
                if (html && files.length > 0) {
                    const doc = (new DOMParser).parseFromString(html, "text/html");
                    if (doc.body.childElementCount === 1 && doc.body.firstElementChild?.tagName === "IMG") {
                        this.quill.uploader.upload(range, files);
                        return;
                    }
                }
                this.onPaste(range, {
                    html,
                    text
                });
            }
            onCopy(range) {
                const text = this.quill.getText(range);
                const html = this.quill.getSemanticHTML(range);
                return {
                    html,
                    text
                };
            }
            onPaste(range, _ref3) {
                let {text, html} = _ref3;
                const formats = this.quill.getFormat(range.index);
                const pastedDelta = this.convert({
                    text,
                    html
                }, formats);
                clipboard_debug.log("onPaste", pastedDelta, {
                    text,
                    html
                });
                const delta = (new Delta).retain(range.index).delete(range.length).concat(pastedDelta);
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(delta.length() - range.length, Quill.sources.SILENT);
                this.quill.scrollSelectionIntoView();
            }
            prepareMatching(container, nodeMatches) {
                const elementMatchers = [];
                const textMatchers = [];
                this.matchers.forEach((pair => {
                    const [selector, matcher] = pair;
                    switch (selector) {
                      case Node.TEXT_NODE:
                        textMatchers.push(matcher);
                        break;

                      case Node.ELEMENT_NODE:
                        elementMatchers.push(matcher);
                        break;

                      default:
                        Array.from(container.querySelectorAll(selector)).forEach((node => {
                            if (nodeMatches.has(node)) {
                                const matches = nodeMatches.get(node);
                                matches?.push(matcher);
                            } else nodeMatches.set(node, [ matcher ]);
                        }));
                        break;
                    }
                }));
                return [ elementMatchers, textMatchers ];
            }
        }
        function applyFormat(delta, format, value, scroll) {
            if (!scroll.query(format)) return delta;
            return delta.reduce(((newDelta, op) => {
                if (!op.insert) return newDelta;
                if (op.attributes && op.attributes[format]) return newDelta.push(op);
                const formats = value ? {
                    [format]: value
                } : {};
                return newDelta.insert(op.insert, {
                    ...formats,
                    ...op.attributes
                });
            }), new Delta);
        }
        function deltaEndsWith(delta, text) {
            let endText = "";
            for (let i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
                const op = delta.ops[i];
                if (typeof op.insert !== "string") break;
                endText = op.insert + endText;
            }
            return endText.slice(-1 * text.length) === text;
        }
        function clipboard_isLine(node, scroll) {
            if (!(node instanceof Element)) return false;
            const match = scroll.query(node);
            if (match && match.prototype instanceof EmbedBlot$1) return false;
            return [ "address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video" ].includes(node.tagName.toLowerCase());
        }
        function isBetweenInlineElements(node, scroll) {
            return node.previousElementSibling && node.nextElementSibling && !clipboard_isLine(node.previousElementSibling, scroll) && !clipboard_isLine(node.nextElementSibling, scroll);
        }
        const preNodes = new WeakMap;
        function isPre(node) {
            if (node == null) return false;
            if (!preNodes.has(node)) if (node.tagName === "PRE") preNodes.set(node, true); else preNodes.set(node, isPre(node.parentNode));
            return preNodes.get(node);
        }
        function traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {
            if (node.nodeType === node.TEXT_NODE) return textMatchers.reduce(((delta, matcher) => matcher(node, delta, scroll)), new Delta);
            if (node.nodeType === node.ELEMENT_NODE) return Array.from(node.childNodes || []).reduce(((delta, childNode) => {
                let childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);
                if (childNode.nodeType === node.ELEMENT_NODE) {
                    childrenDelta = elementMatchers.reduce(((reducedDelta, matcher) => matcher(childNode, reducedDelta, scroll)), childrenDelta);
                    childrenDelta = (nodeMatches.get(childNode) || []).reduce(((reducedDelta, matcher) => matcher(childNode, reducedDelta, scroll)), childrenDelta);
                }
                return delta.concat(childrenDelta);
            }), new Delta);
            return new Delta;
        }
        function createMatchAlias(format) {
            return (_node, delta, scroll) => applyFormat(delta, format, true, scroll);
        }
        function matchAttributor(node, delta, scroll) {
            const attributes = Attributor.keys(node);
            const classes = ClassAttributor$1.keys(node);
            const styles = StyleAttributor$1.keys(node);
            const formats = {};
            attributes.concat(classes).concat(styles).forEach((name => {
                let attr = scroll.query(name, Scope.ATTRIBUTE);
                if (attr != null) {
                    formats[attr.attrName] = attr.value(node);
                    if (formats[attr.attrName]) return;
                }
                attr = ATTRIBUTE_ATTRIBUTORS[name];
                if (attr != null && (attr.attrName === name || attr.keyName === name)) formats[attr.attrName] = attr.value(node) || void 0;
                attr = STYLE_ATTRIBUTORS[name];
                if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                    attr = STYLE_ATTRIBUTORS[name];
                    formats[attr.attrName] = attr.value(node) || void 0;
                }
            }));
            return Object.entries(formats).reduce(((newDelta, _ref4) => {
                let [name, value] = _ref4;
                return applyFormat(newDelta, name, value, scroll);
            }), delta);
        }
        function matchBlot(node, delta, scroll) {
            const match = scroll.query(node);
            if (match == null) return delta;
            if (match.prototype instanceof EmbedBlot$1) {
                const embed = {};
                const value = match.value(node);
                if (value != null) {
                    embed[match.blotName] = value;
                    return (new Delta).insert(embed, match.formats(node, scroll));
                }
            } else {
                if (match.prototype instanceof BlockBlot$1 && !deltaEndsWith(delta, "\n")) delta.insert("\n");
                if ("blotName" in match && "formats" in match && typeof match.formats === "function") return applyFormat(delta, match.blotName, match.formats(node, scroll), scroll);
            }
            return delta;
        }
        function matchBreak(node, delta) {
            if (!deltaEndsWith(delta, "\n")) delta.insert("\n");
            return delta;
        }
        function matchCodeBlock(node, delta, scroll) {
            const match = scroll.query("code-block");
            const language = match && "formats" in match && typeof match.formats === "function" ? match.formats(node, scroll) : true;
            return applyFormat(delta, "code-block", language, scroll);
        }
        function matchIgnore() {
            return new Delta;
        }
        function matchIndent(node, delta, scroll) {
            const match = scroll.query(node);
            if (match == null || match.blotName !== "list" || !deltaEndsWith(delta, "\n")) return delta;
            let indent = -1;
            let parent = node.parentNode;
            while (parent != null) {
                if ([ "OL", "UL" ].includes(parent.tagName)) indent += 1;
                parent = parent.parentNode;
            }
            if (indent <= 0) return delta;
            return delta.reduce(((composed, op) => {
                if (!op.insert) return composed;
                if (op.attributes && typeof op.attributes.indent === "number") return composed.push(op);
                return composed.insert(op.insert, {
                    indent,
                    ...op.attributes || {}
                });
            }), new Delta);
        }
        function matchList(node, delta, scroll) {
            const element = node;
            let list = element.tagName === "OL" ? "ordered" : "bullet";
            const checkedAttr = element.getAttribute("data-checked");
            if (checkedAttr) list = checkedAttr === "true" ? "checked" : "unchecked";
            return applyFormat(delta, "list", list, scroll);
        }
        function matchNewline(node, delta, scroll) {
            if (!deltaEndsWith(delta, "\n")) {
                if (clipboard_isLine(node, scroll) && (node.childNodes.length > 0 || node instanceof HTMLParagraphElement)) return delta.insert("\n");
                if (delta.length() > 0 && node.nextSibling) {
                    let nextSibling = node.nextSibling;
                    while (nextSibling != null) {
                        if (clipboard_isLine(nextSibling, scroll)) return delta.insert("\n");
                        const match = scroll.query(nextSibling);
                        if (match && match.prototype instanceof BlockEmbed) return delta.insert("\n");
                        nextSibling = nextSibling.firstChild;
                    }
                }
            }
            return delta;
        }
        function matchStyles(node, delta, scroll) {
            const formats = {};
            const style = node.style || {};
            if (style.fontStyle === "italic") formats.italic = true;
            if (style.textDecoration === "underline") formats.underline = true;
            if (style.textDecoration === "line-through") formats.strike = true;
            if (style.fontWeight?.startsWith("bold") || parseInt(style.fontWeight, 10) >= 700) formats.bold = true;
            delta = Object.entries(formats).reduce(((newDelta, _ref5) => {
                let [name, value] = _ref5;
                return applyFormat(newDelta, name, value, scroll);
            }), delta);
            if (parseFloat(style.textIndent || 0) > 0) return (new Delta).insert("\t").concat(delta);
            return delta;
        }
        function matchTable(node, delta, scroll) {
            const table = node.parentElement?.tagName === "TABLE" ? node.parentElement : node.parentElement?.parentElement;
            if (table != null) {
                const rows = Array.from(table.querySelectorAll("tr"));
                const row = rows.indexOf(node) + 1;
                return applyFormat(delta, "table", row, scroll);
            }
            return delta;
        }
        function matchText(node, delta, scroll) {
            let text = node.data;
            if (node.parentElement?.tagName === "O:P") return delta.insert(text.trim());
            if (!isPre(node)) {
                if (text.trim().length === 0 && text.includes("\n") && !isBetweenInlineElements(node, scroll)) return delta;
                const replacer = (collapse, match) => {
                    const replaced = match.replace(/[^\u00a0]/g, "");
                    return replaced.length < 1 && collapse ? " " : replaced;
                };
                text = text.replace(/\r\n/g, " ").replace(/\n/g, " ");
                text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
                if (node.previousSibling == null && node.parentElement != null && clipboard_isLine(node.parentElement, scroll) || node.previousSibling instanceof Element && clipboard_isLine(node.previousSibling, scroll)) text = text.replace(/^\s+/, replacer.bind(replacer, false));
                if (node.nextSibling == null && node.parentElement != null && clipboard_isLine(node.parentElement, scroll) || node.nextSibling instanceof Element && clipboard_isLine(node.nextSibling, scroll)) text = text.replace(/\s+$/, replacer.bind(replacer, false));
            }
            return delta.insert(text);
        }
        class history_History extends core_module {
            static DEFAULTS={
                delay: 1e3,
                maxStack: 100,
                userOnly: false
            };
            lastRecorded=0;
            ignoreChange=false;
            stack={
                undo: [],
                redo: []
            };
            currentRange=null;
            constructor(quill, options) {
                super(quill, options);
                this.quill.on(Quill.events.EDITOR_CHANGE, ((eventName, value, oldValue, source) => {
                    if (eventName === Quill.events.SELECTION_CHANGE) {
                        if (value && source !== Quill.sources.SILENT) this.currentRange = value;
                    } else if (eventName === Quill.events.TEXT_CHANGE) {
                        if (!this.ignoreChange) if (!this.options.userOnly || source === Quill.sources.USER) this.record(value, oldValue); else this.transform(value);
                        this.currentRange = transformRange(this.currentRange, value);
                    }
                }));
                this.quill.keyboard.addBinding({
                    key: "z",
                    shortKey: true
                }, this.undo.bind(this));
                this.quill.keyboard.addBinding({
                    key: [ "z", "Z" ],
                    shortKey: true,
                    shiftKey: true
                }, this.redo.bind(this));
                if (/Win/i.test(navigator.platform)) this.quill.keyboard.addBinding({
                    key: "y",
                    shortKey: true
                }, this.redo.bind(this));
                this.quill.root.addEventListener("beforeinput", (event => {
                    if (event.inputType === "historyUndo") {
                        this.undo();
                        event.preventDefault();
                    } else if (event.inputType === "historyRedo") {
                        this.redo();
                        event.preventDefault();
                    }
                }));
            }
            change(source, dest) {
                if (this.stack[source].length === 0) return;
                const item = this.stack[source].pop();
                if (!item) return;
                const base = this.quill.getContents();
                const inverseDelta = item.delta.invert(base);
                this.stack[dest].push({
                    delta: inverseDelta,
                    range: transformRange(item.range, inverseDelta)
                });
                this.lastRecorded = 0;
                this.ignoreChange = true;
                this.quill.updateContents(item.delta, Quill.sources.USER);
                this.ignoreChange = false;
                this.restoreSelection(item);
            }
            clear() {
                this.stack = {
                    undo: [],
                    redo: []
                };
            }
            cutoff() {
                this.lastRecorded = 0;
            }
            record(changeDelta, oldDelta) {
                if (changeDelta.ops.length === 0) return;
                this.stack.redo = [];
                let undoDelta = changeDelta.invert(oldDelta);
                let undoRange = this.currentRange;
                const timestamp = Date.now();
                if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                    const item = this.stack.undo.pop();
                    if (item) {
                        undoDelta = undoDelta.compose(item.delta);
                        undoRange = item.range;
                    }
                } else this.lastRecorded = timestamp;
                if (undoDelta.length() === 0) return;
                this.stack.undo.push({
                    delta: undoDelta,
                    range: undoRange
                });
                if (this.stack.undo.length > this.options.maxStack) this.stack.undo.shift();
            }
            redo() {
                this.change("redo", "undo");
            }
            transform(delta) {
                transformStack(this.stack.undo, delta);
                transformStack(this.stack.redo, delta);
            }
            undo() {
                this.change("undo", "redo");
            }
            restoreSelection(stackItem) {
                if (stackItem.range) this.quill.setSelection(stackItem.range, Quill.sources.USER); else {
                    const index = getLastChangeIndex(this.quill.scroll, stackItem.delta);
                    this.quill.setSelection(index, Quill.sources.USER);
                }
            }
        }
        function transformStack(stack, delta) {
            let remoteDelta = delta;
            for (let i = stack.length - 1; i >= 0; i -= 1) {
                const oldItem = stack[i];
                stack[i] = {
                    delta: remoteDelta.transform(oldItem.delta, true),
                    range: oldItem.range && transformRange(oldItem.range, remoteDelta)
                };
                remoteDelta = oldItem.delta.transform(remoteDelta);
                if (stack[i].delta.length() === 0) stack.splice(i, 1);
            }
        }
        function endsWithNewlineChange(scroll, delta) {
            const lastOp = delta.ops[delta.ops.length - 1];
            if (lastOp == null) return false;
            if (lastOp.insert != null) return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
            if (lastOp.attributes != null) return Object.keys(lastOp.attributes).some((attr => scroll.query(attr, Scope.BLOCK) != null));
            return false;
        }
        function getLastChangeIndex(scroll, delta) {
            const deleteLength = delta.reduce(((length, op) => length + (op.delete || 0)), 0);
            let changeIndex = delta.length() - deleteLength;
            if (endsWithNewlineChange(scroll, delta)) changeIndex -= 1;
            return changeIndex;
        }
        function transformRange(range, delta) {
            if (!range) return range;
            const start = delta.transformPosition(range.index);
            const end = delta.transformPosition(range.index + range.length);
            return {
                index: start,
                length: end - start
            };
        }
        class Uploader extends core_module {
            constructor(quill, options) {
                super(quill, options);
                quill.root.addEventListener("drop", (e => {
                    e.preventDefault();
                    let native = null;
                    if (document.caretRangeFromPoint) native = document.caretRangeFromPoint(e.clientX, e.clientY); else if (document.caretPositionFromPoint) {
                        const position = document.caretPositionFromPoint(e.clientX, e.clientY);
                        native = document.createRange();
                        native.setStart(position.offsetNode, position.offset);
                        native.setEnd(position.offsetNode, position.offset);
                    }
                    const normalized = native && quill.selection.normalizeNative(native);
                    if (normalized) {
                        const range = quill.selection.normalizedToRange(normalized);
                        if (e.dataTransfer?.files) this.upload(range, e.dataTransfer.files);
                    }
                }));
            }
            upload(range, files) {
                const uploads = [];
                Array.from(files).forEach((file => {
                    if (file && this.options.mimetypes?.includes(file.type)) uploads.push(file);
                }));
                if (uploads.length > 0) this.options.handler.call(this, range, uploads);
            }
        }
        Uploader.DEFAULTS = {
            mimetypes: [ "image/png", "image/jpeg" ],
            handler(range, files) {
                if (!this.quill.scroll.query("image")) return;
                const promises = files.map((file => new Promise((resolve => {
                    const reader = new FileReader;
                    reader.onload = () => {
                        resolve(reader.result);
                    };
                    reader.readAsDataURL(file);
                }))));
                Promise.all(promises).then((images => {
                    const update = images.reduce(((delta, image) => delta.insert({
                        image
                    })), (new Delta).retain(range.index).delete(range.length));
                    this.quill.updateContents(update, core_emitter.sources.USER);
                    this.quill.setSelection(range.index + images.length, core_emitter.sources.SILENT);
                }));
            }
        };
        const uploader = Uploader;
        const INSERT_TYPES = [ "insertText", "insertReplacementText" ];
        class Input extends core_module {
            constructor(quill, options) {
                super(quill, options);
                quill.root.addEventListener("beforeinput", (event => {
                    this.handleBeforeInput(event);
                }));
                if (!/Android/i.test(navigator.userAgent)) quill.on(Quill.events.COMPOSITION_BEFORE_START, (() => {
                    this.handleCompositionStart();
                }));
            }
            deleteRange(range) {
                deleteRange({
                    range,
                    quill: this.quill
                });
            }
            replaceText(range) {
                let text = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                if (range.length === 0) return false;
                if (text) {
                    const formats = this.quill.getFormat(range.index, 1);
                    this.deleteRange(range);
                    this.quill.updateContents((new Delta).retain(range.index).insert(text, formats), Quill.sources.USER);
                } else this.deleteRange(range);
                this.quill.setSelection(range.index + text.length, 0, Quill.sources.SILENT);
                return true;
            }
            handleBeforeInput(event) {
                if (this.quill.composition.isComposing || event.defaultPrevented || !INSERT_TYPES.includes(event.inputType)) return;
                const staticRange = event.getTargetRanges ? event.getTargetRanges()[0] : null;
                if (!staticRange || staticRange.collapsed === true) return;
                const text = getPlainTextFromInputEvent(event);
                if (text == null) return;
                const normalized = this.quill.selection.normalizeNative(staticRange);
                const range = normalized ? this.quill.selection.normalizedToRange(normalized) : null;
                if (range && this.replaceText(range, text)) event.preventDefault();
            }
            handleCompositionStart() {
                const range = this.quill.getSelection();
                if (range) this.replaceText(range);
            }
        }
        function getPlainTextFromInputEvent(event) {
            if (typeof event.data === "string") return event.data;
            if (event.dataTransfer?.types.includes("text/plain")) return event.dataTransfer.getData("text/plain");
            return null;
        }
        const input = Input;
        const isMac = /Mac/i.test(navigator.platform);
        const TTL_FOR_VALID_SELECTION_CHANGE = 100;
        const canMoveCaretBeforeUINode = event => {
            if (event.key === "ArrowLeft" || event.key === "ArrowRight" || event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Home") return true;
            if (isMac && event.key === "a" && event.ctrlKey === true) return true;
            return false;
        };
        class UINode extends core_module {
            isListening=false;
            selectionChangeDeadline=0;
            constructor(quill, options) {
                super(quill, options);
                this.handleArrowKeys();
                this.handleNavigationShortcuts();
            }
            handleArrowKeys() {
                this.quill.keyboard.addBinding({
                    key: [ "ArrowLeft", "ArrowRight" ],
                    offset: 0,
                    shiftKey: null,
                    handler(range, _ref) {
                        let {line, event} = _ref;
                        if (!(line instanceof ParentBlot$1) || !line.uiNode) return true;
                        const isRTL = getComputedStyle(line.domNode)["direction"] === "rtl";
                        if (isRTL && event.key !== "ArrowRight" || !isRTL && event.key !== "ArrowLeft") return true;
                        this.quill.setSelection(range.index - 1, range.length + (event.shiftKey ? 1 : 0), Quill.sources.USER);
                        return false;
                    }
                });
            }
            handleNavigationShortcuts() {
                this.quill.root.addEventListener("keydown", (event => {
                    if (!event.defaultPrevented && canMoveCaretBeforeUINode(event)) this.ensureListeningToSelectionChange();
                }));
            }
            ensureListeningToSelectionChange() {
                this.selectionChangeDeadline = Date.now() + TTL_FOR_VALID_SELECTION_CHANGE;
                if (this.isListening) return;
                this.isListening = true;
                const listener = () => {
                    this.isListening = false;
                    if (Date.now() <= this.selectionChangeDeadline) this.handleSelectionChange();
                };
                document.addEventListener("selectionchange", listener, {
                    once: true
                });
            }
            handleSelectionChange() {
                const selection = document.getSelection();
                if (!selection) return;
                const range = selection.getRangeAt(0);
                if (range.collapsed !== true || range.startOffset !== 0) return;
                const line = this.quill.scroll.find(range.startContainer);
                if (!(line instanceof ParentBlot$1) || !line.uiNode) return;
                const newRange = document.createRange();
                newRange.setStartAfter(line.uiNode);
                newRange.setEndAfter(line.uiNode);
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
        }
        const uiNode = UINode;
        Quill.register({
            "blots/block": Block,
            "blots/block/embed": BlockEmbed,
            "blots/break": blots_break,
            "blots/container": container,
            "blots/cursor": cursor,
            "blots/embed": blots_embed,
            "blots/inline": inline,
            "blots/scroll": blots_scroll,
            "blots/text": text_Text,
            "modules/clipboard": Clipboard,
            "modules/history": history_History,
            "modules/keyboard": keyboard_Keyboard,
            "modules/uploader": uploader,
            "modules/input": input,
            "modules/uiNode": uiNode
        });
        const core = Quill;
        class IndentAttributor extends ClassAttributor$1 {
            add(node, value) {
                let normalizedValue = 0;
                if (value === "+1" || value === "-1") {
                    const indent = this.value(node) || 0;
                    normalizedValue = value === "+1" ? indent + 1 : indent - 1;
                } else if (typeof value === "number") normalizedValue = value;
                if (normalizedValue === 0) {
                    this.remove(node);
                    return true;
                }
                return super.add(node, normalizedValue.toString());
            }
            canAdd(node, value) {
                return super.canAdd(node, value) || super.canAdd(node, parseInt(value, 10));
            }
            value(node) {
                return parseInt(super.value(node), 10) || void 0;
            }
        }
        const IndentClass = new IndentAttributor("indent", "ql-indent", {
            scope: Scope.BLOCK,
            whitelist: [ 1, 2, 3, 4, 5, 6, 7, 8 ]
        });
        const indent = IndentClass;
        class Blockquote extends Block {
            static blotName="blockquote";
            static tagName="blockquote";
        }
        const blockquote = Blockquote;
        class Header extends Block {
            static blotName="header";
            static tagName=[ "H1", "H2", "H3", "H4", "H5", "H6" ];
            static formats(domNode) {
                return this.tagName.indexOf(domNode.tagName) + 1;
            }
        }
        const header = Header;
        class ListContainer extends container {}
        ListContainer.blotName = "list-container";
        ListContainer.tagName = "OL";
        class ListItem extends Block {
            static create(value) {
                const node = super.create();
                node.setAttribute("data-list", value);
                return node;
            }
            static formats(domNode) {
                return domNode.getAttribute("data-list") || void 0;
            }
            static register() {
                Quill.register(ListContainer);
            }
            constructor(scroll, domNode) {
                super(scroll, domNode);
                const ui = domNode.ownerDocument.createElement("span");
                const listEventHandler = e => {
                    if (!scroll.isEnabled()) return;
                    const format = this.statics.formats(domNode, scroll);
                    if (format === "checked") {
                        this.format("list", "unchecked");
                        e.preventDefault();
                    } else if (format === "unchecked") {
                        this.format("list", "checked");
                        e.preventDefault();
                    }
                };
                ui.addEventListener("mousedown", listEventHandler);
                ui.addEventListener("touchstart", listEventHandler);
                this.attachUI(ui);
            }
            format(name, value) {
                if (name === this.statics.blotName && value) this.domNode.setAttribute("data-list", value); else super.format(name, value);
            }
        }
        ListItem.blotName = "list";
        ListItem.tagName = "LI";
        ListContainer.allowedChildren = [ ListItem ];
        ListItem.requiredContainer = ListContainer;
        class Bold extends inline {
            static blotName="bold";
            static tagName=[ "STRONG", "B" ];
            static create() {
                return super.create();
            }
            static formats() {
                return true;
            }
            optimize(context) {
                super.optimize(context);
                if (this.domNode.tagName !== this.statics.tagName[0]) this.replaceWith(this.statics.blotName);
            }
        }
        const bold = Bold;
        class Italic extends bold {
            static blotName="italic";
            static tagName=[ "EM", "I" ];
        }
        const italic = Italic;
        class Link extends inline {
            static blotName="link";
            static tagName="A";
            static SANITIZED_URL="about:blank";
            static PROTOCOL_WHITELIST=[ "http", "https", "mailto", "tel", "sms" ];
            static create(value) {
                const node = super.create(value);
                node.setAttribute("href", this.sanitize(value));
                node.setAttribute("rel", "noopener noreferrer");
                node.setAttribute("target", "_blank");
                return node;
            }
            static formats(domNode) {
                return domNode.getAttribute("href");
            }
            static sanitize(url) {
                return sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
            }
            format(name, value) {
                if (name !== this.statics.blotName || !value) super.format(name, value); else this.domNode.setAttribute("href", this.constructor.sanitize(value));
            }
        }
        function sanitize(url, protocols) {
            const anchor = document.createElement("a");
            anchor.href = url;
            const protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
            return protocols.indexOf(protocol) > -1;
        }
        class Script extends inline {
            static blotName="script";
            static tagName=[ "SUB", "SUP" ];
            static create(value) {
                if (value === "super") return document.createElement("sup");
                if (value === "sub") return document.createElement("sub");
                return super.create(value);
            }
            static formats(domNode) {
                if (domNode.tagName === "SUB") return "sub";
                if (domNode.tagName === "SUP") return "super";
                return;
            }
        }
        const script = Script;
        class Strike extends bold {
            static blotName="strike";
            static tagName=[ "S", "STRIKE" ];
        }
        const strike = Strike;
        class Underline extends inline {
            static blotName="underline";
            static tagName="U";
        }
        const underline = Underline;
        class Formula extends blots_embed {
            static blotName="formula";
            static className="ql-formula";
            static tagName="SPAN";
            static create(value) {
                if (window.katex == null) throw new Error("Formula module requires KaTeX.");
                const node = super.create(value);
                if (typeof value === "string") {
                    window.katex.render(value, node, {
                        throwOnError: false,
                        errorColor: "#f00"
                    });
                    node.setAttribute("data-value", value);
                }
                return node;
            }
            static value(domNode) {
                return domNode.getAttribute("data-value");
            }
            html() {
                const {formula} = this.value();
                return `<span>${formula}</span>`;
            }
        }
        const formula = Formula;
        const ATTRIBUTES = [ "alt", "height", "width" ];
        class image_Image extends EmbedBlot$1 {
            static blotName="image";
            static tagName="IMG";
            static create(value) {
                const node = super.create(value);
                if (typeof value === "string") node.setAttribute("src", this.sanitize(value));
                return node;
            }
            static formats(domNode) {
                return ATTRIBUTES.reduce(((formats, attribute) => {
                    if (domNode.hasAttribute(attribute)) formats[attribute] = domNode.getAttribute(attribute);
                    return formats;
                }), {});
            }
            static match(url) {
                return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
            }
            static sanitize(url) {
                return sanitize(url, [ "http", "https", "data" ]) ? url : "//:0";
            }
            static value(domNode) {
                return domNode.getAttribute("src");
            }
            format(name, value) {
                if (ATTRIBUTES.indexOf(name) > -1) if (value) this.domNode.setAttribute(name, value); else this.domNode.removeAttribute(name); else super.format(name, value);
            }
        }
        const formats_image = image_Image;
        const video_ATTRIBUTES = [ "height", "width" ];
        class Video extends BlockEmbed {
            static blotName="video";
            static className="ql-video";
            static tagName="IFRAME";
            static create(value) {
                const node = super.create(value);
                node.setAttribute("frameborder", "0");
                node.setAttribute("allowfullscreen", "true");
                node.setAttribute("src", this.sanitize(value));
                return node;
            }
            static formats(domNode) {
                return video_ATTRIBUTES.reduce(((formats, attribute) => {
                    if (domNode.hasAttribute(attribute)) formats[attribute] = domNode.getAttribute(attribute);
                    return formats;
                }), {});
            }
            static sanitize(url) {
                return Link.sanitize(url);
            }
            static value(domNode) {
                return domNode.getAttribute("src");
            }
            format(name, value) {
                if (video_ATTRIBUTES.indexOf(name) > -1) if (value) this.domNode.setAttribute(name, value); else this.domNode.removeAttribute(name); else super.format(name, value);
            }
            html() {
                const {video} = this.value();
                return `<a href="${video}">${video}</a>`;
            }
        }
        const video = Video;
        const TokenAttributor = new ClassAttributor$1("code-token", "hljs", {
            scope: Scope.INLINE
        });
        class CodeToken extends inline {
            static formats(node, scroll) {
                while (node != null && node !== scroll.domNode) {
                    if (node.classList && node.classList.contains(CodeBlock.className)) return super.formats(node, scroll);
                    node = node.parentNode;
                }
                return;
            }
            constructor(scroll, domNode, value) {
                super(scroll, domNode, value);
                TokenAttributor.add(this.domNode, value);
            }
            format(format, value) {
                if (format !== CodeToken.blotName) super.format(format, value); else if (value) TokenAttributor.add(this.domNode, value); else {
                    TokenAttributor.remove(this.domNode);
                    this.domNode.classList.remove(this.statics.className);
                }
            }
            optimize() {
                super.optimize(...arguments);
                if (!TokenAttributor.value(this.domNode)) this.unwrap();
            }
        }
        CodeToken.blotName = "code-token";
        CodeToken.className = "ql-token";
        class SyntaxCodeBlock extends CodeBlock {
            static create(value) {
                const domNode = super.create(value);
                if (typeof value === "string") domNode.setAttribute("data-language", value);
                return domNode;
            }
            static formats(domNode) {
                return domNode.getAttribute("data-language") || "plain";
            }
            static register() {}
            format(name, value) {
                if (name === this.statics.blotName && value) this.domNode.setAttribute("data-language", value); else super.format(name, value);
            }
            replaceWith(name, value) {
                this.formatAt(0, this.length(), CodeToken.blotName, false);
                return super.replaceWith(name, value);
            }
        }
        class SyntaxCodeBlockContainer extends CodeBlockContainer {
            attach() {
                super.attach();
                this.forceNext = false;
                this.scroll.emitMount(this);
            }
            format(name, value) {
                if (name === SyntaxCodeBlock.blotName) {
                    this.forceNext = true;
                    this.children.forEach((child => {
                        child.format(name, value);
                    }));
                }
            }
            formatAt(index, length, name, value) {
                if (name === SyntaxCodeBlock.blotName) this.forceNext = true;
                super.formatAt(index, length, name, value);
            }
            highlight(highlight) {
                let forced = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (this.children.head == null) return;
                const nodes = Array.from(this.domNode.childNodes).filter((node => node !== this.uiNode));
                const text = `${nodes.map((node => node.textContent)).join("\n")}\n`;
                const language = SyntaxCodeBlock.formats(this.children.head.domNode);
                if (forced || this.forceNext || this.cachedText !== text) {
                    if (text.trim().length > 0 || this.cachedText == null) {
                        const oldDelta = this.children.reduce(((delta, child) => delta.concat(blockDelta(child, false))), new Delta);
                        const delta = highlight(text, language);
                        oldDelta.diff(delta).reduce(((index, _ref) => {
                            let {retain, attributes} = _ref;
                            if (!retain) return index;
                            if (attributes) Object.keys(attributes).forEach((format => {
                                if ([ SyntaxCodeBlock.blotName, CodeToken.blotName ].includes(format)) this.formatAt(index, retain, format, attributes[format]);
                            }));
                            return index + retain;
                        }), 0);
                    }
                    this.cachedText = text;
                    this.forceNext = false;
                }
            }
            html(index, length) {
                const [codeBlock] = this.children.find(index);
                const language = codeBlock ? SyntaxCodeBlock.formats(codeBlock.domNode) : "plain";
                return `<pre data-language="${language}">\n${escapeText(this.code(index, length))}\n</pre>`;
            }
            optimize(context) {
                super.optimize(context);
                if (this.parent != null && this.children.head != null && this.uiNode != null) {
                    const language = SyntaxCodeBlock.formats(this.children.head.domNode);
                    if (language !== this.uiNode.value) this.uiNode.value = language;
                }
            }
        }
        SyntaxCodeBlockContainer.allowedChildren = [ SyntaxCodeBlock ];
        SyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;
        SyntaxCodeBlock.allowedChildren = [ CodeToken, cursor, text_Text, blots_break ];
        const highlight = (lib, language, text) => {
            if (typeof lib.versionString === "string") {
                const majorVersion = lib.versionString.split(".")[0];
                if (parseInt(majorVersion, 10) >= 11) return lib.highlight(text, {
                    language
                }).value;
            }
            return lib.highlight(language, text).value;
        };
        class Syntax extends core_module {
            static register() {
                Quill.register(CodeToken, true);
                Quill.register(SyntaxCodeBlock, true);
                Quill.register(SyntaxCodeBlockContainer, true);
            }
            constructor(quill, options) {
                super(quill, options);
                if (this.options.hljs == null) throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
                this.languages = this.options.languages.reduce(((memo, _ref2) => {
                    let {key} = _ref2;
                    memo[key] = true;
                    return memo;
                }), {});
                this.highlightBlot = this.highlightBlot.bind(this);
                this.initListener();
                this.initTimer();
            }
            initListener() {
                this.quill.on(Quill.events.SCROLL_BLOT_MOUNT, (blot => {
                    if (!(blot instanceof SyntaxCodeBlockContainer)) return;
                    const select = this.quill.root.ownerDocument.createElement("select");
                    this.options.languages.forEach((_ref3 => {
                        let {key, label} = _ref3;
                        const option = select.ownerDocument.createElement("option");
                        option.textContent = label;
                        option.setAttribute("value", key);
                        select.appendChild(option);
                    }));
                    select.addEventListener("change", (() => {
                        blot.format(SyntaxCodeBlock.blotName, select.value);
                        this.quill.root.focus();
                        this.highlight(blot, true);
                    }));
                    if (blot.uiNode == null) {
                        blot.attachUI(select);
                        if (blot.children.head) select.value = SyntaxCodeBlock.formats(blot.children.head.domNode);
                    }
                }));
            }
            initTimer() {
                let timer = null;
                this.quill.on(Quill.events.SCROLL_OPTIMIZE, (() => {
                    if (timer) clearTimeout(timer);
                    timer = setTimeout((() => {
                        this.highlight();
                        timer = null;
                    }), this.options.interval);
                }));
            }
            highlight() {
                let blot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (this.quill.selection.composing) return;
                this.quill.update(Quill.sources.USER);
                const range = this.quill.getSelection();
                const blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [ blot ];
                blots.forEach((container => {
                    container.highlight(this.highlightBlot, force);
                }));
                this.quill.update(Quill.sources.SILENT);
                if (range != null) this.quill.setSelection(range, Quill.sources.SILENT);
            }
            highlightBlot(text) {
                let language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
                language = this.languages[language] ? language : "plain";
                if (language === "plain") return escapeText(text).split("\n").reduce(((delta, line, i) => {
                    if (i !== 0) delta.insert("\n", {
                        [CodeBlock.blotName]: language
                    });
                    return delta.insert(line);
                }), new Delta);
                const container = this.quill.root.ownerDocument.createElement("div");
                container.classList.add(CodeBlock.className);
                container.innerHTML = highlight(this.options.hljs, language, text);
                return traverse(this.quill.scroll, container, [ (node, delta) => {
                    const value = TokenAttributor.value(node);
                    if (value) return delta.compose((new Delta).retain(delta.length(), {
                        [CodeToken.blotName]: value
                    }));
                    return delta;
                } ], [ (node, delta) => node.data.split("\n").reduce(((memo, nodeText, i) => {
                    if (i !== 0) memo.insert("\n", {
                        [CodeBlock.blotName]: language
                    });
                    return memo.insert(nodeText);
                }), delta) ], new WeakMap);
            }
        }
        Syntax.DEFAULTS = {
            hljs: (() => window.hljs)(),
            interval: 1e3,
            languages: [ {
                key: "plain",
                label: "Plain"
            }, {
                key: "bash",
                label: "Bash"
            }, {
                key: "cpp",
                label: "C++"
            }, {
                key: "cs",
                label: "C#"
            }, {
                key: "css",
                label: "CSS"
            }, {
                key: "diff",
                label: "Diff"
            }, {
                key: "xml",
                label: "HTML/XML"
            }, {
                key: "java",
                label: "Java"
            }, {
                key: "javascript",
                label: "JavaScript"
            }, {
                key: "markdown",
                label: "Markdown"
            }, {
                key: "php",
                label: "PHP"
            }, {
                key: "python",
                label: "Python"
            }, {
                key: "ruby",
                label: "Ruby"
            }, {
                key: "sql",
                label: "SQL"
            } ]
        };
        class TableCell extends Block {
            static blotName="table";
            static tagName="TD";
            static create(value) {
                const node = super.create();
                if (value) node.setAttribute("data-row", value); else node.setAttribute("data-row", tableId());
                return node;
            }
            static formats(domNode) {
                if (domNode.hasAttribute("data-row")) return domNode.getAttribute("data-row");
                return;
            }
            cellOffset() {
                if (this.parent) return this.parent.children.indexOf(this);
                return -1;
            }
            format(name, value) {
                if (name === TableCell.blotName && value) this.domNode.setAttribute("data-row", value); else super.format(name, value);
            }
            row() {
                return this.parent;
            }
            rowOffset() {
                if (this.row()) return this.row().rowOffset();
                return -1;
            }
            table() {
                return this.row() && this.row().table();
            }
        }
        class TableRow extends container {
            static blotName="table-row";
            static tagName="TR";
            checkMerge() {
                if (super.checkMerge() && this.next.children.head != null) {
                    const thisHead = this.children.head.formats();
                    const thisTail = this.children.tail.formats();
                    const nextHead = this.next.children.head.formats();
                    const nextTail = this.next.children.tail.formats();
                    return thisHead.table === thisTail.table && thisHead.table === nextHead.table && thisHead.table === nextTail.table;
                }
                return false;
            }
            optimize(context) {
                super.optimize(context);
                this.children.forEach((child => {
                    if (child.next == null) return;
                    const childFormats = child.formats();
                    const nextFormats = child.next.formats();
                    if (childFormats.table !== nextFormats.table) {
                        const next = this.splitAfter(child);
                        if (next) next.optimize();
                        if (this.prev) this.prev.optimize();
                    }
                }));
            }
            rowOffset() {
                if (this.parent) return this.parent.children.indexOf(this);
                return -1;
            }
            table() {
                return this.parent && this.parent.parent;
            }
        }
        class TableBody extends container {
            static blotName="table-body";
            static tagName="TBODY";
        }
        class TableContainer extends container {
            static blotName="table-container";
            static tagName="TABLE";
            balanceCells() {
                const rows = this.descendants(TableRow);
                const maxColumns = rows.reduce(((max, row) => Math.max(row.children.length, max)), 0);
                rows.forEach((row => {
                    new Array(maxColumns - row.children.length).fill(0).forEach((() => {
                        let value;
                        if (row.children.head != null) value = TableCell.formats(row.children.head.domNode);
                        const blot = this.scroll.create(TableCell.blotName, value);
                        row.appendChild(blot);
                        blot.optimize();
                    }));
                }));
            }
            cells(column) {
                return this.rows().map((row => row.children.at(column)));
            }
            deleteColumn(index) {
                const [body] = this.descendant(TableBody);
                if (body == null || body.children.head == null) return;
                body.children.forEach((row => {
                    const cell = row.children.at(index);
                    if (cell != null) cell.remove();
                }));
            }
            insertColumn(index) {
                const [body] = this.descendant(TableBody);
                if (body == null || body.children.head == null) return;
                body.children.forEach((row => {
                    const ref = row.children.at(index);
                    const value = TableCell.formats(row.children.head.domNode);
                    const cell = this.scroll.create(TableCell.blotName, value);
                    row.insertBefore(cell, ref);
                }));
            }
            insertRow(index) {
                const [body] = this.descendant(TableBody);
                if (body == null || body.children.head == null) return;
                const id = tableId();
                const row = this.scroll.create(TableRow.blotName);
                body.children.head.children.forEach((() => {
                    const cell = this.scroll.create(TableCell.blotName, id);
                    row.appendChild(cell);
                }));
                const ref = body.children.at(index);
                body.insertBefore(row, ref);
            }
            rows() {
                const body = this.children.head;
                if (body == null) return [];
                return body.children.map((row => row));
            }
        }
        TableContainer.allowedChildren = [ TableBody ];
        TableBody.requiredContainer = TableContainer;
        TableBody.allowedChildren = [ TableRow ];
        TableRow.requiredContainer = TableBody;
        TableRow.allowedChildren = [ TableCell ];
        TableCell.requiredContainer = TableRow;
        function tableId() {
            const id = Math.random().toString(36).slice(2, 6);
            return `row-${id}`;
        }
        class Table extends core_module {
            static register() {
                Quill.register(TableCell);
                Quill.register(TableRow);
                Quill.register(TableBody);
                Quill.register(TableContainer);
            }
            constructor() {
                super(...arguments);
                this.listenBalanceCells();
            }
            balanceTables() {
                this.quill.scroll.descendants(TableContainer).forEach((table => {
                    table.balanceCells();
                }));
            }
            deleteColumn() {
                const [table, , cell] = this.getTable();
                if (cell == null) return;
                table.deleteColumn(cell.cellOffset());
                this.quill.update(Quill.sources.USER);
            }
            deleteRow() {
                const [, row] = this.getTable();
                if (row == null) return;
                row.remove();
                this.quill.update(Quill.sources.USER);
            }
            deleteTable() {
                const [table] = this.getTable();
                if (table == null) return;
                const offset = table.offset();
                table.remove();
                this.quill.update(Quill.sources.USER);
                this.quill.setSelection(offset, Quill.sources.SILENT);
            }
            getTable() {
                let range = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.quill.getSelection();
                if (range == null) return [ null, null, null, -1 ];
                const [cell, offset] = this.quill.getLine(range.index);
                if (cell == null || cell.statics.blotName !== TableCell.blotName) return [ null, null, null, -1 ];
                const row = cell.parent;
                const table = row.parent.parent;
                return [ table, row, cell, offset ];
            }
            insertColumn(offset) {
                const range = this.quill.getSelection();
                if (!range) return;
                const [table, row, cell] = this.getTable(range);
                if (cell == null) return;
                const column = cell.cellOffset();
                table.insertColumn(column + offset);
                this.quill.update(Quill.sources.USER);
                let shift = row.rowOffset();
                if (offset === 0) shift += 1;
                this.quill.setSelection(range.index + shift, range.length, Quill.sources.SILENT);
            }
            insertColumnLeft() {
                this.insertColumn(0);
            }
            insertColumnRight() {
                this.insertColumn(1);
            }
            insertRow(offset) {
                const range = this.quill.getSelection();
                if (!range) return;
                const [table, row, cell] = this.getTable(range);
                if (cell == null) return;
                const index = row.rowOffset();
                table.insertRow(index + offset);
                this.quill.update(Quill.sources.USER);
                if (offset > 0) this.quill.setSelection(range, Quill.sources.SILENT); else this.quill.setSelection(range.index + row.children.length, range.length, Quill.sources.SILENT);
            }
            insertRowAbove() {
                this.insertRow(0);
            }
            insertRowBelow() {
                this.insertRow(1);
            }
            insertTable(rows, columns) {
                const range = this.quill.getSelection();
                if (range == null) return;
                const delta = new Array(rows).fill(0).reduce((memo => {
                    const text = new Array(columns).fill("\n").join("");
                    return memo.insert(text, {
                        table: tableId()
                    });
                }), (new Delta).retain(range.index));
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(range.index, Quill.sources.SILENT);
                this.balanceTables();
            }
            listenBalanceCells() {
                this.quill.on(Quill.events.SCROLL_OPTIMIZE, (mutations => {
                    mutations.some((mutation => {
                        if ([ "TD", "TR", "TBODY", "TABLE" ].includes(mutation.target.tagName)) {
                            this.quill.once(Quill.events.TEXT_CHANGE, ((delta, old, source) => {
                                if (source !== Quill.sources.USER) return;
                                this.balanceTables();
                            }));
                            return true;
                        }
                        return false;
                    }));
                }));
            }
        }
        const table = Table;
        const toolbar_debug = logger("quill:toolbar");
        class Toolbar extends core_module {
            constructor(quill, options) {
                super(quill, options);
                if (Array.isArray(this.options.container)) {
                    const container = document.createElement("div");
                    container.setAttribute("role", "toolbar");
                    addControls(container, this.options.container);
                    quill.container?.parentNode?.insertBefore(container, quill.container);
                    this.container = container;
                } else if (typeof this.options.container === "string") this.container = document.querySelector(this.options.container); else this.container = this.options.container;
                if (!(this.container instanceof HTMLElement)) {
                    toolbar_debug.error("Container required for toolbar", this.options);
                    return;
                }
                this.container.classList.add("ql-toolbar");
                this.controls = [];
                this.handlers = {};
                if (this.options.handlers) Object.keys(this.options.handlers).forEach((format => {
                    const handler = this.options.handlers?.[format];
                    if (handler) this.addHandler(format, handler);
                }));
                Array.from(this.container.querySelectorAll("button, select")).forEach((input => {
                    this.attach(input);
                }));
                this.quill.on(Quill.events.EDITOR_CHANGE, (() => {
                    const [range] = this.quill.selection.getRange();
                    this.update(range);
                }));
            }
            addHandler(format, handler) {
                this.handlers[format] = handler;
            }
            attach(input) {
                let format = Array.from(input.classList).find((className => className.indexOf("ql-") === 0));
                if (!format) return;
                format = format.slice("ql-".length);
                if (input.tagName === "BUTTON") input.setAttribute("type", "button");
                if (this.handlers[format] == null && this.quill.scroll.query(format) == null) {
                    toolbar_debug.warn("ignoring attaching to nonexistent format", format, input);
                    return;
                }
                const eventName = input.tagName === "SELECT" ? "change" : "click";
                input.addEventListener(eventName, (e => {
                    let value;
                    if (input.tagName === "SELECT") {
                        if (input.selectedIndex < 0) return;
                        const selected = input.options[input.selectedIndex];
                        if (selected.hasAttribute("selected")) value = false; else value = selected.value || false;
                    } else {
                        if (input.classList.contains("ql-active")) value = false; else value = input.value || !input.hasAttribute("value");
                        e.preventDefault();
                    }
                    this.quill.focus();
                    const [range] = this.quill.selection.getRange();
                    if (this.handlers[format] != null) this.handlers[format].call(this, value); else if (this.quill.scroll.query(format).prototype instanceof EmbedBlot$1) {
                        value = prompt(`Enter ${format}`);
                        if (!value) return;
                        this.quill.updateContents((new Delta).retain(range.index).delete(range.length).insert({
                            [format]: value
                        }), Quill.sources.USER);
                    } else this.quill.format(format, value, Quill.sources.USER);
                    this.update(range);
                }));
                this.controls.push([ format, input ]);
            }
            update(range) {
                const formats = range == null ? {} : this.quill.getFormat(range);
                this.controls.forEach((pair => {
                    const [format, input] = pair;
                    if (input.tagName === "SELECT") {
                        let option = null;
                        if (range == null) option = null; else if (formats[format] == null) option = input.querySelector("option[selected]"); else if (!Array.isArray(formats[format])) {
                            let value = formats[format];
                            if (typeof value === "string") value = value.replace(/"/g, '\\"');
                            option = input.querySelector(`option[value="${value}"]`);
                        }
                        if (option == null) {
                            input.value = "";
                            input.selectedIndex = -1;
                        } else option.selected = true;
                    } else if (range == null) {
                        input.classList.remove("ql-active");
                        input.setAttribute("aria-pressed", "false");
                    } else if (input.hasAttribute("value")) {
                        const value = formats[format];
                        const isActive = value === input.getAttribute("value") || value != null && value.toString() === input.getAttribute("value") || value == null && !input.getAttribute("value");
                        input.classList.toggle("ql-active", isActive);
                        input.setAttribute("aria-pressed", isActive.toString());
                    } else {
                        const isActive = formats[format] != null;
                        input.classList.toggle("ql-active", isActive);
                        input.setAttribute("aria-pressed", isActive.toString());
                    }
                }));
            }
        }
        Toolbar.DEFAULTS = {};
        function addButton(container, format, value) {
            const input = document.createElement("button");
            input.setAttribute("type", "button");
            input.classList.add(`ql-${format}`);
            input.setAttribute("aria-pressed", "false");
            if (value != null) {
                input.value = value;
                input.setAttribute("aria-label", `${format}: ${value}`);
            } else input.setAttribute("aria-label", format);
            container.appendChild(input);
        }
        function addControls(container, groups) {
            if (!Array.isArray(groups[0])) groups = [ groups ];
            groups.forEach((controls => {
                const group = document.createElement("span");
                group.classList.add("ql-formats");
                controls.forEach((control => {
                    if (typeof control === "string") addButton(group, control); else {
                        const format = Object.keys(control)[0];
                        const value = control[format];
                        if (Array.isArray(value)) addSelect(group, format, value); else addButton(group, format, value);
                    }
                }));
                container.appendChild(group);
            }));
        }
        function addSelect(container, format, values) {
            const input = document.createElement("select");
            input.classList.add(`ql-${format}`);
            values.forEach((value => {
                const option = document.createElement("option");
                if (value !== false) option.setAttribute("value", String(value)); else option.setAttribute("selected", "selected");
                input.appendChild(option);
            }));
            container.appendChild(input);
        }
        Toolbar.DEFAULTS = {
            container: null,
            handlers: {
                clean() {
                    const range = this.quill.getSelection();
                    if (range == null) return;
                    if (range.length === 0) {
                        const formats = this.quill.getFormat();
                        Object.keys(formats).forEach((name => {
                            if (this.quill.scroll.query(name, Scope.INLINE) != null) this.quill.format(name, false, Quill.sources.USER);
                        }));
                    } else this.quill.removeFormat(range.index, range.length, Quill.sources.USER);
                },
                direction(value) {
                    const {align} = this.quill.getFormat();
                    if (value === "rtl" && align == null) this.quill.format("align", "right", Quill.sources.USER); else if (!value && align === "right") this.quill.format("align", false, Quill.sources.USER);
                    this.quill.format("direction", value, Quill.sources.USER);
                },
                indent(value) {
                    const range = this.quill.getSelection();
                    const formats = this.quill.getFormat(range);
                    const indent = parseInt(formats.indent || 0, 10);
                    if (value === "+1" || value === "-1") {
                        let modifier = value === "+1" ? 1 : -1;
                        if (formats.direction === "rtl") modifier *= -1;
                        this.quill.format("indent", indent + modifier, Quill.sources.USER);
                    }
                },
                link(value) {
                    if (value === true) value = prompt("Enter link URL:");
                    this.quill.format("link", value, Quill.sources.USER);
                },
                list(value) {
                    const range = this.quill.getSelection();
                    const formats = this.quill.getFormat(range);
                    if (value === "check") if (formats.list === "checked" || formats.list === "unchecked") this.quill.format("list", false, Quill.sources.USER); else this.quill.format("list", "unchecked", Quill.sources.USER); else this.quill.format("list", value, Quill.sources.USER);
                }
            }
        };
        const alignLeftIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>';
        const alignCenterIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>';
        const alignRightIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>';
        const alignJustifyIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>';
        const backgroundIcon = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>';
        const blockquoteIcon = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>';
        const boldIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>';
        const cleanIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>';
        const codeIcon = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>';
        const colorIcon = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>';
        const directionLeftToRightIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>';
        const directionRightToLeftIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>';
        const formulaIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>';
        const headerIcon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>';
        const header2Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
        const header3Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
        const header4Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>';
        const header5Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
        const header6Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>';
        const italicIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>';
        const imageIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>';
        const indentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>';
        const outdentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>';
        const linkIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>';
        const listBulletIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>';
        const listCheckIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>';
        const listOrderedIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>';
        const subscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>';
        const superscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>';
        const strikeIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>';
        const tableIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>';
        const underlineIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>';
        const videoIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>';
        const icons = {
            align: {
                "": alignLeftIcon,
                center: alignCenterIcon,
                right: alignRightIcon,
                justify: alignJustifyIcon
            },
            background: backgroundIcon,
            blockquote: blockquoteIcon,
            bold: boldIcon,
            clean: cleanIcon,
            code: codeIcon,
            "code-block": codeIcon,
            color: colorIcon,
            direction: {
                "": directionLeftToRightIcon,
                rtl: directionRightToLeftIcon
            },
            formula: formulaIcon,
            header: {
                1: headerIcon,
                2: header2Icon,
                3: header3Icon,
                4: header4Icon,
                5: header5Icon,
                6: header6Icon
            },
            italic: italicIcon,
            image: imageIcon,
            indent: {
                "+1": indentIcon,
                "-1": outdentIcon
            },
            link: linkIcon,
            list: {
                bullet: listBulletIcon,
                check: listCheckIcon,
                ordered: listOrderedIcon
            },
            script: {
                sub: subscriptIcon,
                super: superscriptIcon
            },
            strike: strikeIcon,
            table: tableIcon,
            underline: underlineIcon,
            video: videoIcon
        };
        const DropdownIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
        let optionsCounter = 0;
        function toggleAriaAttribute(element, attribute) {
            element.setAttribute(attribute, `${!(element.getAttribute(attribute) === "true")}`);
        }
        class Picker {
            constructor(select) {
                this.select = select;
                this.container = document.createElement("span");
                this.buildPicker();
                this.select.style.display = "none";
                this.select.parentNode.insertBefore(this.container, this.select);
                this.label.addEventListener("mousedown", (() => {
                    this.togglePicker();
                }));
                this.label.addEventListener("keydown", (event => {
                    switch (event.key) {
                      case "Enter":
                        this.togglePicker();
                        break;

                      case "Escape":
                        this.escape();
                        event.preventDefault();
                        break;

                      default:
                    }
                }));
                this.select.addEventListener("change", this.update.bind(this));
            }
            togglePicker() {
                this.container.classList.toggle("ql-expanded");
                toggleAriaAttribute(this.label, "aria-expanded");
                toggleAriaAttribute(this.options, "aria-hidden");
            }
            buildItem(option) {
                const item = document.createElement("span");
                item.tabIndex = "0";
                item.setAttribute("role", "button");
                item.classList.add("ql-picker-item");
                const value = option.getAttribute("value");
                if (value) item.setAttribute("data-value", value);
                if (option.textContent) item.setAttribute("data-label", option.textContent);
                item.addEventListener("click", (() => {
                    this.selectItem(item, true);
                }));
                item.addEventListener("keydown", (event => {
                    switch (event.key) {
                      case "Enter":
                        this.selectItem(item, true);
                        event.preventDefault();
                        break;

                      case "Escape":
                        this.escape();
                        event.preventDefault();
                        break;

                      default:
                    }
                }));
                return item;
            }
            buildLabel() {
                const label = document.createElement("span");
                label.classList.add("ql-picker-label");
                label.innerHTML = DropdownIcon;
                label.tabIndex = "0";
                label.setAttribute("role", "button");
                label.setAttribute("aria-expanded", "false");
                this.container.appendChild(label);
                return label;
            }
            buildOptions() {
                const options = document.createElement("span");
                options.classList.add("ql-picker-options");
                options.setAttribute("aria-hidden", "true");
                options.tabIndex = "-1";
                options.id = `ql-picker-options-${optionsCounter}`;
                optionsCounter += 1;
                this.label.setAttribute("aria-controls", options.id);
                this.options = options;
                Array.from(this.select.options).forEach((option => {
                    const item = this.buildItem(option);
                    options.appendChild(item);
                    if (option.selected === true) this.selectItem(item);
                }));
                this.container.appendChild(options);
            }
            buildPicker() {
                Array.from(this.select.attributes).forEach((item => {
                    this.container.setAttribute(item.name, item.value);
                }));
                this.container.classList.add("ql-picker");
                this.label = this.buildLabel();
                this.buildOptions();
            }
            escape() {
                this.close();
                setTimeout((() => this.label.focus()), 1);
            }
            close() {
                this.container.classList.remove("ql-expanded");
                this.label.setAttribute("aria-expanded", "false");
                this.options.setAttribute("aria-hidden", "true");
            }
            selectItem(item) {
                let trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                const selected = this.container.querySelector(".ql-selected");
                if (item === selected) return;
                if (selected != null) selected.classList.remove("ql-selected");
                if (item == null) return;
                item.classList.add("ql-selected");
                this.select.selectedIndex = Array.from(item.parentNode.children).indexOf(item);
                if (item.hasAttribute("data-value")) this.label.setAttribute("data-value", item.getAttribute("data-value")); else this.label.removeAttribute("data-value");
                if (item.hasAttribute("data-label")) this.label.setAttribute("data-label", item.getAttribute("data-label")); else this.label.removeAttribute("data-label");
                if (trigger) {
                    this.select.dispatchEvent(new Event("change"));
                    this.close();
                }
            }
            update() {
                let option;
                if (this.select.selectedIndex > -1) {
                    const item = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                    option = this.select.options[this.select.selectedIndex];
                    this.selectItem(item);
                } else this.selectItem(null);
                const isActive = option != null && option !== this.select.querySelector("option[selected]");
                this.label.classList.toggle("ql-active", isActive);
            }
        }
        const picker = Picker;
        class ColorPicker extends picker {
            constructor(select, label) {
                super(select);
                this.label.innerHTML = label;
                this.container.classList.add("ql-color-picker");
                Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((item => {
                    item.classList.add("ql-primary");
                }));
            }
            buildItem(option) {
                const item = super.buildItem(option);
                item.style.backgroundColor = option.getAttribute("value") || "";
                return item;
            }
            selectItem(item, trigger) {
                super.selectItem(item, trigger);
                const colorLabel = this.label.querySelector(".ql-color-label");
                const value = item ? item.getAttribute("data-value") || "" : "";
                if (colorLabel) if (colorLabel.tagName === "line") colorLabel.style.stroke = value; else colorLabel.style.fill = value;
            }
        }
        const color_picker = ColorPicker;
        class IconPicker extends picker {
            constructor(select, icons) {
                super(select);
                this.container.classList.add("ql-icon-picker");
                Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((item => {
                    item.innerHTML = icons[item.getAttribute("data-value") || ""];
                }));
                this.defaultItem = this.container.querySelector(".ql-selected");
                this.selectItem(this.defaultItem);
            }
            selectItem(target, trigger) {
                super.selectItem(target, trigger);
                const item = target || this.defaultItem;
                if (item != null) {
                    if (this.label.innerHTML === item.innerHTML) return;
                    this.label.innerHTML = item.innerHTML;
                }
            }
        }
        const icon_picker = IconPicker;
        const isScrollable = el => {
            const {overflowY} = getComputedStyle(el, null);
            return overflowY !== "visible" && overflowY !== "clip";
        };
        class Tooltip {
            constructor(quill, boundsContainer) {
                this.quill = quill;
                this.boundsContainer = boundsContainer || document.body;
                this.root = quill.addContainer("ql-tooltip");
                this.root.innerHTML = this.constructor.TEMPLATE;
                if (isScrollable(this.quill.root)) this.quill.root.addEventListener("scroll", (() => {
                    this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
                }));
                this.hide();
            }
            hide() {
                this.root.classList.add("ql-hidden");
            }
            position(reference) {
                const left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                const top = reference.bottom + this.quill.root.scrollTop;
                this.root.style.left = `${left}px`;
                this.root.style.top = `${top}px`;
                this.root.classList.remove("ql-flip");
                const containerBounds = this.boundsContainer.getBoundingClientRect();
                const rootBounds = this.root.getBoundingClientRect();
                let shift = 0;
                if (rootBounds.right > containerBounds.right) {
                    shift = containerBounds.right - rootBounds.right;
                    this.root.style.left = `${left + shift}px`;
                }
                if (rootBounds.left < containerBounds.left) {
                    shift = containerBounds.left - rootBounds.left;
                    this.root.style.left = `${left + shift}px`;
                }
                if (rootBounds.bottom > containerBounds.bottom) {
                    const height = rootBounds.bottom - rootBounds.top;
                    const verticalShift = reference.bottom - reference.top + height;
                    this.root.style.top = `${top - verticalShift}px`;
                    this.root.classList.add("ql-flip");
                }
                return shift;
            }
            show() {
                this.root.classList.remove("ql-editing");
                this.root.classList.remove("ql-hidden");
            }
        }
        const tooltip = Tooltip;
        const ALIGNS = [ false, "center", "right", "justify" ];
        const COLORS = [ "#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466" ];
        const FONTS = [ false, "serif", "monospace" ];
        const HEADERS = [ "1", "2", "3", false ];
        const SIZES = [ "small", false, "large", "huge" ];
        class BaseTheme extends core_theme {
            constructor(quill, options) {
                super(quill, options);
                const listener = e => {
                    if (!document.body.contains(quill.root)) {
                        document.body.removeEventListener("click", listener);
                        return;
                    }
                    if (this.tooltip != null && !this.tooltip.root.contains(e.target) && document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus()) this.tooltip.hide();
                    if (this.pickers != null) this.pickers.forEach((picker => {
                        if (!picker.container.contains(e.target)) picker.close();
                    }));
                };
                quill.emitter.listenDOM("click", document.body, listener);
            }
            addModule(name) {
                const module = super.addModule(name);
                if (name === "toolbar") this.extendToolbar(module);
                return module;
            }
            buildButtons(buttons, icons) {
                Array.from(buttons).forEach((button => {
                    const className = button.getAttribute("class") || "";
                    className.split(/\s+/).forEach((name => {
                        if (!name.startsWith("ql-")) return;
                        name = name.slice("ql-".length);
                        if (icons[name] == null) return;
                        if (name === "direction") button.innerHTML = icons[name][""] + icons[name].rtl; else if (typeof icons[name] === "string") button.innerHTML = icons[name]; else {
                            const value = button.value || "";
                            if (value != null && icons[name][value]) button.innerHTML = icons[name][value];
                        }
                    }));
                }));
            }
            buildPickers(selects, icons) {
                this.pickers = Array.from(selects).map((select => {
                    if (select.classList.contains("ql-align")) {
                        if (select.querySelector("option") == null) fillSelect(select, ALIGNS);
                        if (typeof icons.align === "object") return new icon_picker(select, icons.align);
                    }
                    if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
                        const format = select.classList.contains("ql-background") ? "background" : "color";
                        if (select.querySelector("option") == null) fillSelect(select, COLORS, format === "background" ? "#ffffff" : "#000000");
                        return new color_picker(select, icons[format]);
                    }
                    if (select.querySelector("option") == null) if (select.classList.contains("ql-font")) fillSelect(select, FONTS); else if (select.classList.contains("ql-header")) fillSelect(select, HEADERS); else if (select.classList.contains("ql-size")) fillSelect(select, SIZES);
                    return new picker(select);
                }));
                const update = () => {
                    this.pickers.forEach((picker => {
                        picker.update();
                    }));
                };
                this.quill.on(core_emitter.events.EDITOR_CHANGE, update);
            }
        }
        BaseTheme.DEFAULTS = lodash_es_merge({}, core_theme.DEFAULTS, {
            modules: {
                toolbar: {
                    handlers: {
                        formula() {
                            this.quill.theme.tooltip.edit("formula");
                        },
                        image() {
                            let fileInput = this.container.querySelector("input.ql-image[type=file]");
                            if (fileInput == null) {
                                fileInput = document.createElement("input");
                                fileInput.setAttribute("type", "file");
                                fileInput.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", "));
                                fileInput.classList.add("ql-image");
                                fileInput.addEventListener("change", (() => {
                                    const range = this.quill.getSelection(true);
                                    this.quill.uploader.upload(range, fileInput.files);
                                    fileInput.value = "";
                                }));
                                this.container.appendChild(fileInput);
                            }
                            fileInput.click();
                        },
                        video() {
                            this.quill.theme.tooltip.edit("video");
                        }
                    }
                }
            }
        });
        class BaseTooltip extends tooltip {
            constructor(quill, boundsContainer) {
                super(quill, boundsContainer);
                this.textbox = this.root.querySelector('input[type="text"]');
                this.listen();
            }
            listen() {
                this.textbox.addEventListener("keydown", (event => {
                    if (event.key === "Enter") {
                        this.save();
                        event.preventDefault();
                    } else if (event.key === "Escape") {
                        this.cancel();
                        event.preventDefault();
                    }
                }));
            }
            cancel() {
                this.hide();
                this.restoreFocus();
            }
            edit() {
                let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
                let preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                this.root.classList.remove("ql-hidden");
                this.root.classList.add("ql-editing");
                if (this.textbox == null) return;
                if (preview != null) this.textbox.value = preview; else if (mode !== this.root.getAttribute("data-mode")) this.textbox.value = "";
                const bounds = this.quill.getBounds(this.quill.selection.savedRange);
                if (bounds != null) this.position(bounds);
                this.textbox.select();
                this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${mode}`) || "");
                this.root.setAttribute("data-mode", mode);
            }
            restoreFocus() {
                this.quill.focus({
                    preventScroll: true
                });
            }
            save() {
                let {value} = this.textbox;
                switch (this.root.getAttribute("data-mode")) {
                  case "link":
                    {
                        const {scrollTop} = this.quill.root;
                        if (this.linkRange) {
                            this.quill.formatText(this.linkRange, "link", value, core_emitter.sources.USER);
                            delete this.linkRange;
                        } else {
                            this.restoreFocus();
                            this.quill.format("link", value, core_emitter.sources.USER);
                        }
                        this.quill.root.scrollTop = scrollTop;
                        break;
                    }

                  case "video":
                    value = extractVideoUrl(value);

                  case "formula":
                    {
                        if (!value) break;
                        const range = this.quill.getSelection(true);
                        if (range != null) {
                            const index = range.index + range.length;
                            this.quill.insertEmbed(index, this.root.getAttribute("data-mode"), value, core_emitter.sources.USER);
                            if (this.root.getAttribute("data-mode") === "formula") this.quill.insertText(index + 1, " ", core_emitter.sources.USER);
                            this.quill.setSelection(index + 2, core_emitter.sources.USER);
                        }
                        break;
                    }

                  default:
                }
                this.textbox.value = "";
                this.hide();
            }
        }
        function extractVideoUrl(url) {
            let match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
            if (match) return `${match[1] || "https"}://www.youtube.com/embed/${match[2]}?showinfo=0`;
            if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) return `${match[1] || "https"}://player.vimeo.com/video/${match[2]}/`;
            return url;
        }
        function fillSelect(select, values) {
            let defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            values.forEach((value => {
                const option = document.createElement("option");
                if (value === defaultValue) option.setAttribute("selected", "selected"); else option.setAttribute("value", String(value));
                select.appendChild(option);
            }));
        }
        const TOOLBAR_CONFIG = [ [ "bold", "italic", "link" ], [ {
            header: 1
        }, {
            header: 2
        }, "blockquote" ] ];
        class BubbleTooltip extends BaseTooltip {
            static TEMPLATE=[ '<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>" ].join("");
            constructor(quill, bounds) {
                super(quill, bounds);
                this.quill.on(core_emitter.events.EDITOR_CHANGE, ((type, range, oldRange, source) => {
                    if (type !== core_emitter.events.SELECTION_CHANGE) return;
                    if (range != null && range.length > 0 && source === core_emitter.sources.USER) {
                        this.show();
                        this.root.style.left = "0px";
                        this.root.style.width = "";
                        this.root.style.width = `${this.root.offsetWidth}px`;
                        const lines = this.quill.getLines(range.index, range.length);
                        if (lines.length === 1) {
                            const bounds = this.quill.getBounds(range);
                            if (bounds != null) this.position(bounds);
                        } else {
                            const lastLine = lines[lines.length - 1];
                            const index = this.quill.getIndex(lastLine);
                            const length = Math.min(lastLine.length() - 1, range.index + range.length - index);
                            const indexBounds = this.quill.getBounds(new Range(index, length));
                            if (indexBounds != null) this.position(indexBounds);
                        }
                    } else if (document.activeElement !== this.textbox && this.quill.hasFocus()) this.hide();
                }));
            }
            listen() {
                super.listen();
                this.root.querySelector(".ql-close").addEventListener("click", (() => {
                    this.root.classList.remove("ql-editing");
                }));
                this.quill.on(core_emitter.events.SCROLL_OPTIMIZE, (() => {
                    setTimeout((() => {
                        if (this.root.classList.contains("ql-hidden")) return;
                        const range = this.quill.getSelection();
                        if (range != null) {
                            const bounds = this.quill.getBounds(range);
                            if (bounds != null) this.position(bounds);
                        }
                    }), 1);
                }));
            }
            cancel() {
                this.show();
            }
            position(reference) {
                const shift = super.position(reference);
                const arrow = this.root.querySelector(".ql-tooltip-arrow");
                arrow.style.marginLeft = "";
                if (shift !== 0) arrow.style.marginLeft = `${-1 * shift - arrow.offsetWidth / 2}px`;
                return shift;
            }
        }
        class BubbleTheme extends BaseTheme {
            constructor(quill, options) {
                if (options.modules.toolbar != null && options.modules.toolbar.container == null) options.modules.toolbar.container = TOOLBAR_CONFIG;
                super(quill, options);
                this.quill.container.classList.add("ql-bubble");
            }
            extendToolbar(toolbar) {
                this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                if (toolbar.container != null) {
                    this.tooltip.root.appendChild(toolbar.container);
                    this.buildButtons(toolbar.container.querySelectorAll("button"), icons);
                    this.buildPickers(toolbar.container.querySelectorAll("select"), icons);
                }
            }
        }
        BubbleTheme.DEFAULTS = lodash_es_merge({}, BaseTheme.DEFAULTS, {
            modules: {
                toolbar: {
                    handlers: {
                        link(value) {
                            if (!value) this.quill.format("link", false, Quill.sources.USER); else this.quill.theme.tooltip.edit();
                        }
                    }
                }
            }
        });
        const snow_TOOLBAR_CONFIG = [ [ {
            header: [ "1", "2", "3", false ]
        } ], [ "bold", "italic", "underline", "link" ], [ {
            list: "ordered"
        }, {
            list: "bullet"
        } ], [ "clean" ] ];
        class SnowTooltip extends BaseTooltip {
            static TEMPLATE=[ '<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>' ].join("");
            preview=this.root.querySelector("a.ql-preview");
            listen() {
                super.listen();
                this.root.querySelector("a.ql-action").addEventListener("click", (event => {
                    if (this.root.classList.contains("ql-editing")) this.save(); else this.edit("link", this.preview.textContent);
                    event.preventDefault();
                }));
                this.root.querySelector("a.ql-remove").addEventListener("click", (event => {
                    if (this.linkRange != null) {
                        const range = this.linkRange;
                        this.restoreFocus();
                        this.quill.formatText(range, "link", false, core_emitter.sources.USER);
                        delete this.linkRange;
                    }
                    event.preventDefault();
                    this.hide();
                }));
                this.quill.on(core_emitter.events.SELECTION_CHANGE, ((range, oldRange, source) => {
                    if (range == null) return;
                    if (range.length === 0 && source === core_emitter.sources.USER) {
                        const [link, offset] = this.quill.scroll.descendant(Link, range.index);
                        if (link != null) {
                            this.linkRange = new Range(range.index - offset, link.length());
                            const preview = Link.formats(link.domNode);
                            this.preview.textContent = preview;
                            this.preview.setAttribute("href", preview);
                            this.show();
                            const bounds = this.quill.getBounds(this.linkRange);
                            if (bounds != null) this.position(bounds);
                            return;
                        }
                    } else delete this.linkRange;
                    this.hide();
                }));
            }
            show() {
                super.show();
                this.root.removeAttribute("data-mode");
            }
        }
        class SnowTheme extends BaseTheme {
            constructor(quill, options) {
                if (options.modules.toolbar != null && options.modules.toolbar.container == null) options.modules.toolbar.container = snow_TOOLBAR_CONFIG;
                super(quill, options);
                this.quill.container.classList.add("ql-snow");
            }
            extendToolbar(toolbar) {
                if (toolbar.container != null) {
                    toolbar.container.classList.add("ql-snow");
                    this.buildButtons(toolbar.container.querySelectorAll("button"), icons);
                    this.buildPickers(toolbar.container.querySelectorAll("select"), icons);
                    this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                    if (toolbar.container.querySelector(".ql-link")) this.quill.keyboard.addBinding({
                        key: "k",
                        shortKey: true
                    }, ((_range, context) => {
                        toolbar.handlers.link.call(toolbar, !context.format.link);
                    }));
                }
            }
        }
        SnowTheme.DEFAULTS = lodash_es_merge({}, BaseTheme.DEFAULTS, {
            modules: {
                toolbar: {
                    handlers: {
                        link(value) {
                            if (value) {
                                const range = this.quill.getSelection();
                                if (range == null || range.length === 0) return;
                                let preview = this.quill.getText(range);
                                if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) preview = `mailto:${preview}`;
                                const {tooltip} = this.quill.theme;
                                tooltip.edit("link", preview);
                            } else this.quill.format("link", false, Quill.sources.USER);
                        }
                    }
                }
            }
        });
        const snow = SnowTheme;
        core.register({
            "attributors/attribute/direction": DirectionAttribute,
            "attributors/class/align": AlignClass,
            "attributors/class/background": BackgroundClass,
            "attributors/class/color": ColorClass,
            "attributors/class/direction": DirectionClass,
            "attributors/class/font": FontClass,
            "attributors/class/size": SizeClass,
            "attributors/style/align": AlignStyle,
            "attributors/style/background": BackgroundStyle,
            "attributors/style/color": ColorStyle,
            "attributors/style/direction": DirectionStyle,
            "attributors/style/font": FontStyle,
            "attributors/style/size": SizeStyle
        }, true);
        core.register({
            "formats/align": AlignClass,
            "formats/direction": DirectionClass,
            "formats/indent": indent,
            "formats/background": BackgroundStyle,
            "formats/color": ColorStyle,
            "formats/font": FontClass,
            "formats/size": SizeClass,
            "formats/blockquote": blockquote,
            "formats/code-block": CodeBlock,
            "formats/header": header,
            "formats/list": ListItem,
            "formats/bold": bold,
            "formats/code": Code,
            "formats/italic": italic,
            "formats/link": Link,
            "formats/script": script,
            "formats/strike": strike,
            "formats/underline": underline,
            "formats/formula": formula,
            "formats/image": formats_image,
            "formats/video": video,
            "modules/syntax": Syntax,
            "modules/table": table,
            "modules/toolbar": Toolbar,
            "themes/bubble": BubbleTheme,
            "themes/snow": snow,
            "ui/icons": icons,
            "ui/picker": picker,
            "ui/icon-picker": icon_picker,
            "ui/color-picker": color_picker,
            "ui/tooltip": tooltip
        }, true);
        const quill_quill = core;
        const publisher = document.querySelector(".form-publisher");
        if (publisher !== null) {
            new quill_quill("#editor", {
                theme: "snow",
                placeholder: "⭐ Здесь вы можете добавить свою статью..."
            });
        }
        window["FLS"] = false;
        addLoadedClass();
        menuInit();
        spollers();
        tabs();
        formFieldsInit({
            viewPass: false,
            autoHeight: false
        });
        formSubmit();
        formRating();
    })();
})();